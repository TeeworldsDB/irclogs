00:10 < bridge> <deen> Full-time work on Github is probably cheating?
00:10 < bridge> <deen> https://cdn.discordapp.com/attachments/293493549758939136/1179922434833535016/Screenshot_2023-12-01_at_00.09.47.png?ex=657b8b66&is=65691666&hm=08f941e5dccaf8caf431c01afce260f54d09ac7a5b354c04955680be3fb94127&
00:16 < ChillerDragon> Is it grap share time?
00:16 < ChillerDragon> https://zillyhuhn.com/cs/.1701386257.png
00:18 < bridge> <blaiszephyr> whats in your guy's opinion the best way to parse json stuff into client? - never did it, wanna do it.
00:18 < ChillerDragon> in the ddnet client?
00:18 < ChillerDragon> there is a json parser already
00:18 < bridge> <blaiszephyr> y
00:18 < ChillerDragon> look at the server browser code on how its used
00:18 < bridge> <blaiszephyr> aight - ty
02:42 < bridge> <Mr.Gh0s7> man it's already 1st December
04:20 < bridge> <lllggghhhaaa> I'm implementing some commands, how do I keep them stored in settings_ddnet.cfg?
08:08 < bridge> <gravitycontained> 10+ / day on average is crazy
08:08 < bridge> <gravitycontained> very nice grid üòÅ
09:20 < bridge> <Jupstar ‚ú™> FFR
09:35 < bridge> <ryozuki> @jupeyy_keks do aoc
09:35 < bridge> <ryozuki> https://adventofcode.com/
09:35 < bridge> <ryozuki> i got such a beautiful answer of first in rust
09:35 < bridge> <ryozuki> but damn doing this in asm will be hard
09:36 < bridge> <ryozuki> i need a hashmap xddd
09:36 < bridge> <Jupstar ‚ú™> it has so much text, i'm too lazy to read it all
09:41 < bridge> <Jupstar ‚ú™> ok gpt solved the puzzle. so not worth my time
09:41 < bridge> <Jupstar ‚ú™> üòè
09:44 < bridge> <ryozuki> boring
09:45 < bridge> <ryozuki> well i need a C guy or girl to do it
09:45 < bridge> <ryozuki> so i can beat it
09:46 < bridge> <ryozuki> @jupeyy_keks for ffr u can read my blog
09:46 < bridge> <ryozuki> üò¨
09:46 < bridge> <ryozuki> joking ill look later its gym time
10:07 < bridge> <Ewan> gm
10:45 < bridge> <Jupstar ‚ú™> today i had a reverse deja vu again:
10:45 < bridge> <Jupstar ‚ú™> I thought i've done exactly the same before but came to a different conclusion in the end
11:02 < bridge> <ryozuki> xd
11:54 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180099535930920970/image.png?ex=657c3056&is=6569bb56&hm=7291c83854ad470226e7683bc5fb5505416ae3d239852e52e86de07cf1a67cf4&
11:54 < bridge> <ryozuki> @deen does ur work squash commits
11:54 < bridge> <ryozuki> i dont remember if squashed count as 1 here
11:55 < bridge> <ryozuki> chiller probs just does lot of small commits xd
11:55 < bridge> <ryozuki> mine squashes
11:57 < bridge> <deen> I can squash, but usually don't. Each commit should make sense in isolation
12:03 < bridge> <ryozuki> ic
12:03 < bridge> <ryozuki> i think i follow more the philosophy of, a pr itself should make sense in isolatio, so inside it i make progress commits
12:03 < bridge> <ryozuki> then they get squashed to the final clean version
12:03 < bridge> <ryozuki> or rebased
12:04 < bridge> <ryozuki> ofc some stuff is to complex
12:04 < bridge> <ryozuki> omg a new firefox update
12:04 < bridge> <ryozuki> ill do it tomorrow xd
12:04 < bridge> <Jupstar ‚ú™> I follow a repo should make sense in isolation
12:04 < bridge> <ryozuki> u mean a pr
12:05 < bridge> <Jupstar ‚ú™> The full repo
12:05 < bridge> <ryozuki> xddd
12:10 < bridge> <Jupstar ‚ú™> My shower me was super clever today and noticed my current concept is really too overcomplicated and bloated. Now I'm super demotivated to fix it
12:11 < bridge> <Jupstar ‚ú™> @ryozuki you have to do some stuff for ffr xd
12:11 < bridge> <Jupstar ‚ú™> I'm out of ideas
12:15 < bridge> <ryozuki> xd
12:16 < bridge> <ryozuki> https://without.boats/blog/three-problems-of-pinning/
12:17 < bridge> <ryozuki> https://mcyoung.xyz/2023/11/27/simd-base64/
12:25 < bridge> <ryozuki> https://blog.marcocantu.com/blog/2023-november-turbopascal40.html
12:25 < bridge> <ryozuki> xd
12:25 < bridge> <ryozuki> Turbo Pascal was introduced by Borland in November 1983. It's officially turning 40 years old this month.
12:27 < bridge> <Jupstar ‚ú™> I mean this is kinda rust related considered rust took quite a few concepts from it üòâ
12:29 < bridge> <learath2> Gpt truly ruined this industry forever
12:30 < bridge> <learath2> I'll switch professions and become a baker
12:31 < bridge> <Jupstar ‚ú™> Just like the baker will be useless, the coder will be. So you are free to do what you like
12:33 < bridge> <learath2> Chatgpt is awful at anything food related
12:33 < bridge> <learath2> Atleast for now maybe someone already has foodgpt in training üòÑ
12:34 < bridge> <deen> This is annoying with `git bisect`, have to use `--first-parent` for that
12:34 < bridge> <teero777> Ask it what chemicals you need for making a mix that appeals to the human taste xd
12:35 < bridge> <deen> My main insight about AoC today was how to make a shebang for a SQL file üòÑ https://github.com/def-/adventofcode-2023
12:35 < bridge> <Jupstar ‚ú™> Well ai is ofc also trained for real motions at some point
12:35 < bridge> <learath2> It fails miserably at trying to make anything balanced. It'll get the ingredients right but the ratios and portions will be all over the place
12:35 < bridge> <teero777> oh lol
12:35 < bridge> <teero777> 2kg of sugar lesgo
12:36 < bridge> <learath2> General purpose robots taking over baking is the last thing I'd be worried about. Robotics is by far the jankest of all tech
12:36 < bridge> <teero777> true
12:37 < bridge> <teero777> Software cooler :kek:
12:38 < bridge> <teero777> But you cant flex to normies with it
12:38 < bridge> <learath2> Used to be. Now everyone is just using gpt for everything
12:39 < bridge> <Jupstar ‚ú™> I dunno. I didn't underestimate it. Nature is basically nothing else than robotic+ ai
12:39 < bridge> <Jupstar ‚ú™> Wouldn't
12:40 < bridge> <learath2> Natures way of locomotion has nothing to do with the robotics we currently have access to. Robots have like 1 point in dex while humans have 100
12:41 < bridge> <learath2> Special purpose robots will definitely take over most jobs but those don't need any ai sauce
12:41 < bridge> <Jupstar ‚ú™> Yes but is that really a point against robotics?
12:41 < bridge> <Jupstar ‚ú™> It doesn't have the disadvantage of evolution
12:42 < bridge> <learath2> Yes, the strict limits on their motion is a huge issue. Muscles are far more flexible than servos
12:42 < bridge> <Jupstar ‚ú™> That's not directly the point. A kitchen ai must still learn to act differently on different scenarios and normal programming simply is bad at this
12:43 < bridge> <Jupstar ‚ú™> Making food in mass production ofc already happens
12:43 < bridge> <learath2> The cutting edge general purpose robots have 1/10th of a humans output folding a shirt e.g.
12:44 < bridge> <Jupstar ‚ú™> I mean that it's not happening tomorrow is clear. But let's say the next 10 years
12:44 < bridge> <learath2> If you really want to shoehorn ai into it ai orchestrating a bunch of special purpose robots would probably be the goal unless a significant leap in robotics is upon us that I completely missed
12:46 < bridge> <Jupstar ‚ú™> Sadly these hard coded robots are often not very flexible and thus only useful for very specific designed tasks.. thats nothing bad, and often probably more efficient.
12:46 < bridge> <Jupstar ‚ú™> 
12:46 < bridge> <Jupstar ‚ú™> But the robot that will do your house works will not be this i guess^^
12:47 < bridge> <Jupstar ‚ú™> So i guess the interest in this general purpose designs will sky rocket this century
12:47 < bridge> <learath2> I don't expect any robot to take over my housework completely for atleast 2 decades. Honestly they are faaar too clumsy and slow
12:47 < bridge> <Jupstar ‚ú™> And decade
12:48 < bridge> <learath2> Though yeah it only takes a handful of breakthroughs for that to change
12:48 < bridge> <Jupstar ‚ú™> We still have 5 years
12:48 < bridge> <Jupstar ‚ú™> Until Detroit become human takes place
12:48 < bridge> <Jupstar ‚ú™> Xdd
12:49 < bridge> <Jupstar ‚ú™> Sag wait 15 years
12:49 < bridge> <Jupstar ‚ú™> 2038
12:49 < bridge> <Jupstar ‚ú™> Ah wait 15 years
12:49 < bridge> <learath2> You seem far too excited for what will probably be a catastrophic event for the working class üòÑ
12:50 < bridge> <Jupstar ‚ú™> It's the only solution against human slavery
12:50 < bridge> <Jupstar ‚ú™> i don't see a better one
12:50 < bridge> <Jupstar ‚ú™> But yeah. I'm team machine
12:50 < bridge> <learath2> If you think the people with the money will let us live in some startrek utopia you will be very surprised
12:50 < bridge> <Jupstar ‚ú™> Humans have the disadvantage of being a nature being
12:51 < bridge> <Jupstar ‚ú™> Too much hate inside us
12:51 < bridge> <Jupstar ‚ú™> Hard to predict
12:52 < bridge> <learath2> Not extremely hard to extrapolate from how the elite has acted in the last 2 millennia
12:53 < bridge> <Jupstar ‚ú™> That's true, but if the ai is more intelligent than a human, we don't know what happens anyway.. why should it not be able to overthink whatever it was trained with
12:54 < bridge> <learath2> They'll live in supercities with their ai robots and we'll live in slums and be used as court jesters
12:54 < bridge> <Jupstar ‚ú™> Possible
12:54 < bridge> <Jupstar ‚ú™> Maybe you will be one of them
12:54 < bridge> <Jupstar ‚ú™> And change it
12:55 < bridge> <Jupstar ‚ú™> Not everyone is a psychopath like musk and consorts
12:55 < bridge> <learath2> Probably. So I'd rather the ai revolution chill for a little bit so I don't have to wear one of those jester outfits
12:56 < bridge> <learath2> Oh you meant I'd be one of the megarich? I'd just blast myself off to mars so I don't die in the inevitable civil war
12:56 < bridge> <Jupstar ‚ú™> Yes why not.. just gotta marry rich girl xdd
12:57 < bridge> <Jupstar ‚ú™> I feel like it's more likely the poor ones will simply be sent to Mars üòÇ
12:57 < bridge> <Jupstar ‚ú™> Who wants to be there xdd
12:57 < bridge> <learath2> Ooor we can chill with all the AI and I can live a normal life then you can make all the cool robots after I die
12:58 < bridge> <learath2> That's actually viable. Just ship all the poors of to some mining camp on another planet. Not that we'd need the ore, just so they are out of the way and have work
12:59 < bridge> <Jupstar ‚ú™> Without ai you will lose 50% of your remaining awake life time to your job
12:59 < bridge> <ryozuki> @learath2 when  aoc
12:59 < bridge> <learath2> C'est la vie
13:00 < bridge> <learath2> Well c'est la social contract under capitalism to be more exact
13:00 < bridge> <Jupstar ‚ú™> Xd
13:00 < bridge> <ryozuki> nice
13:00 < bridge> <learath2> Oh maybe this year I can follow it to the end. I don't have anything to do
13:01 < bridge> <ryozuki> go
13:01 < bridge> <ryozuki> do it in C
13:01 < bridge> <ryozuki> share it
13:01 < bridge> <learath2> And I wanted to practice my algs a bit
13:01 < bridge> <ryozuki> i bench
13:01 < bridge> <learath2> I was thinking Python this year
13:01 < bridge> <ryozuki> :c
13:01 < bridge> <learath2> I can do C too sure
13:01 < bridge> <ryozuki> does c has btrees in std
13:02 < bridge> <ryozuki> the program should load the input from a file
13:02 < bridge> <ryozuki> called input.txt
13:02 < bridge> <learath2> :kekW:
13:02 < bridge> <ryozuki> xd
13:03 < bridge> <learath2> You want btree, you make btree
13:03 < bridge> <learath2> Honestly, not much of a point benching what I'd make against properly optimized data structures
13:04 < bridge> <ryozuki> true
13:04 < bridge> <learath2> Most proper libraries use hand vectorized code. I can't compete with that every day on every task üòÑ
13:04 < bridge> <ryozuki> i was going to also use a optimized allocator and hashing algo
13:04 < bridge> <ryozuki> tryharding
13:04 < bridge> <ryozuki> @learath2 how hard is it to use mimalloc on C
13:04 < bridge> <ryozuki> well just thinking about linking and stuff makes me already pain
13:05 < bridge> <learath2> It should just be linking it in and it works
13:05 < bridge> <learath2> I bet you can even just ld preload it like with jemalloc
13:07 < bridge> <Jupstar ‚ú™> You don't need python. Gpt is really good in it xddd
13:07 < bridge> <Jupstar ‚ú™> Ok sry i quickly rq
13:07 < bridge> <ryozuki> ‚ùØ hyperfine -N -w 5 ./target/release/rust-aoc
13:07 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
13:07 < bridge> <ryozuki>   Time (mean ¬± œÉ):       1.2 ms ¬±   0.1 ms    [User: 1.0 ms, System: 0.2 ms]
13:07 < bridge> <ryozuki>   Range (min ‚Ä¶ max):     1.1 ms ‚Ä¶   1.7 ms    2654 runs
13:07 < bridge> <ryozuki> hmm
13:08 < bridge> <learath2> 1.1ms sounds acceptable for like anything üòÑ
13:08 < bridge> <Jupstar ‚ú™> Nice are we doing a competition about speed?
13:08 < bridge> <ryozuki> yes
13:08 < bridge> <learath2> I wonder if gpt can beat ryo
13:08 < bridge> <ryozuki> this is not a optimized version
13:08 < bridge> <ryozuki> its my first naive solution
13:08 < bridge> <ryozuki> but i guess its p optimized
13:09 < bridge> <ryozuki> im using a btreemap
13:09 < bridge> <ryozuki> let me put everything in proper iterators
13:09 < bridge> <ryozuki> i wanna see if it changes
13:09 < bridge> <learath2> All the optimization juice is in here
13:09 < bridge> <learath2> Atleast all the significant part
13:10 < bridge> <Jupstar ‚ú™> ```py
13:10 < bridge> <Jupstar ‚ú™> 
13:10 < bridge> <Jupstar ‚ú™> def sum_calibration_values(calibration_document):
13:10 < bridge> <Jupstar ‚ú™>     total_sum = 0
13:10 < bridge> <Jupstar ‚ú™>     for line in calibration_document:
13:10 < bridge> <Jupstar ‚ú™>         digits = [char for char in line if char.isdigit()]
13:10 < bridge> <Jupstar ‚ú™>         if digits:
13:10 < bridge> <Jupstar ‚ú™>             first_digit = digits[0]
13:10 < bridge> <Jupstar ‚ú™>             last_digit = digits[-1]
13:11 < bridge> <Jupstar ‚ú™>             two_digit_number = int(first_digit + last_digit)
13:11 < bridge> <Jupstar ‚ú™>             total_sum += two_digit_number
13:11 < bridge> <Jupstar ‚ú™>     return total_sum
13:11 < bridge> <Jupstar ‚ú™> 
13:11 < bridge> <Jupstar ‚ú™> # Example usage:
13:11 < bridge> <Jupstar ‚ú™> calibration_document = [
13:11 < bridge> <Jupstar ‚ú™>     "1abc2",
13:11 < bridge> <Jupstar ‚ú™>     "pqr3stu8vwx",
13:11 < bridge> <Jupstar ‚ú™>     "a1b2c3d4e5f",
13:11 < bridge> <Jupstar ‚ú™>     "treb7uchet"
13:11 < bridge> <Jupstar ‚ú™> ]
13:11 < bridge> <Jupstar ‚ú™> 
13:11 < bridge> <Jupstar ‚ú™> result = sum_calibration_values(calibration_document)
13:11 < bridge> <Jupstar ‚ú™> print("Total sum of calibration values:", result)
13:11 < bridge> <Jupstar ‚ú™> ```
13:11 < bridge> <Jupstar ‚ú™> this was from gpt
13:11 < bridge> <ryozuki> pls make sure it loads a file called input.txt
13:11 < bridge> <Jupstar ‚ú™> i dont even know if it works for non example input xD
13:11 < bridge> <ryozuki> and only outputs the result number
13:12 < bridge> <Jupstar ‚ú™> do i look like a pyson dev.
13:12 < bridge> <Jupstar ‚ú™> gpt is down for me, cant do it
13:13 < bridge> <learath2> I can't wait for the future where the company just sends everyone home when gpt goes down because no one can code without it anymore
13:13 < bridge> <Jupstar ‚ú™> same
13:13 < bridge> <Jupstar ‚ú™> and at home i do the real fun stuff
13:14 < bridge> <Jupstar ‚ú™> what awesome times that will be
13:15 < bridge> <learath2> Ur ofc not getting paid for those hours
13:15 < bridge> <learath2> Imagine thinking capitalists will pay you for nonproductive hours :xDe:
13:16 < bridge> <Jupstar ‚ú™> i dont think you understand how that works
13:16 < bridge> <Jupstar ‚ú™> if you have a skill nobody has. you can do whatever you want. because you are basically their golden shovel
13:16 < bridge> <Jupstar ‚ú™> without you they can't even dig
13:17 < bridge> <Jupstar ‚ú™> if you have a job that is very common, then u the real slave
13:17 < bridge> <Jupstar ‚ú™> that's where capitalism shows it's evilness
13:17 < bridge> <ryozuki> my iterator version is slower :o
13:17 < bridge> <ryozuki> || ```rust
13:17 < bridge> <ryozuki> let result = input.lines().fold(0u32, |acc, line| {
13:17 < bridge> <ryozuki>         let indices: BTreeMap<_, _> = numbers
13:17 < bridge> <ryozuki>             .keys()
13:17 < bridge> <ryozuki>             .flat_map(|x| line.match_indices(*x))
13:17 < bridge> <ryozuki>             .collect();
13:17 < bridge> <ryozuki> 
13:17 < bridge> <ryozuki>         let first = numbers.get(indices.first_key_value().unwrap().1).unwrap();
13:17 < bridge> <ryozuki>         let last = numbers.get(indices.last_key_value().unwrap().1).unwrap();
13:17 < bridge> <ryozuki> 
13:17 < bridge> <ryozuki>         acc + first * 10 + last
13:17 < bridge> <ryozuki>     });
13:17 < bridge> <ryozuki> ``` ||
13:18 < bridge> <learath2> A skill in prompting chatgpt is much more replaceable than actually being able to code
13:18 < bridge> <ryozuki> || ```rust
13:18 < bridge> <ryozuki>  let mut result = 0;
13:18 < bridge> <ryozuki>     let mut indices = BTreeMap::new();
13:18 < bridge> <ryozuki>     for line in input.lines() {
13:18 < bridge> <ryozuki>         for x in numbers.keys() {
13:18 < bridge> <ryozuki>             indices.extend(line.match_indices(x));
13:18 < bridge> <ryozuki>         }
13:18 < bridge> <ryozuki> 
13:18 < bridge> <ryozuki>         let first = numbers.get(indices.first_key_value().unwrap().1).unwrap();
13:18 < bridge> <ryozuki>         let last = numbers.get(indices.last_key_value().unwrap().1).unwrap();
13:18 < bridge> <ryozuki> 
13:18 < bridge> <ryozuki>         result += first * 10 + last;
13:18 < bridge> <ryozuki>         indices.clear();
13:18 < bridge> <ryozuki>     }
13:18 < bridge> <ryozuki> ``` ||
13:18 < bridge> <ryozuki> this is faster
13:18 < bridge> <ryozuki> 1.2ms vs 1.5ms
13:18 < bridge> <ryozuki> unsafe on the unwrap changes nothing
13:19 < bridge> <learath2> Have you run it a couple more times?
13:19 < bridge> <Jupstar ‚ú™> correct, but the fact you still have to think is already smth most can't do üòÇ
13:19 < bridge> <ryozuki> hyperfine does that
13:19 < bridge> <ryozuki> it ran it 2700 times
13:19 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
13:19 < bridge> <ryozuki>   Time (mean ¬± œÉ):       1.5 ms ¬±   0.1 ms    [User: 1.2 ms, System: 0.2 ms]
13:19 < bridge> <ryozuki>   Range (min ‚Ä¶ max):     1.3 ms ‚Ä¶   1.9 ms    2245 runs
13:19 < bridge> <ryozuki> iterator
13:19 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
13:19 < bridge> <ryozuki>   Time (mean ¬± œÉ):       1.2 ms ¬±   0.1 ms    [User: 1.0 ms, System: 0.2 ms]
13:19 < bridge> <ryozuki>   Range (min ‚Ä¶ max):     1.1 ms ‚Ä¶   2.6 ms    2706 runs
13:19 < bridge> <ryozuki> for loop
13:20 < bridge> <learath2> Curious, maybe check the assembly generated?
13:20 < bridge> <Jupstar ‚ú™> can u send me the input file? without account i cant seem to access it
13:21 < bridge> <Jupstar ‚ú™> i make you the fastest ever
13:21 < bridge> <ryozuki> but ur computer specs is diferent
13:21 < bridge> <Jupstar ‚ú™> i give u the code
13:21 < bridge> <ryozuki> https://gist.github.com/edg-l/5c65631ed4d9e736187058a955f97556
13:21 < bridge> <learath2> The fastest ever is just puts the result
13:21 < bridge> <ryozuki> result is 54277
13:22 < bridge> <ryozuki> (note it does nto work for others cuz each gets their own input)
13:22 < bridge> <learath2> `puts("54277")` beat this one nerd
13:22 < bridge> <ryozuki> xd
13:22 < bridge> <ryozuki> why call puts use  a syscall
13:23 < bridge> <learath2> Portable üòÑ
13:23 < bridge> <ryozuki> using ahash on the numbers hashmap doesnt help
13:24 < bridge> <Jupstar ‚ú™> @ryozuki what is the assignment to numbers in your example?
13:24 < bridge> <Jupstar ‚ú™> you didnt send full code xd
13:25 < bridge> <ryozuki> ```
13:25 < bridge> <ryozuki>     let mut numbers = HashMap::with_capacity(18);
13:25 < bridge> <ryozuki>     numbers.insert("one", 1);
13:25 < bridge> <ryozuki>     numbers.insert("two", 2);
13:25 < bridge> <ryozuki>     numbers.insert("three", 3);
13:25 < bridge> <ryozuki>     numbers.insert("four", 4);
13:25 < bridge> <ryozuki>     numbers.insert("five", 5);
13:25 < bridge> <ryozuki>     numbers.insert("six", 6);
13:25 < bridge> <ryozuki>     numbers.insert("seven", 7);
13:25 < bridge> <ryozuki>     numbers.insert("eight", 8);
13:25 < bridge> <ryozuki>     numbers.insert("nine", 9);
13:25 < bridge> <ryozuki>     numbers.insert("1", 1);
13:25 < bridge> <ryozuki>     numbers.insert("2", 2);
13:25 < bridge> <ryozuki>     numbers.insert("3", 3);
13:25 < bridge> <ryozuki>     numbers.insert("4", 4);
13:25 < bridge> <ryozuki>     numbers.insert("5", 5);
13:25 < bridge> <ryozuki>     numbers.insert("6", 6);
13:25 < bridge> <ryozuki>     numbers.insert("7", 7);
13:25 < bridge> <ryozuki>     numbers.insert("8", 8);
13:25 < bridge> <ryozuki>     numbers.insert("9", 9);
13:25 < bridge> <ryozuki> ```
13:25 < bridge> <ryozuki> xd
13:25 < bridge> <ryozuki> || ```rust
13:25 < bridge> <ryozuki> use std::{
13:25 < bridge> <ryozuki>     collections::{BTreeMap, HashMap},
13:25 < bridge> <ryozuki>     error::Error,
13:25 < bridge> <ryozuki> };
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> use mimalloc::MiMalloc;
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> #[global_allocator]
13:25 < bridge> <ryozuki> static GLOBAL: MiMalloc = MiMalloc;
13:25 < bridge> <ryozuki> 
13:26 < bridge> <ryozuki> fn main() -> Result<(), Box<dyn Error>> {
13:26 < bridge> <ryozuki>     let input = std::fs::read_to_string("input.txt")?;
13:26 < bridge> <ryozuki> 
13:26 < bridge> <ryozuki>     let mut numbers = HashMap::with_capacity(18);
13:26 < bridge> <ryozuki>     numbers.insert("one", 1);
13:26 < bridge> <ryozuki>     numbers.insert("two", 2);
13:26 < bridge> <ryozuki>     numbers.insert("three", 3);
13:26 < bridge> <ryozuki>     numbers.insert("four", 4);
13:26 < bridge> <ryozuki>     numbers.insert("five", 5);
13:26 < bridge> <ryozuki>     numbers.insert("six", 6);
13:26 < bridge> <ryozuki>     numbers.insert("seven", 7);
13:26 < bridge> <ryozuki>     numbers.insert("eight", 8);
13:26 < bridge> <ryozuki>     numbers.insert("nine", 9);
13:26 < bridge> <ryozuki>     numbers.insert("1", 1);
13:26 < bridge> <ryozuki>     numbers.insert("2", 2);
13:26 < bridge> <ryozuki>     numbers.insert("3", 3);
13:26 < bridge> <ryozuki>     numbers.insert("4", 4);
13:26 < bridge> <ryozuki>     numbers.insert("5", 5);
13:26 < bridge> <ryozuki>     numbers.insert("6", 6);
13:26 < bridge> <ryozuki>     numbers.insert("7", 7);
13:26 < bridge> <ryozuki> full code
13:26 < bridge> <ryozuki> lmao
13:26 < bridge> <ryozuki> oh wait
13:26 < bridge> <ryozuki> rayon
13:26 < bridge> <ryozuki> its threads time
13:27 < bridge> <learath2> Did you find out why slower?
13:28 < bridge> <learath2> This task is so quick that I would think spinning up a thread and synchronization overhead might make it worse
13:29 < bridge> <ryozuki> one thing i noted is
13:29 < bridge> <ryozuki> im doing the sum in the fold body
13:29 < bridge> <ryozuki> while i can just return the result
13:29 < bridge> <ryozuki> and do .sum
13:29 < bridge> <ryozuki> ```
13:29 < bridge> <ryozuki>     let result: u32 = input.lines().par_bridge().fold(|| 0u32, |acc, line| {
13:29 < bridge> <ryozuki>         let indices: BTreeMap<_, _> = numbers
13:29 < bridge> <ryozuki>             .keys()
13:29 < bridge> <ryozuki>             .flat_map(|x| line.match_indices(*x))
13:29 < bridge> <ryozuki>             .collect();
13:29 < bridge> <ryozuki> 
13:29 < bridge> <ryozuki>         let first = numbers.get(indices.first_key_value().unwrap().1).unwrap();
13:29 < bridge> <ryozuki>         let last = numbers.get(indices.last_key_value().unwrap().1).unwrap();
13:29 < bridge> <ryozuki> 
13:29 < bridge> <ryozuki>         first * 10 + last
13:29 < bridge> <ryozuki>     }).sum();
13:29 < bridge> <ryozuki> ```
13:29 < bridge> <ryozuki> this is faster
13:29 < bridge> <ryozuki> rayon
13:30 < bridge> <ryozuki> 1.1ms
13:30 < bridge> <ryozuki> wait
13:30 < bridge> <ryozuki> i dont need fold at all
13:30 < bridge> <ryozuki> ```rust
13:30 < bridge> <ryozuki> let result: u32 = input.lines().par_bridge().map(|line| {
13:30 < bridge> <ryozuki>         let indices: BTreeMap<_, _> = numbers
13:30 < bridge> <ryozuki>             .keys()
13:30 < bridge> <ryozuki>             .flat_map(|x| line.match_indices(*x))
13:30 < bridge> <ryozuki>             .collect();
13:30 < bridge> <ryozuki> 
13:30 < bridge> <ryozuki>         let first = numbers.get(indices.first_key_value().unwrap().1).unwrap();
13:30 < bridge> <ryozuki>         let last = numbers.get(indices.last_key_value().unwrap().1).unwrap();
13:30 < bridge> <ryozuki> 
13:30 < bridge> <ryozuki>         first * 10 + last
13:30 < bridge> <ryozuki>     }).sum();
13:30 < bridge> <ryozuki> ```
13:30 < bridge> <ryozuki> same speed
13:30 < bridge> <ryozuki> xd
13:30 < bridge> <ryozuki> 1.1
13:30 < bridge> <ryozuki> without rayon 1.5ms
13:31 < bridge> <learath2> Wasnt your attempt without iterators also 1.1?
13:31 < bridge> <ryozuki> 1.2
13:31 < bridge> <Jupstar ‚ú™> lol was about to
14:09 < bridge> <Jupstar ‚ú™> ok i took your solution and tried to remove the btree:
14:09 < bridge> <Jupstar ‚ú™> 
14:09 < bridge> <Jupstar ‚ú™> ```rs
14:09 < bridge> <Jupstar ‚ú™> let result: i32 = input
14:09 < bridge> <Jupstar ‚ú™>             .par_lines()
14:09 < bridge> <Jupstar ‚ú™>             .map(|line| {
14:09 < bridge> <Jupstar ‚ú™>                 let matches = numbers.keys().map(|x| line.match_indices(x));
14:09 < bridge> <Jupstar ‚ú™>                 let m = matches.flatten().peekable();
14:09 < bridge> <Jupstar ‚ú™> 
14:09 < bridge> <Jupstar ‚ú™>                 let (min, max) = match m.minmax_by_key(|x| x.0) {
14:09 < bridge> <Jupstar ‚ú™>                     MinMaxResult::NoElements => todo!(),
14:09 < bridge> <Jupstar ‚ú™>                     MinMaxResult::OneElement(min) => (min, min),
14:09 < bridge> <Jupstar ‚ú™>                     MinMaxResult::MinMax(min, max) => (min, max),
14:09 < bridge> <Jupstar ‚ú™>                 };
14:09 < bridge> <Jupstar ‚ú™> 
14:09 < bridge> <Jupstar ‚ú™>                 let first = numbers.get(min.1).unwrap();
14:09 < bridge> <Jupstar ‚ú™>                 let last = numbers.get(max.1).unwrap();
14:09 < bridge> <Jupstar ‚ú™> 
14:09 < bridge> <Jupstar ‚ú™>                 first * 10 + last
14:09 < bridge> <Jupstar ‚ú™>             })
14:09 < bridge> <Jupstar ‚ú™>             .sum();
14:09 < bridge> <Jupstar ‚ú™> ```
14:09 < bridge> <Jupstar ‚ú™> 
14:09 < bridge> <Jupstar ‚ú™> i wonder if that makes any difference at all
14:09 < bridge> <Jupstar ‚ú™> i also used itertools
14:09 < bridge> <ryozuki> ah
14:10 < bridge> <ryozuki> oh
14:10 < bridge> <ryozuki> i used par_bridge
14:10 < bridge> <ryozuki> not par lines
14:10 < bridge> <ryozuki> @jupeyy_keks 1.1ms
14:10 < bridge> <ryozuki> same
14:10 < bridge> <Jupstar ‚ú™> rip xdd
14:11 < bridge> <Jupstar ‚ú™> maybe 2700 runs are not enough anyway
14:11 < bridge> <Jupstar ‚ú™> too much noise
14:11 < bridge> <Jupstar ‚ú™> or the input is too small üòÑ
14:11 < bridge> <ryozuki> hyperfine accounts for that
14:11 < bridge> <ryozuki> it does warmup too
14:11 < bridge> <Jupstar ‚ú™> oh ok
14:11 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
14:11 < bridge> <ryozuki>   Time (mean ¬± œÉ):       1.1 ms ¬±   0.1 ms    [User: 1.3 ms, System: 3.1 ms]
14:11 < bridge> <ryozuki>   Range (min ‚Ä¶ max):     1.0 ms ‚Ä¶   2.2 ms    2495 runs
14:12 < bridge> <Jupstar ‚ú™> well then heap allocations are simply too cheap when filled
14:12 < bridge> <ryozuki> ‚ùØ hyperfine -N -w 5 -r 10000 ./target/release/rust-aoc
14:12 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
14:12 < bridge> <ryozuki>   Time (mean ¬± œÉ):       1.1 ms ¬±   0.1 ms    [User: 1.2 ms, System: 3.0 ms]
14:12 < bridge> <ryozuki>   Range (min ‚Ä¶ max):     1.0 ms ‚Ä¶   4.0 ms    10000 runs
14:12 < bridge> <ryozuki> i forced 10k
14:12 < bridge> <Jupstar ‚ú™> tho filling the btree should have been slower  üòÆ
14:13 < bridge> <Jupstar ‚ú™> probs not significant enough, since we talk about 2-3 elements
14:13 < bridge> <ryozuki> > Currently, our implementation simply performs naive linear search. This provides excellent performance on small nodes of elements which are cheap to compare. However in the future we would like to further explore choosing the optimal search strategy based on the choice of B, and possibly other factors. Using linear search, searching for a random element is expected to take B * log(n) comparisons, which is generally worse than a BST. In practice, 
14:13 < bridge> <ryozuki> omg
14:13 < bridge> <ryozuki> mimalloc is actually slower
14:14 < bridge> <Jupstar ‚ú™> he had that quote ready xdd
14:14 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
14:14 < bridge> <ryozuki>   Time (mean ¬± œÉ):     971.1 ¬µs ¬± 110.5 ¬µs    [User: 1355.7 ¬µs, System: 2347.9 ¬µs]
14:14 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   794.9 ¬µs ‚Ä¶ 2960.6 ¬µs    10000 runs
14:14 < bridge> <ryozuki> my solution
14:14 < bridge> <ryozuki> without mimalloc
14:14 < bridge> <ryozuki> i need to try a bump allocator
14:14 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
14:14 < bridge> <ryozuki>   Time (mean ¬± œÉ):     927.1 ¬µs ¬± 102.4 ¬µs    [User: 1284.5 ¬µs, System: 2129.9 ¬µs]
14:14 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   774.1 ¬µs ‚Ä¶ 3706.6 ¬µs    10000 runs
14:14 < bridge> <ryozuki> @jupeyy_keks ur solution
14:15 < bridge> <ryozuki> using lto on both obviously
14:15 < bridge> <ryozuki> codegen units 1 too
14:15 < bridge> <ryozuki> and native march
14:15 < bridge> <Jupstar ‚ú™> lmao, so even slower
14:16 < bridge> <Jupstar ‚ú™> ok lower min
15:17 < bridge> <j.0u> how can i create popup in ddnet
15:17 < bridge> <j.0u> is there's a tutorial or something?
15:17 < bridge> <Jupstar ‚ú™> you mean a GUI popup?
15:17 < bridge> <j.0u> yes
15:17 < bridge> <Jupstar ‚ú™> or like a notification?
15:18 < bridge> <j.0u> like the confirm popup
15:18 < bridge> <Jupstar ‚ú™> i guess the easiest is too search the string that was used in any confirm popup and copy that code üòÑ
15:19 < bridge> <j.0u> ye but the way to render :.), maybe put the function in OnRender?
15:19 < bridge> <Jupstar ‚ú™> yeah put it somewhere that is called onrender or render
15:20 < bridge> <Jupstar ‚ú™> if you want to have ingame popups that harder tho
15:20 < bridge> <Jupstar ‚ú™> dunno where you currently add this popup
15:21 < bridge> <j.0u> is it possible to add it in OnInit ? XDD
15:21 < bridge> <j.0u> i wanna like a welcome popup
15:21 < bridge> <ryozuki> || welcome to my bot client üò¨ || @jupeyy_keks
15:22 < bridge> <j.0u> funny
15:22 < bridge> <ryozuki> 99% of time its true üò¨
15:23 < bridge> <j.0u> yea bro i will put an aimbot in that popup who knows
15:23 < bridge> <j.0u> creating popups will gimme a knowledge how to destroy the game hahahha
15:24 < bridge> <j.0u> :brownbear:
15:24 < bridge> <ryozuki> thats not what i meant bro
15:24 < bridge> <ryozuki> the popup is unrelated
15:24 < bridge> <ryozuki> anyway its a joke
15:24 < bridge> <ryozuki> cuz most random ppl coming asking for advice are always doing client side code and often making bots
15:25 < bridge> <j.0u> yup but i think not about popups right?
15:25 < bridge> <Jupstar ‚ú™> u could add it to the welcome popup
15:56 < bridge> <ryozuki> https://github.com/osimon8/CombinatorC
15:56 < bridge> <ryozuki> @jupeyy_keks aoc
15:56 < bridge> <ryozuki> ill try it
15:57 < bridge> <ReiTW> Lool so cool
15:57 < bridge> <ryozuki> https://github.com/misprit7/computerraria
15:58 < bridge> <ryozuki> @chairn for ur class
16:06 < bridge> <ryozuki> @jupeyy_keks  861.2 ¬µs
16:06 < bridge> <ryozuki> using PGO
16:13 < bridge> <Jupstar ‚ú™> Does it run inside factario or just for modding?
16:14 < bridge> <ryozuki> ? it makes a factorio blueprint
16:14 < bridge> <ryozuki> which is a ofiical game thing
16:14 < bridge> <ryozuki> factorio is turing complete with the signals it has
16:14 < bridge> <ryozuki> a blueprint allows u to paste structures
16:14 < bridge> <Jupstar ‚ú™> but you used it for the aoc program or what
16:14 < bridge> <ryozuki> no
16:14 < bridge> <ryozuki> wanted to try
16:14 < bridge> <Jupstar ‚ú™> i am bit confused why u pinged me and said aoc
16:14 < bridge> <Jupstar ‚ú™> xd
16:14 < bridge> <ryozuki> but idk how i would give it input
16:14 < bridge> <ryozuki> xd
16:14 < bridge> <ryozuki> i got motivated sry xd
16:15 < bridge> <Jupstar ‚ú™> i bet u could get another 4ns by using a vec for the key() iteration
16:15 < bridge> <Jupstar ‚ú™> xd
16:16 < bridge> <ryozuki> xd
16:19 < bridge> <ryozuki> 883.6 ¬µs without pgo
16:19 < bridge> <ryozuki> so yes
16:19 < bridge> <ryozuki> not a  vec but a array
16:19 < bridge> <ryozuki> ill try perfect hashing now
16:23 < bridge> <ryozuki> seems same
16:37 < bridge> <Jupstar ‚ú™> @ryozuki what is your exact command line with hyperfine?
16:37 < bridge> <Jupstar ‚ú™> hyperfine -N -w 5 -r 10000 ./target/release/rust-aoc
16:37 < bridge> <Jupstar ‚ú™> ah
16:38 < bridge> <Jupstar ‚ú™> no cargo integration? xd
16:38 < bridge> <ryozuki> cargo would bloat
16:38 < bridge> <ryozuki> i run the bin direct xd
16:38 < bridge> <xcapeest> whoa
16:39 < bridge> <xcapeest> this game still has things to develop?
16:39 < bridge> <xcapeest> xd
16:39 < bridge> <Jupstar ‚ú™> no it's 100% perfect and bug free
16:39 < bridge> <Jupstar ‚ú™> https://github.com/ddnet/ddnet/issues
16:39 < bridge> <xcapeest> Suppose I'm fairly new
16:39 < bridge> <ryozuki> hi fairly new im dad
16:39 < bridge> <ryozuki> sorry
16:40 < bridge> <xcapeest> Tho I did play first in 2011
16:40 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180171567423041617/image.png?ex=657c736c&is=6569fe6c&hm=40ee99c57ebda043370d665815a95cd3b8d5adbd31bc28591515219d7f142c27&
16:40 < bridge> <ryozuki> :NekoEvil:
16:40 < bridge> <Jupstar ‚ú™> wtf your pc is so fast xD
16:40 < bridge> <Jupstar ‚ú™> Benchmark 1: ./target/release/aoc
16:40 < bridge> <Jupstar ‚ú™>   Time (mean ¬± œÉ):       5.5 ms ¬±   0.4 ms    [User: 4.9 ms, System: 29.8 ms]
16:40 < bridge> <Jupstar ‚ú™>   Range (min ‚Ä¶ max):     3.6 ms ‚Ä¶   8.3 ms    10000 runs
16:40 < bridge> <ryozuki> ```
16:40 < bridge> <ryozuki> [profile.release]
16:40 < bridge> <ryozuki> lto = true
16:40 < bridge> <ryozuki> codegen-units = 1
16:41 < bridge> <ryozuki> ```
16:41 < bridge> <ryozuki> + mold
16:41 < bridge> <ryozuki> @jupeyy_keks maybe it depends on the file load?
16:41 < bridge> <ryozuki> well it should be cached
16:41 < bridge> <ryozuki> with the warmup
16:41 < bridge> <ryozuki> but im on gentoo
16:41 < bridge> <ryozuki> everything natively compiled
16:41 < bridge> <Jupstar ‚ú™> and also my ssd is really fast i think
16:41 < bridge> <ryozuki> thats slow lol
16:41 < bridge> <Jupstar ‚ú™> i use
16:41 < bridge> <Jupstar ‚ú™> `hyperfine -N -w 5 -r 10000 ./target/release/aoc`
16:41 < bridge> <Jupstar ‚ú™> same as you?
16:42 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180172049528934490/image.png?ex=657c73df&is=6569fedf&hm=db7d6fd57010c2a2e36c083790a6c2df842646e254d51c6858f82c24d4a1fb15&
16:42 < bridge> <Jupstar ‚ú™> well i have 16 cores. maybe rayon is bad in this case üòÑ
16:42 < bridge> <Jupstar ‚ú™> i try without parallel
16:42 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180172165799231498/image.png?ex=657c73fa&is=6569fefa&hm=fd9c2212ae693ebfd8c8e7a3a4374a5dd8aa84cf7d9d2e81cb3835e71055e596&
16:42 < bridge> <ryozuki> i got 16
16:43 < bridge> <ryozuki> xd
16:43 < bridge> <ryozuki> well
16:43 < bridge> <ryozuki> 16 threads
16:43 < bridge> <Jupstar ‚ú™> https://cdn.discordapp.com/attachments/293493549758939136/1180172242387226654/image.png?ex=657c740d&is=6569ff0d&hm=e680ae01c43c9be169d5f063b2834c0e5aac0f61ff3f544becc944e1a69d9ca7&
16:43 < bridge> <ryozuki> ah it could be
16:43 < bridge> <ryozuki> too much paralel
16:43 < bridge> <ryozuki> u can limit rayon
16:43 < bridge> <ryozuki> rayon::ThreadPoolBuilder::new().num_threads(4).build_global().unwrap();
16:43 < bridge> <Jupstar ‚ú™> ok single threaded not much better
16:43 < bridge> <ryozuki> put 16
16:43 < bridge> <Jupstar ‚ú™> just a bit better
16:43 < bridge> <ryozuki> me without rayon its 1.2ms
16:43 < bridge> <ryozuki> @jupeyy_keks i guess u found a argument to use gentoo
16:44 < bridge> <ryozuki> native kernel
16:44 < bridge> <Jupstar ‚ú™> xDD
16:44 < bridge> <Jupstar ‚ú™> i doubt that this will help in this case
16:44 < bridge> <Jupstar ‚ú™> but i am surprised my pc sucks so hard
16:44 < bridge> <ryozuki> wait
16:44 < bridge> <Jupstar ‚ú™> 3000 series ryzen are ofc slower
16:44 < bridge> <ryozuki> u use 3.5ghz
16:44 < bridge> <Jupstar ‚ú™> than 5000 series
16:44 < bridge> <ryozuki> i have  CPU: AMD Ryzen 7 5800X (16) @ 4.85 GHz
16:44 < bridge> <ryozuki> 4.85ghz
16:44 < bridge> <ryozuki> normal
16:44 < bridge> <Jupstar ‚ú™> yeah, but benchmarks show ur cpu is like 20% faster
16:44 < bridge> <Jupstar ‚ú™> not 200% faster xD
16:45 < bridge> <ryozuki> xd
16:45 < bridge> <ryozuki> @jupeyy_keks did u use march native
16:45 < bridge> <Jupstar ‚ú™> no, but no matter which flag, it would not explain such a difference
16:45 < bridge> <Jupstar ‚ú™> maybe my RAM XMP profile was discarded or smth
16:46 < bridge> <ryozuki> oh wait
16:46 < bridge> <ryozuki> iwasnt using march native
16:46 < bridge> <ryozuki> ok same shit
16:48 < bridge> <Jupstar ‚ú™> the funny thing is, my "System" time is even lower than yours
16:48 < bridge> <Jupstar ‚ú™> 
16:48 < bridge> <Jupstar ‚ú™> but user time much higher
16:48 < bridge> <Jupstar ‚ú™> ok but single threaded
16:48 < bridge> <Jupstar ‚ú™> lmao
16:48 < bridge> <Jupstar ‚ú™> multi threaded is sucks ass
16:49 < bridge> <ryozuki> wdym
16:49 < bridge> <ryozuki> urs is in ms
16:49 < bridge> <ryozuki> mine is in us
16:49 < bridge> <Jupstar ‚ú™> yes
16:49 < bridge> <ryozuki> my sys time is lower
16:49 < bridge> <Jupstar ‚ú™> i dunno
16:49 < bridge> <Jupstar ‚ú™> all your benchmarks are like 3ms
16:49 < bridge> <Jupstar ‚ú™> mine is:
16:49 < bridge> <Jupstar ‚ú™> 
16:49 < bridge> <Jupstar ‚ú™> Benchmark 1: ./target/release/aoc
16:49 < bridge> <Jupstar ‚ú™>   Time (mean ¬± œÉ):       3.5 ms ¬±   0.4 ms    [User: 2.8 ms, System: 0.6 ms]
16:49 < bridge> <Jupstar ‚ú™>   Range (min ‚Ä¶ max):     3.1 ms ‚Ä¶   9.9 ms    10000 runs
16:49 < bridge> <Jupstar ‚ú™> single threaded
16:49 < bridge> <ryozuki> ahh
16:49 < bridge> <ryozuki> u mean among my benches
16:49 < bridge> <ryozuki> xd
16:50 < bridge> <Jupstar ‚ú™> ah
16:50 < bridge> <Jupstar ‚ú™> this is faster
16:50 < bridge> <Jupstar ‚ú™> then nvm
16:50 < bridge> <ryozuki> is sys time kernel time?
16:50 < bridge> <Jupstar ‚ú™> i assume so
16:51 < bridge> <Jupstar ‚ú™> ok whatever, my pc sucks apparently
16:51 < bridge> <Jupstar ‚ú™> that also explains why i dont have 10k FPS in ddnet anymore
16:51 < bridge> <ryozuki> f
16:51 < bridge> <Jupstar ‚ú™> i bet some fixes for security vuln kicked in xD
16:51 < bridge> <Jupstar ‚ú™> spectre 2000
16:51 < bridge> <Jupstar ‚ú™> or whatever their names are
16:51 < bridge> <ryozuki> https://gist.github.com/edg-l/c4bb02a5171a7190dcc72830ac4d5576
16:51 < bridge> <ryozuki> just so u know t his is my code
16:53 < bridge> <Jupstar ‚ú™> Benchmark 1: ./target/release/aoc
16:53 < bridge> <Jupstar ‚ú™>   Time (mean ¬± œÉ):       3.4 ms ¬±   0.2 ms    [User: 6.3 ms, System: 11.8 ms]
16:53 < bridge> <Jupstar ‚ú™>   Range (min ‚Ä¶ max):     2.8 ms ‚Ä¶   5.2 ms    10000 runs
16:53 < bridge> <ryozuki> f
16:54 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
16:54 < bridge> <ryozuki>   Time (mean ¬± œÉ):     884.2 ¬µs ¬±  91.8 ¬µs    [User: 1415.1 ¬µs, System: 2001.2 ¬µs]
16:54 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   769.5 ¬µs ‚Ä¶ 5621.4 ¬µs    10000 runs
16:55 < bridge> <ryozuki> @jupeyy_keks just to know
16:55 < bridge> <ryozuki> what ur fstab
16:55 < bridge> <ryozuki> do u have noatime
16:56 < bridge> <ryozuki> ```
16:56 < bridge> <ryozuki> UUID=8E37-E91C    /boot    vfat    defaults,noatime    0 2
16:56 < bridge> <ryozuki> UUID=6739c2cc-4a15-4a30-b223-bafcdff6688f / ext4 defaults,noatime 0 1
16:56 < bridge> <ryozuki> 
16:56 < bridge> <ryozuki> # sda1 is the 2tb ssd partition for linux
16:56 < bridge> <ryozuki> UUID=c598fbd0-b87c-4e69-9fb6-8b2fd0624f24 /data1 ext4 defaults,noatime 0 2
16:56 < bridge> <ryozuki> 
16:56 < bridge> <ryozuki> UUID=f0146921-8313-4099-bb81-7c87675cbbfe /data2 ext4 defaults,noatime 0 2
16:56 < bridge> <ryozuki> 
16:56 < bridge> <ryozuki> UUID=d2359c6c-99c0-4f4f-9225-5605bed37399 none swap sw 0 0
16:56 < bridge> <ryozuki> 
16:56 < bridge> <ryozuki> /dev/cdrom        /mnt/cdrom    auto        noauto,user    0 0
16:56 < bridge> <ryozuki> 
16:56 < bridge> <ryozuki> tmpfs /tmp tmpfs rw,nosuid,noatime,nodev,size=16G,mode=1777 0 0
16:56 < bridge> <ryozuki> tmpfs /var/tmp/portage tmpfs size=14G,uid=portage,gid=portage,mode=775,nosuid,noatime,nodev    0 0
16:56 < bridge> <ryozuki> ```
16:56 < bridge> <ryozuki> this mine
16:56 < bridge> <Jupstar ‚ú™> # /etc/fstab: static file system information.
16:56 < bridge> <Jupstar ‚ú™> #
16:56 < bridge> <Jupstar ‚ú™> # Use 'blkid' to print the universally unique identifier for a
16:56 < bridge> <Jupstar ‚ú™> # device; this may be used with UUID= as a more robust way to name devices
16:56 < bridge> <Jupstar ‚ú™> # that works even if disks are added and removed. See fstab(5).
16:56 < bridge> <Jupstar ‚ú™> #
16:56 < bridge> <Jupstar ‚ú™> # <file system> <mount point>   <type>  <options>       <dump>  <pass>
16:56 < bridge> <Jupstar ‚ú™> # / was on /dev/nvme0n1p2 during installation
16:56 < bridge> <Jupstar ‚ú™> UUID=6c4f1ad8-7a33-4fc5-9725-6e2c0cc27c1f /               ext4    errors=remount-ro 0       1
16:57 < bridge> <Jupstar ‚ú™> # /boot/efi was on /dev/nvme0n1p1 during installation
16:57 < bridge> <Jupstar ‚ú™> UUID=B5AB-A475  /boot/efi       vfat    umask=0077      0       1
16:57 < bridge> <Jupstar ‚ú™> # swap was on /dev/nvme0n1p3 during installation
16:57 < bridge> <Jupstar ‚ú™> #UUID=2d0dd124-e35f-41fe-8074-b1c98eb3c1b5 none            swap    sw              0       0
16:57 < bridge> <Jupstar ‚ú™> /swapfile    none    swap    sw    0    0
16:57 < bridge> <Jupstar ‚ú™> UUID=1c6d88fc-0f21-492f-a17c-28d4c4ae33ef /media/jupeyy/SSD_NVME/ ext4 defaults 0 0
16:57 < bridge> <Jupstar ‚ú™> #UUID=8dc275c9-a78f-44bf-8a4c-aa95bef3ce44 /media/jupeyy/SSD_SMALL ext4 defaults 0 0
16:57 < bridge> <Jupstar ‚ú™> WTF
16:57 < bridge> <ryozuki> lmao
16:57 < bridge> <Jupstar ‚ú™> xD
16:57 < bridge> <ryozuki> xzddd
16:57 < bridge> <ryozuki> @jupeyy_keks bruv
16:57 < bridge> <ryozuki> u need noatime
16:57 < bridge> <ryozuki> atime = access time
16:57 < bridge> <ryozuki> it slows down a lot
16:57 < bridge> <ryozuki> https://opensource.com/article/20/6/linux-noatime
16:57 < bridge> <Jupstar ‚ú™> i used include_str! now
16:57 < bridge> <Jupstar ‚ú™> if u mean for reading files
16:57 < bridge> <ryozuki> ye
16:58 < bridge> <ryozuki> same?
16:58 < bridge> <Jupstar ‚ú™> yeah it makes no diff
16:58 < bridge> <ryozuki> f
16:58 < bridge> <ryozuki> then yes
16:58 < bridge> <ryozuki> cpu
16:58 < bridge> <ryozuki> whats ur ram speed
16:58 < bridge> <Jupstar ‚ú™> 3200
16:58 < bridge> <ryozuki> same
16:58 < bridge> <Jupstar ‚ú™> CL 16
16:58 < bridge> <ryozuki> or was 3600
16:58 < bridge> <ryozuki> i forgot
16:59 < bridge> <Jupstar ‚ú™> oh
16:59 < bridge> <Jupstar ‚ú™> CL14 even
16:59 < bridge> <Jupstar ‚ú™> does the terminal matter? xdd
16:59 < bridge> <ryozuki> i doubt
16:59 < bridge> <ryozuki> cuz no prints
16:59 < bridge> <Jupstar ‚ú™> i ran it inside vscode xD
16:59 < bridge> <ryozuki> also hyperfine -N option disables shell
16:59 < bridge> <ryozuki> for more real perf
17:00 < bridge> <ryozuki> i ran it inside vs too
17:00 < bridge> <ryozuki> @jupeyy_keks when add christmas on to ur vulkan pfp
17:00 < bridge> <ryozuki> @murpi no christmas themed discord pic?
17:01 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180176747623350272/image.png?ex=657c783f&is=656a033f&hm=1cf99b8aa78e40547007f738aef5b5134c8df0b6161adc5eaba8514cf448c6bd&
17:01 < bridge> <Jupstar ‚ú™> i try taskset --cpu-list 1 now
17:02 < bridge> <Jupstar ‚ú™> maybe my CPU is simply bad at this specific task xD
17:02 < bridge> <Jupstar ‚ú™> now i got:
17:02 < bridge> <Jupstar ‚ú™>   Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet system without any interferences from other programs. It might help to use the '--warmup' or '--prepare' options.
17:02 < bridge> <Jupstar ‚ú™> xd
17:03 < bridge> <Jupstar ‚ú™> but it's useless to do it like this anyway. force mt program on 1 core xD
17:03 < bridge> <murpi> Do you have one?
17:04 < bridge> <Jupstar ‚ú™> i bet insanity has one
17:13 < bridge> <Jupstar ‚ú™> @ryozuki i found reason
17:13 < bridge> <Jupstar ‚ú™> but don't laugh
17:13 < bridge> <Jupstar ‚ú™> i pasted the input twice
17:14 < bridge> <Jupstar ‚ú™> interestingly the multi threaded version is still around as fast
17:15 < bridge> <Jupstar ‚ú™> there comes the 16 core power
17:15 < bridge> <Jupstar ‚ú™> üòè
17:18 < bridge> <Jupstar ‚ú™> so when i force it to only use 4 cores:
17:18 < bridge> <Jupstar ‚ú™> Benchmark 1: ./target/release/aoc
17:18 < bridge> <Jupstar ‚ú™>   Time (mean ¬± œÉ):       1.4 ms ¬±   0.1 ms    [User: 2.2 ms, System: 0.6 ms]
17:18 < bridge> <Jupstar ‚ú™>   Range (min ‚Ä¶ max):     1.2 ms ‚Ä¶   1.8 ms    1000 runs
17:18 < bridge> <Jupstar ‚ú™> 16 cores is simply too much overkill in this case
17:19 < bridge> <Jupstar ‚ú™> or wait
17:19 < bridge> <Jupstar ‚ú™> does rayon not use 32threads default?
17:20 < bridge> <Jupstar ‚ú™> yeah nvm:
17:20 < bridge> <Jupstar ‚ú™> 4 threads > 16 threads >>> 32 threads
17:20 < bridge> <Jupstar ‚ú™> the CXX is simply to unefficient then
17:20 < bridge> <Jupstar ‚ú™> murpi knew that already
17:20 < bridge> <Jupstar ‚ú™> the CCX is simply to unefficient then
17:38 < bridge> <ryozuki> @jupeyy_keks 1 hour and im free of work
17:39 < bridge> <ryozuki> for a entire week
17:39 < bridge> <ryozuki> :NekoEvil:
17:47 < bridge> <_voxeldoesart> i wonder what ryo will do for the week off
17:58 < bridge> <learath2> @ryozuki I did my very best to make it as disgusting as possible for you, I got 0.5ms
17:58 < bridge> <learath2> https://paste.pr0.tips/UjA?c behold
17:59 < bridge> <ryozuki> how much time did u spend
18:00 < bridge> <ryozuki> oh u used a match xDDD
18:00 < bridge> <learath2> 20 minutes handcrafting the state machine, another 20 debugging it üòÑ
18:00 < bridge> <ryozuki> lmao
18:00 < bridge> <ryozuki> goto
18:00 < bridge> <learath2> Someone smarter than me would generate the state machine too
18:01 < bridge> <learath2> I did my very best to sprinkle more of them around but sadly wasn't able to get more in there
18:01 < bridge> <learath2> However, observe the ugly found label right under the switch, it's the very best
18:02 < bridge> <ryozuki> xd
18:02 < bridge> <ryozuki> i will just say
18:02 < bridge> <ryozuki> very readable code
18:02 < bridge> <ryozuki> congrats
18:02 < bridge> <learath2> Albeit it's not extremely useful here, it's Aho-Corasick algorithm
18:03 < bridge> <ryozuki> nice to know
18:03 < bridge> <ryozuki> for now u win
18:03 < bridge> <ryozuki> i dont think i have the will rn to do smth like that xdd
18:03 < bridge> <learath2> I'm sure there is a rust crate to pregenerate and run a Aho-Corasick FSM
18:04 < bridge> <learath2> Or maybe you can abuse one of those parser lexer generators, they might internally implement it
18:04 < bridge> <ryozuki> wait
18:04 < bridge> <ryozuki> 0.5ms is 500us right
18:05 < bridge> <ryozuki> https://crates.io/crates/rust-fsm
18:05 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180192910583533588/image.png?ex=657c874c&is=656a124c&hm=1ed9d076452c101018bcf79104e2be3cd73f33cba58e033ac17d3bb59fa69b84&
18:05 < bridge> <ryozuki> wtf itexists
18:05 < bridge> <ryozuki> https://crates.io/crates/aho-corasick
18:05 < bridge> <learath2> Aha, that would beat mine probably, it has simd magic
18:06 < bridge> <learath2> Here is my state machine üòÑ
18:06 < bridge> <learath2> https://cdn.discordapp.com/attachments/293493549758939136/1180193138317463703/IMG_0752.png?ex=657c8783&is=656a1283&hm=94c2870f8b4a88b1fe61d0211ba788bad3eb4f3366f58ca18822f809aefdc227&
18:06 < bridge> <learath2> LOL so simple to use aswell
18:07 < bridge> <learath2> But does it build the FSM at compile time? I'd guess it does since that's kinda the point
18:11 < bridge> <learath2> Oh actually, I ran it on my input on my pc, maybe it is worse than your rayon version
18:12 < bridge> <ryozuki> oh
18:12 < bridge> <ryozuki> let me test it
18:12 < bridge> <ryozuki> @learath2 how to have raw copy of ur
18:12 < bridge> <ryozuki> it copies nums
18:12 < bridge> <ryozuki> oh
18:12 < bridge> <learath2> Just remove the ?c at the end of the link
18:12 < bridge> <ryozuki> it doesnt
18:13 < bridge> <ryozuki> ok it does but at start
18:13 < bridge> <ryozuki> @learath2 tell me how u want me to compile it for max perf
18:13 < bridge> <learath2> Just go for a `cc -O3` I didn't think much about it
18:14 < bridge> <ryozuki> ok result is correct
18:14 < bridge> <zogtib> (I'm out of context, I just clicked your pastebin out of curiosity and I noticed that) your `get1()` function doesn't actually check for buffer overflow: it checks for `bufsz > 0` but bufsz doesn't get updated. I'd change the while-loop line to `while ((c = getc(f)) != EOF && c != '\n' && bufsz-- > 1)`
18:14 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
18:14 < bridge> <ryozuki>   Time (mean ¬± œÉ):     887.7 ¬µs ¬±  70.8 ¬µs    [User: 1408.4 ¬µs, System: 2021.9 ¬µs]
18:14 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   773.8 ¬µs ‚Ä¶ 2301.4 ¬µs    10000 runs
18:14 < bridge> <ryozuki>  
18:14 < bridge> <ryozuki>   Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet system without any interferences from other programs. It might help to use the '--warmup' or '--prepare' options.
18:14 < bridge> <ryozuki>  
18:14 < bridge> <ryozuki> Benchmark 2: ./a.out
18:14 < bridge> <ryozuki>   Time (mean ¬± œÉ):     425.8 ¬µs ¬±  41.1 ¬µs    [User: 311.5 ¬µs, System: 68.1 ¬µs]
18:14 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   352.6 ¬µs ‚Ä¶ 993.3 ¬µs    10000 runs
18:14 < bridge> <ryozuki>  
18:14 < bridge> <ryozuki>   Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet system without any interferences from other programs. It might help to use the '--warmup' or '--prepare' options.
18:14 < bridge> <ryozuki>  
18:14 < bridge> <ryozuki> Summary
18:14 < bridge> <ryozuki>   ./a.out ran
18:14 < bridge> <ryozuki>     2.08 ¬± 0.26 times faster than ./target/release/rust-aoc
18:14 < bridge> <ryozuki> @learath2 urs is faster rn
18:16 < bridge> <learath2> Oh yep, good catch, I just assumed all input is sane at some point forgot to remove bufsz
18:16 < bridge> <learath2> Oh you can compare 2 with hyperfine, wow that's a cool feature
18:17 < bridge> <ryozuki> thats the point of hyperfine
18:17 < bridge> <ryozuki> https://github.com/sharkdp/hyperfine
18:18 < bridge> <zogtib> üëç anyways good luck üôÇ
18:19 < bridge> <Jupstar ‚ú™> so that's the time to beat
18:19 < bridge> <ryozuki> i got it bro
18:19 < bridge> <Jupstar ‚ú™> for m,e
18:19 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
18:19 < bridge> <ryozuki>   Time (mean ¬± œÉ):     563.1 ¬µs ¬±  57.9 ¬µs    [User: 382.8 ¬µs, System: 129.7 ¬µs]
18:19 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   461.9 ¬µs ‚Ä¶ 1623.0 ¬µs    10000 runs
18:19 < bridge> <ryozuki> rayon doesnt help here
18:20 < bridge> <Jupstar ‚ú™> ui, close already
18:21 < bridge> <ryozuki> ill remove a hashmap
18:21 < bridge> <ryozuki> with a match
18:22 < bridge> <_voxeldoesart> what r u guys doing
18:22 < bridge> <ryozuki> fighting
18:22 < bridge> <_voxeldoesart> ok
18:23 < bridge> <learath2> It should probably just match or beat mine just with that change tbf, the compiler is probably smart enough to generate a jumptable just without the blue edges in mine which there aren't enough to matter in this problem
18:23 < bridge> <ryozuki> ‚ùØ hyperfine -N -w 500 -r 10000  ./target/release/rust-aoc
18:23 < bridge> <ryozuki> Benchmark 1: ./target/release/rust-aoc
18:23 < bridge> <ryozuki>   Time (mean ¬± œÉ):     526.5 ¬µs ¬±  52.1 ¬µs    [User: 353.5 ¬µs, System: 123.5 ¬µs]
18:23 < bridge> <ryozuki>   Range (min ‚Ä¶ max):   436.9 ¬µs ‚Ä¶ 2036.4 ¬µs    10000 runs
18:23 < bridge> <ryozuki> without unsafe
18:24 < bridge> <ryozuki> http://paste.pr0.tips/eX4?rust
18:25 < bridge> <ryozuki> same speed with unsafe xd
18:25 < bridge> <ryozuki> The default configuration optimizes for less space usage, but at the expense of longer search times. To change the configuration, use AhoCorasickBuilder.
18:25 < bridge> <ryozuki> ok wait
18:31 < bridge> <learath2> ok now let me try rust
18:31 < bridge> <learath2> My turn on the rust machine
18:31 < bridge> <ryozuki> ok yeah 526us
18:31 < bridge> <ryozuki> the crate is built by burntsushi
18:31 < bridge> <ryozuki> the author of the regex crate
18:31 < bridge> <ryozuki> he is a pro
18:31 < bridge> <ryozuki> among pros
18:31 < bridge> <learath2> Which crate?
18:31 < bridge> <ryozuki> https://github.com/BurntSushi/aho-corasick
18:32 < bridge> <learath2> Oh, were you using that for your 526us result?
18:32 < bridge> <ryozuki> burntsushi is like a 2nd dtolnay
18:32 < bridge> <ryozuki> yes
18:33 < bridge> <ryozuki> im 2 lazy to make it myself
18:33 < bridge> <ryozuki> xd
18:33 < bridge> <Jupstar ‚ú™> did u even check learaths solution for correctness? xd
18:33 < bridge> <ryozuki> ye
18:33 < bridge> <learath2> doubter can't believe I outperformed the machine
18:33 < bridge> <ryozuki> @learath2 did u know about this from uni?
18:33 < bridge> <learath2> Though it is probably just some rust overhead ngl
18:33 < bridge> <learath2> It's unlikely my hand drawn FSM is better than a generated one
18:34 < bridge> <ryozuki> @learath2 my guess is maybe cuz utf8
18:34 < bridge> <Jupstar ‚ú™> no
18:34 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180200323869061220/image.png?ex=657c8e34&is=656a1934&hm=96ebea2d1843e1c9e6da45b7d25acae8f46a8692f5392d3d4aa34c81e3c85513&
18:34 < bridge> <ryozuki> nice
18:34 < bridge> <learath2> Nooo, I knew there existed an optimal algorithm to find a set of small strings in a larger string
18:34 < bridge> <ryozuki> i used clang instead of cc
18:35 < bridge> <learath2> So clang made it worse?
18:35 < bridge> <ryozuki> oh true
18:35 < bridge> <ryozuki> looks like clangg is slower
18:35 < bridge> <Jupstar ‚ú™> it is indeed
18:35 < bridge> <ryozuki> im trying gcc
18:35 < bridge> <Jupstar ‚ú™> esp with lto
18:36 < bridge> <ryozuki> 421 gcc
18:36 < bridge> <ryozuki> but im only using -o¬∑
18:36 < bridge> <ryozuki> o3
18:36 < bridge> <ryozuki> no lto
18:36 < bridge> <learath2> What would even be LTO'd? I guess the printf
18:37 < bridge> <ryozuki> now native  march
18:37 < bridge> <ryozuki> no change
18:37 < bridge> <ryozuki> xd
18:37 < bridge> <ryozuki> lto is 2us slower
18:38 < bridge> <ryozuki> noise
18:38 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180201296653996052/flamegraph.svg?ex=657c8f1c&is=656a1a1c&hm=c1bcee50b7dc1c07cbfc809a054e9132dcf31ac9939ce9f5d5c8a826bfc52c9a&
18:38 < bridge> <ryozuki> rust flamegraph
18:38 < bridge> <zogtib> doesn't this imply that they both spend almost the same time in userspace? so they mainly differ in time spent by system calls?
18:39 < bridge> <ryozuki> ok not useful xd
18:39 < bridge> <ryozuki> tbh idk, but what u say makes sense
18:39 < bridge> <zogtib> So it does? Because Learath version's doesn't read the whole file at once
18:40 < bridge> <ryozuki> idk xD
18:40 < bridge> <zogtib> (lol "Learath verison's" -> "Learath's version")
18:40 < bridge> <ryozuki> time man page
18:40 < bridge> <ryozuki> These statistics consist of (i) the elapsed real time between invocation and termination, (ii) the user CPU time (the sum of the tms_utime and tms_cutime values  in  a
18:40 < bridge> <ryozuki>        struct tms as returned by times(2)), and (iii) the system CPU time (the sum of the tms_stime and tms_cstime values in a struct tms as returned by times(2)).
18:40 < bridge> <ryozuki> %S     Total number of CPU-seconds that the process spent in kernel mode.
18:40 < bridge> <ryozuki> 
18:40 < bridge> <ryozuki>        %U     Total number of CPU-seconds that the process spent in user mode.
18:40 < bridge> <learath2> I find it hard to believe that my naive character by character read of the file is more optimal than the newfangled space age methods rust uses
18:41 < bridge> <Jupstar ‚ú™> dude
18:42 < bridge> <Jupstar ‚ú™> have u ever looked at your solution
18:42 < bridge> <Jupstar ‚ú™> it's completely unreadable. ofc it might be slightly faster
18:42 < bridge> <ryozuki> let me try to buffer
18:42 < bridge> <ryozuki> the file read
18:43 < bridge> <zogtib> Isn't it that generally complicated algorithms become fast for big enough inputs?
18:46 < bridge> <ryozuki> buffering doesnt help
18:47 < bridge> <zogtib> hmm, a bit surprising I'd say
18:47 < bridge> <ryozuki> well i guess the way i did it
18:47 < bridge> <ryozuki> i should bypass strings totally
18:47 < bridge> <ryozuki> xd
18:48 < bridge> <zogtib> I mean, because besides reading the file, system/OS isn't called in another way, right?
18:51 < bridge> <ryozuki> @learath2 ah
18:51 < bridge> <ryozuki> the state machine is not at compile time
18:52 < bridge> <ryozuki> its built once at  runtime
18:52 < bridge> <learath2> Ah that might be the extra 100
18:53 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180204921681875004/image.png?ex=657c927c&is=656a1d7c&hm=a9822533427b55fcc6ef7d931f9e57503e4b2d944aa0d47cfffb28d222574bde&
18:53 < bridge> <learath2> Though the similar times spent in user code suggests to me that the rust generated one is far faster, but rust reads the file wrong
18:53 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180205041299247205/image.png?ex=657c9298&is=656a1d98&hm=d98a9a415093221c24eb332813065883c2fa563803e483a2d82eeb4ee15a9614&
18:53 < bridge> <ryozuki> i guess
18:53 < bridge> <ryozuki> i could do it like C but im lazy rn
18:54 < bridge> <Jupstar ‚ú™> did u rewrite it in rust or what?
18:54 < bridge> <learath2> Anyway, it wouldn't surprise me, I'm not a machine, I can't generate a perfect FSM üòÑ
18:54 < bridge> <ryozuki> let me try panic = abort
18:54 < bridge> <ryozuki> what?
18:54 < bridge> <ryozuki> i used the aho-corasick crate
18:55 < bridge> <ryozuki> didnt help xd
18:55 < bridge> <Jupstar ‚ú™> what is that? üòÑ
18:55 < bridge> <ryozuki> u missed t he entire convo? XD
18:55 < bridge> <ryozuki> @jupeyy_keks its how lea got 420
18:55 < bridge> <ryozuki> and i reduced down to 520
18:56 < bridge> <ryozuki> a algo
19:01 < bridge> <ryozuki> @learath2 https://en.wikipedia.org/wiki/Commentz-Walter_algorithm
19:01 < bridge> <ryozuki> is this faster?
19:02 < bridge> <ryozuki> > Comparing the Aho-Corasick to the Commentz-Walter Algorithm yields results with the idea of time complexity. Aho-Corasick is considered linear O(m+n+k) where k is the number of matches. Commentz-Walter may be considered quadratic O(mn). The reason for this lies in the fact that Commentz-Walter was developed by adding the shifts within the Boyer‚ÄìMoore string-search algorithm to the Aho-Corasick, thus moving its complexity from linear to quadrati
19:02 < bridge> <learath2> It's far more complicated for me to do by hand so I didn't even look into it
19:03 < bridge> <learath2> It technically has quadratic complexity but it does perform better in most cases
19:48 < bridge> <learath2> @ryozuki what was the new way of compiling regexes once?
19:49 < bridge> <ryozuki> i think u can compile regex in a static context in rust now
19:49 < bridge> <ryozuki> let me see
19:49 < bridge> <ryozuki> ```rust
19:49 < bridge> <ryozuki> fn some_helper_function(haystack: &str) -> bool {
19:49 < bridge> <ryozuki>     static RE: Lazy<Regex> = Lazy::new(|| Regex::new(r"...").unwrap());
19:49 < bridge> <ryozuki>     RE.is_match(haystack)
19:49 < bridge> <ryozuki> }
19:49 < bridge> <ryozuki> ```
19:50 < bridge> <ryozuki> ```rust
19:50 < bridge> <ryozuki> use {
19:50 < bridge> <ryozuki>     once_cell::sync::Lazy,
19:50 < bridge> <ryozuki>     regex::Regex,
19:50 < bridge> <ryozuki> };
19:50 < bridge> <ryozuki> ```
19:50 < bridge> <ryozuki> TIL this is a way to do imports!
19:51 < bridge> <ryozuki> @jupeyy_keks my FFR contribution
19:51 < bridge> <ryozuki> also it works with cfg
19:53 < bridge> <learath2> https://paste.pr0.tips/xWq?rust behold my abomination
19:53 < bridge> <learath2> It's god awful but I had the urge to make it for some reason
19:54 < bridge> <learath2> Ignore the unused imports, it has seen some stuff
20:16 < bridge> <learath2> hm, I wonder what is blocking
20:16 < bridge> <learath2> https://cdn.discordapp.com/attachments/293493549758939136/1180225962248515694/image.png?ex=657ca614&is=656a3114&hm=1587d1318a29878b57ebcc971826fe6e29f439209cf8e76c9222a3a61a9f479e&
20:16 < bridge> <learath2> I thought rusts compile time facilities were top notch
20:18 < bridge> <ryozuki> where u her
20:18 < bridge> <ryozuki> heard
20:18 < bridge> <ryozuki> its known rust compile time is not up there to c++
20:19 < bridge> <ryozuki> yet
20:23 < bridge> <robyt3> Can someone retry #7552 ?
20:23 < bridge> <DDNet> https://github.com/ddnet/ddnet/pull/7552
20:31 < bridge> <learath2> but procmacros have access to the entire AST no?
20:32 < bridge> <learath2> and can't you like run actual rust code at compile time too?
20:33 < bridge> <ryozuki> yes
20:33 < bridge> <ryozuki> yes xd
20:33 < bridge> <ryozuki> i guess ppl didnt do that yet
20:33 < bridge> <ryozuki> @learath2 someone did this for maps
20:33 < bridge> <ryozuki> anmd perfect hashes
20:33 < bridge> <ryozuki> https://github.com/rust-phf/rust-phf
20:34 < bridge> <learath2> I should read the dragon book sometime. I noticed I code automata really weirdly, maybe there is some insight there as to a "standard" way to write one
20:34 < bridge> <ryozuki> i want to own the dragon book
20:34 < bridge> <ryozuki> the book of compilers
20:34 < bridge> <ryozuki> BUT
20:34 < bridge> <ryozuki> IT COSTS 150‚Ç¨
20:34 < bridge> <ryozuki> THANKS ACADEMIA!
20:35 < bridge> <learath2> Thanks Publishers*
20:35 < bridge> <ryozuki> @learath2 let me ask a friend who likes a lot automatas
20:35 < bridge> <ryozuki> if he knows a nic book
20:35 < bridge> <ryozuki> coworker*
20:40 < bridge> <ryozuki> @learath2 got my answer
20:40 < bridge> <ryozuki> https://www.amazon.com/Automata-Theory-Algorithmic-Javier-Esparza/dp/0262048639/ref=sr_1_1?keywords=Automata+Theory%3A+An+Algorithmic+Approach&qid=1701459608&sr=8-1
20:40 < bridge> <ryozuki> https://www7.in.tum.de/~esparza/autoskript.pdf
20:40 < bridge> <ryozuki> free read
20:40 < bridge> <ryozuki> xd
20:40 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1180232063123734528/image.png?ex=657cabc3&is=656a36c3&hm=9b8e5e1f5e4fd9f15579b30351158641be558b7671cdc94a8f71242c618a15dd&
20:40 < bridge> <ryozuki> and this one
20:41 < bridge> <ryozuki> http://aleteya.cs.buap.mx/~jlavalle/papers/distribuidos/algorithms-on-strings.9780521848992.33360.pdf
20:41 < bridge> <ryozuki> @learath2 this one has string algorithms like the one u used today
20:44 < bridge> <ryozuki> this coworker of mine is always reading books
20:44 < bridge> <ryozuki> he read so many xd
20:46 < bridge> <learath2> Bookworm
20:48 < bridge> <learath2> Tries are key to pattern matching automata
20:52 < bridge> <ryozuki> https://125-problems.univ-mlv.fr/
20:54 < bridge> <learath2> Might be good to do a couple
21:22 < bridge> <ryozuki> https://blog.cloudflare.com/cloudflare-gen-12-server-bigger-better-cooler-in-a-2u1n-form-factor/
22:53 < bridge> <chairn> has anyone ever used or knows cling ?
22:54 < bridge> <chairn> https://github.com/root-project/cling
23:13 < ChillerDragon> interesting chairn but seems bloat
23:13 < ChillerDragon> i did not find cling in apt and rage quitted build from source after 2 minutes since i just cba
23:14 < ChillerDragon> i wrote my own C repl in bash and it gets the job done for what i need a C repl which is mostly testing oneliners and maybe reusing one variable
23:22 < bridge> <chairn> i tried to build it, but it just segfaults
23:22 < bridge> <chairn> given it's from CERN, i guess it's not maintained anymore, but there should be a working version somewhere
23:23 < bridge> <chairn> i found an apt repo with it, but i don't trust the repo
