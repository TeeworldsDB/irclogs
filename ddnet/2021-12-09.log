06:40 <+bridge> [ddnet] <ReD> with the lava puzzle, for these recursive approaches, I always instantly declare an extra array of booleans where I check if I already was at this index to avoid repetition. I wonder if this is the common way to do it
07:56 <+bridge> [ddnet] <Ryozuki> memoization?
08:38 <+bridge> [ddnet] <Ryozuki> im getting the example correct but with my input it doesnt work
08:38 <+bridge> [ddnet] <Ryozuki> ðŸ’€
08:47 <+bridge> [ddnet] <Ryozuki> 11011110
08:50 <+bridge> [ddnet] <Ryozuki> got the first part xd
08:53 <+bridge> [ddnet] <Ryozuki> https://support.alexa.com/hc/en-us/articles/4410503838999
08:54 <+bridge> [ddnet] <Ryozuki> lol this is surprising
08:54 <+bridge> [ddnet] <Ryozuki> > We will be retiring Alexa.com on May 1, 2022
08:54 <+bridge> [ddnet] <Ryozuki> https://news.ycombinator.com/item?id=29488522
08:55 <+bridge> [ddnet] <Ryozuki> >      
08:55 <+bridge> [ddnet] <Ryozuki> > ravenstine 11 hours ago | prev | next [â€“]
08:55 <+bridge> [ddnet] <Ryozuki> > 
08:55 <+bridge> [ddnet] <Ryozuki> > Are there any alternatives? I enjoy watching the long-term decline of the websites of former employers I don't like.
08:55 <+bridge> [ddnet] <Ryozuki> xd
20:04 <+bridge> [ddnet] <Index> eh sure :>
20:04 <+bridge> [ddnet] <Index> ```Bash
20:04 <+bridge> [ddnet] <Index> #!/bin/bash
20:04 <+bridge> [ddnet] <Index> shopt -s lastpipe; for l in `cut -d'|' -f2 "$1" | xargs | tr ' ' '\n'`; do [[ "2 4 3 7" =~ "${#l}" ]] && i=$((i+1)); done; echo $i
20:04 <+bridge> [ddnet] <Index> ```
20:04 <+bridge> [ddnet] <Index> (143 Bytes)
20:04 <+bridge> [ddnet] <Index> btw that didnt work for today, but somehow i have a p1 solution :>
20:04 <+bridge> [ddnet] <Index> ```Bash
20:04 <+bridge> [ddnet] <Index> #!/bin/bash
20:04 <+bridge> [ddnet] <Index> # Advent of Code 9p1
20:04 <+bridge> [ddnet] <Index> shopt -s lastpipe
20:04 <+bridge> [ddnet] <Index> declare -A f
20:04 <+bridge> [ddnet] <Index> i=0
20:04 <+bridge> [ddnet] <Index> while read -r l; do
20:04 <+bridge> [ddnet] <Index>     for j in {0..99}; do f[$i,$j]=${l:$j:1}; done
20:04 <+bridge> [ddnet] <Index>     i=$((i+1))
20:04 <+bridge> [ddnet] <Index> done < "$1"
20:04 <+bridge> [ddnet] <Index> for i in {0..99}; do
20:04 <+bridge> [ddnet] <Index>     for j in {0..99}; do
20:04 <+bridge> [ddnet] <Index>     l=${f[$i,$j]}
20:04 <+bridge> [ddnet] <Index>     if [ -z ${f[$((i-1)),$j]} ] || [[ ${f[$((i-1)),$j]} -gt $l ]]; then
20:04 <+bridge> [ddnet] <Index>         if [ -z ${f[$((i+1)),$j]} ] || [[ ${f[$((i+1)),$j]} -gt $l ]]; then
20:04 <+bridge> [ddnet] <Index>             if [ -z ${f[$i,$((j-1))]} ] || [[ ${f[$i,$((j-1))]} -gt $l ]]; then
20:04 <+bridge> [ddnet] <Index>                 if [ -z ${f[$i,$((j+1))]} ] || [[ ${f[$i,$((j+1))]} -gt $l ]]; then
20:04 <+bridge> [ddnet] <Index>                     [ -z $l ] && continue
20:04 <+bridge> [ddnet] <Index>                     a=$((a + l + 1))
20:04 <+bridge> [ddnet] <Index>                 fi
20:04 <+bridge> [ddnet] <Index>             fi
20:04 <+bridge> [ddnet] <Index>         fi
20:04 <+bridge> [ddnet] <Index>     fi
20:05 <+bridge> [ddnet] <Index>     done
20:05 <+bridge> [ddnet] <Index> done
20:05 <+bridge> [ddnet] <Index> echo $a
20:05 <+bridge> [ddnet] <Index> ```
20:05 <+bridge> [ddnet] <Index> eh sure :> (143 Bytes)
20:05 <+bridge> [ddnet] <Index> ```Bash
20:05 <+bridge> [ddnet] <Index> #!/bin/bash
20:05 <+bridge> [ddnet] <Index> shopt -s lastpipe; for l in `cut -d'|' -f2 "$1" | xargs | tr ' ' '\n'`; do [[ "2 4 3 7" =~ "${#l}" ]] && i=$((i+1)); done; echo $i
20:05 <+bridge> [ddnet] <Index> ```
20:12 <+bridge> [ddnet] <Izanagi> that looks so complicated
20:24 <+bridge> [ddnet] <Ryozuki> :monkaS:
20:25 <+bridge> [ddnet] <nouaa> ðŸ‘€
