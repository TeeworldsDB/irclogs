08:31 <+ChillerDragon> well deen i guess someone has to prepare something for next advent that looks like aoc but is secretly ddnet issues
08:35 <@deen> Hohoho, please fix bug #1234
09:09 <+ChillerDragon> lmao
10:42 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785803585660125204/unknown.png
10:42 <+bridge> [ddnet] <heinrich5991> @deen https://github.com/ddnet/ddnet/pull/3387 fixes CI. deletes two tests (EXPECT_STREQs) that were brittle anyway and would have to be kept in sync with the code
10:42 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785803596238159904/unknown.png
10:43 <+bridge> [ddnet] <Ryozuki> i used the same answer
10:43 <+bridge> [ddnet] <heinrich5991> `acc=1532`
10:43 <+bridge> [ddnet] <Ryozuki> oh damn
10:43 <+bridge> [ddnet] <heinrich5991> you accidentally put `acc=`
10:43 <+bridge> [ddnet] <Ryozuki> i copied wrong
10:43 <+bridge> [ddnet] <Ryozuki> thanks to that i wasted 30 mins
10:43 <+bridge> [ddnet] <Ryozuki> staring at my screen
10:43 <+bridge> [ddnet] <heinrich5991> oof
10:43 <+bridge> [ddnet] <Ryozuki> :pepe_straight:
10:45 <+bridge> [ddnet] <Ryozuki> <https://github.com/edg-l/adventofcode-2020/blob/master/day8b.rs>
10:51 <+bridge> [ddnet] <deen> I was trying to implement it in sed, but full programming in sed is more annoying than in perl
10:51 <+bridge> [ddnet] <heinrich5991> üòÑ
10:52 <+bridge> [ddnet] <deen> How to increment a number for example: https://www.gnu.org/software/sed/manual/sed.html#DOCF9
10:52 <+bridge> [ddnet] <heinrich5991> ouch
10:54 <+bridge> [ddnet] <mohsen7s> Will there be a webgl verwion of ddnet ?
10:54 <+bridge> [ddnet] <heinrich5991> there was one, but it got outdated
10:54 <+bridge> [ddnet] <heinrich5991> not if nobody works on it
10:54 <+bridge> [ddnet] <deen> and the servers don't run with websockets support atm
10:55 <+bridge> [ddnet] <deen> @mohsen7s https://github.com/eeeee/ddnet this is it
10:55 <+bridge> [ddnet] <deen> if you want to work on it, some people recently got it building again. the coolest thing would be a demo viewer in browser
10:59 <+bridge> [ddnet] <mohsen7s> @deen lol its 5 years old code
11:08 <+bridge> [ddnet] <Comrade> why do you support CMake 2.8? isn't that heavily deprecated? there's even no official documentation for versions below 3.0
11:10 <+bridge> [ddnet] <heinrich5991> @Comrade not sure if we actually build with it. but in theory for centos 6&7
11:10 <+bridge> [ddnet] <heinrich5991> here's the official docs for 2.8.12: https://cmake.org/cmake/help/v2.8.12/cmake.html
11:11 <+bridge> [ddnet] <Comrade> oh, didn't know that
11:11 <+bridge> [ddnet] <Comrade> https://cdn.discordapp.com/attachments/293493549758939136/785810840560468008/unknown.png
11:12 <+bridge> [ddnet] <Comrade> CMakeLists.txt with more than 2000 lines üò¶
11:29 <+bridge> [ddnet] <heinrich5991> > See older versions below.
11:29 <+bridge> [ddnet] <heinrich5991> yes, sorry for that
11:29 <+bridge> [ddnet] <heinrich5991> sorry for the 2000 lines I mean
11:30 <+bridge> [ddnet] <Comrade> i think CMake is like C++ - it's very hard to write clean code in it, especially when you try to maintain compatibility with legacy tools
11:31 <+bridge> [ddnet] <heinrich5991> but does it really need clean code? it'd be best if you didn't even need to touch it ^^
11:31 <+bridge> [ddnet] <Comrade> it should be clean, otherwise we can go back to autotools üòÑ
11:31 <+bridge> [ddnet] <heinrich5991> no, autotools doesn't work because it has poor windows support
11:32 <+bridge> [ddnet] <heinrich5991> I didn't choose cmake because it was "clean" or whatever
11:32 <+bridge> [ddnet] <heinrich5991> but because it was popular and well-supported by tooling
11:32 <+bridge> [ddnet] <Comrade> yes, it's de facto standard build system for C++
11:34 <+bridge> [ddnet] <Comrade> i think build scripts should be as clean as possible, so anyone can check what it actually does
11:34 <+bridge> [ddnet] <heinrich5991> with ninja and make you can print out what they actually do I think
11:34 <+bridge> [ddnet] <heinrich5991> `ninja -v` or `make VERBOSE=1`
11:35 <+bridge> [ddnet] <heinrich5991> helped me debug issues in the past
11:36 <+bridge> [ddnet] <Comrade> yes, but i mean checking it before actual building
11:36 <+bridge> [ddnet] <Comrade> for example, there are some configuration variables and you need to dig through that huge CMakeLists.txt to see what they do
11:38 <+bridge> [ddnet] <heinrich5991> hmm. my flippant answer would be: if you want to have configuration options, the cmakelists is going to be long. so why do you want to set options that are not documented in the readme?
11:40 <+bridge> [ddnet] <Comrade> aren't there some useful options that are not documented?
11:41 <+bridge> [ddnet] <heinrich5991> idk. right now it seems to me that you want conflicting things: a) short cmakelists.txt with b) many options
11:41 <+bridge> [ddnet] <Comrade> i think it's possible to have both
11:41 <+bridge> [ddnet] <heinrich5991> got an example?
11:41 <+bridge> [ddnet] <heinrich5991> of a "good" cmakelists?
11:41 <+bridge> [ddnet] <Comrade> if you remove all that code used by legacy version of CMake...
11:43 <+bridge> [ddnet] <Comrade> here's one of mine, but it's Windows-only project, so it's incomparable with DDNet
11:43 <+bridge> [ddnet] <Comrade> https://github.com/ccomrade/c1-launcher/blob/master/CMakeLists.txt
11:44 <+bridge> [ddnet] <Comrade> not sure if it's really a good one üòÑ
11:44 <+bridge> [ddnet] <heinrich5991> by my naive counting, this reduces the line count by 54 lines
11:44 <+bridge> [ddnet] <heinrich5991> dropping support for older cmake
11:44 <+bridge> [ddnet] <heinrich5991> 2660 ‚Üí 2606
11:45 <+bridge> [ddnet] <Comrade> let's see
11:46 <+bridge> [ddnet] <heinrich5991> I removed all if(POLICY) branches that aren't executed and the if statements themselves, plus all if(CMAKE_VERSION) branches that do not match the current version, plus the if statements themselves
11:51 <+bridge> [ddnet] <Comrade> i think if you get rid all those variables holding list of C++ source files, it should reduce line count as well
11:51 <+bridge> [ddnet] <Comrade> in newer CMake you can sources to target on-the-fly with `target_sources`
11:51 <+bridge> [ddnet] <Comrade> in newer CMake you can add sources to target on-the-fly with `target_sources`
11:54 <+bridge> [ddnet] <Comrade> but you're right that line count can't reduced that much because it's just complex project with a lot of things
11:55 <+bridge> [ddnet] <Comrade> it's only the begging of CMakeLists.txt that looks so messy, the rest is quite readable
11:55 <+bridge> [ddnet] <Comrade> it's only the beginning of CMakeLists.txt that looks so messy, the rest is quite readable
11:56 <+bridge> [ddnet] <Comrade> ideally, there should be no functions in CMake, but it's not always possible
12:02 <+bridge> [ddnet] <Ryozuki> @heinrich5991 what about https://cmake.org/cmake/help/latest/module/FetchContent.html
12:03 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785823757243383838/unknown.png
12:04 <+bridge> [ddnet] <heinrich5991> that would drop support for debian, unfortunately @Ryozuki
12:04 <+bridge> [ddnet] <Comrade> Debian has CMake 3.13
12:04 <+bridge> [ddnet] <Comrade> https://packages.debian.org/buster/cmake
12:04 <+bridge> [ddnet] <heinrich5991> oh indeed, wow
12:05 <+bridge> [ddnet] <Ryozuki> why r we supporting 2.8?
12:06 <+bridge> [ddnet] <heinrich5991> https://discord.com/channels/252358080522747904/293493549758939136/785810450482724865
12:06 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785824702110105600/unknown.png
12:06 <+bridge> [ddnet] <heinrich5991> https://github.com/ddnet/ddnet/pull/2085
12:06 <+bridge> [ddnet] <Ryozuki> i dont get why we want to support centos-7
12:07 <+bridge> [ddnet] <Ryozuki> this is a game we are talking about, u should expect to have a updated system
12:07 <+bridge> [ddnet] <heinrich5991> I guess the question is rather whether the dropped support gives us anything worthwhile in return
12:07 <+bridge> [ddnet] <heinrich5991> if not, we might as well support it
12:07 <+bridge> [ddnet] <Ryozuki> why
12:07 <+bridge> [ddnet] <Ryozuki> its probably only 1 or 2 people
12:07 <+bridge> [ddnet] <Ryozuki> using that
12:07 <+bridge> [ddnet] <Ryozuki> or maybe even 0
12:08 <+bridge> [ddnet] <Comrade> it seems CentOS 7 really has only CMake 2.8
12:08 <+bridge> [ddnet] <Comrade> what a shame
12:08 <+bridge> [ddnet] <heinrich5991> maintainability is a valid concern for dropping old version
12:08 <+bridge> [ddnet] <heinrich5991> s
12:08 <+bridge> [ddnet] <heinrich5991> but gaining nothing for dropping support doesn't seem sensible to me
12:08 <+bridge> [ddnet] <Ryozuki> https://geekylog.com/post/170938902714/install-cmake-3-in-centos-7
12:08 <+bridge> [ddnet] <Ryozuki> u can install cmake 3 on centos-7
12:09 <+bridge> [ddnet] <Comrade> dropping legacy code is valid reason i think, but it requires additional work
12:09 <+bridge> [ddnet] <heinrich5991> only if that legacy code is stopping you from doing anything, or being a pain to work with
12:09 <+bridge> [ddnet] <Ryozuki> https://centos.pkgs.org/7/okey-x86_64/cmake3-3.12.1-2.el7.x86_64.rpm.html
12:09 <+bridge> [ddnet] <Ryozuki> the pkg is called cmake3
12:09 <+bridge> [ddnet] <heinrich5991> dropping legacy code for the sake of dropping legacy code doesn't seem valid to me
12:09 <+bridge> [ddnet] <heinrich5991> @Ryozuki make a new survey which cmake versions are supported where and do a PR
12:10 <+bridge> [ddnet] <heinrich5991> https://github.com/ddnet/ddnet/pull/2085
12:10 <+bridge> [ddnet] <heinrich5991> EPEL seems to be some third-party repository
12:10 <+bridge> [ddnet] <Ryozuki> cmake3-3.17.3-3.el7.x86_64.rpm
12:11 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785825781296791582/unknown.png
12:11 <+bridge> [ddnet] <Ryozuki> official it says
12:11 <+bridge> [ddnet] <heinrich5991> > How do I install the extra repositories such as Fedora EPEL repo on a Red Hat Enterprise Linux server version 7.x or CentOS Linux server version 7.x?
12:11 <+bridge> [ddnet] <Ryozuki> i would say its common to use EPEL
12:11 <+bridge> [ddnet] <Ryozuki> in centos
12:11 <+bridge> [ddnet] <heinrich5991> I don't know anyone runnign centos, can't comment
12:11 <+bridge> [ddnet] <Ryozuki> same
12:11 <+bridge> [ddnet] <Ryozuki> but i would never run cmake 2.8
12:11 <+bridge> [ddnet] <heinrich5991> how can you say that it's common then?
12:11 <+bridge> [ddnet] <Ryozuki> because its what i would do
12:11 <+bridge> [ddnet] <Ryozuki> common sense
12:12 <+bridge> [ddnet] <Ryozuki> i always enable backports
12:12 <+bridge> [ddnet] <Ryozuki> in debian
12:12 <+bridge> [ddnet] <heinrich5991> I don't
12:17 <+bridge> [ddnet] <Comrade> no wonder companies like Adobe don't want to port their software to Linux when it's such a mess üòÑ
12:17 <+bridge> [ddnet] <Comrade> but proprietary software is bad anyway
12:36 <+ChillerDragon> +1
12:41 <+bridge> [ddnet] <Learath2> Not like windows is soooo much better. The only thing they do well is keeping forward compatibility
12:43 <+bridge> [ddnet] <Learath2> I have like 5 versions of msvcrt and 5 versions of vcr++. With 4 build configurations, so that's 40 runtimes any piece of code could be running on
12:44 <+ChillerDragon> macos masterrace
12:44 <+ChillerDragon> lul
12:44 <+bridge> [ddnet] <Learath2> The only reason adobe or any other company doesn't port to linux is MONEY. For profit corporations only care about maximizing shareholder profits
12:45 <+ChillerDragon> no adobe is just evil
12:45 <+ChillerDragon> good meme btw https://www.youtube.com/watch?v=158bJFTETRI
12:45 <+ChillerDragon> xd
12:45 <+bridge> [ddnet] <Comrade> yes, it's so sad that money controls everything
12:45 <+ChillerDragon> its only sad if u poor
12:45 <+bridge> [ddnet] <Comrade> üòÑ
12:46 <+bridge> [ddnet] <Learath2> macOS is indeed pretty good at backwards and forwards compatibility. They really have a great idea there with the has_feature. But the problem there is the framework compatibility shims
12:46 <+bridge> [ddnet] <Learath2> The frameworks behave differently depending on your deployment target
12:46 <+ChillerDragon> well my macbook had many struggles staying compatible with my i mobile devices lol
12:47 <+bridge> [ddnet] <Comrade> maintaining backward compatibility is a nice thing, but it has its drawbacks
12:47 <+bridge> [ddnet] <Comrade> just look at WinAPI üòÑ
12:47 <+ChillerDragon> just look at 0.6
12:47 <+bridge> [ddnet] <Comrade> https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-large_integer-r1 üòÑ
12:47 <+bridge> [ddnet] <Learath2> Hard part is forward compatibility anyway
12:48 <+ChillerDragon> isnt rust claiming to have gud forward compability
12:48 <+bridge> [ddnet] <Learath2> Winapi is a sad state of affairs, idk why people enjoy it
12:48 <+ChillerDragon> because it has win in the name
12:48 <+bridge> [ddnet] <Learath2> Like everything about windows at it's core it's actually decent
12:49 <+bridge> [ddnet] <Learath2> E.g. the ntkernel is actually fairly well designed and stable
12:49 <+bridge> [ddnet] <Comrade> that's questionable - using UTF-16 everywhere internally is not so good idea i think
12:50 <+bridge> [ddnet] <Comrade> but it was designed more than 20 years ago, so we can't really blame it for that decision
12:50 <+ChillerDragon> \n\r
12:50 <+bridge> [ddnet] <Comrade> \r\n üòÑ
12:50 <+ChillerDragon> xd
12:50 <+ChillerDragon> see so complicated
12:50 <+bridge> [ddnet] <Comrade> that's another good example
12:50 <+ChillerDragon> already messed it up
12:50 <+bridge> [ddnet] <Comrade> yes
12:50 <+bridge> [ddnet] <Learath2> I agree a lot of the backwards compat can be dropped
12:51 <+ChillerDragon> only good thing was clippy
12:51 <+bridge> [ddnet] <Learath2> But that will create bugs, which will break the illusion that windows is stable
12:51 <+bridge> [ddnet] <Learath2> So they instead have layers upon layers of compatibility
12:51 <+bridge> [ddnet] <Learath2> Did you know that Windows doesn't actually even use UTF16?
12:52 <+bridge> [ddnet] <Comrade> really?
12:52 <+bridge> [ddnet] <jao> :justatest:
12:52 <+bridge> [ddnet] <Learath2> It uses a non compliant mess internally to support their "codepages"
12:53 <+bridge> [ddnet] <Learath2> Whenever I hear the word codepage I feel like we are operating a ww2 submarine
12:53 <+bridge> [ddnet] <Comrade> isn't so called ANSI string using some codepage always converted to UTF-16 when you call some WinAPI function?
12:53 <+bridge> [ddnet] <Learath2> https://devblogs.microsoft.com/commandline/windows-command-line-unicode-and-utf-8-output-text-buffer/
12:53 <+bridge> [ddnet] <Learath2> 
12:53 <+bridge> [ddnet] <Learath2> I think I linked this here before, this explains the history of this mess rather well
12:53 <+bridge> [ddnet] <Ryozuki> it uses "editions" for that
12:53 <+ChillerDragon> ye
12:54 <+ChillerDragon> that thing
12:54 <+bridge> [ddnet] <Ryozuki> and modern rust compilers can compile old editions i think
12:54 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/edition-guide/editions/index.html
12:54 <+ChillerDragon> sounded cool
12:54 <+bridge> [ddnet] <Learath2> I'm not sure I like either solution for compilers
12:54 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785836806298009640/unknown.png
12:54 <+bridge> [ddnet] <timakro> @heinrich5991 I still don't get what's up with your alternative fixes for alloc of 0 and why there are so many changes.  Couldn
12:55 <+bridge> [ddnet] <Ryozuki> not sounded, sounds*
12:55 <+ChillerDragon> well i heard it a while ago
12:55 <+bridge> [ddnet] <Ryozuki> rust can have fast dev thanks to this
12:55 <+bridge> [ddnet] <Learath2> I don't mind letting old code only be compiled by old compilers, but what about compiler bugs?
12:55 <+bridge> [ddnet] <timakro> @heinrich5991 I still don't get what's up with your alternative fixes for alloc of 0 and why there are so many changes.  Couldn't we just keep the old commit and do
12:55 <+bridge> [ddnet] <timakro> ```
12:55 <+bridge> [ddnet] <timakro> --- a/src/game/editor/io.cpp
12:55 <+bridge> [ddnet] <timakro> +++ b/src/game/editor/io.cpp
12:55 <+bridge> [ddnet] <timakro> @@ -560,6 +560,10 @@ int CEditorMap::Save(class IStorage *pStorage, const char *pFileName)
12:55 <+bridge> [ddnet] <timakro>                 df.AddItem(MAPITEMTYPE_ENVPOINTS, 0, TotalSize, pPoints);
12:55 <+bridge> [ddnet] <timakro>                 free(pPoints);
12:55 <+bridge> [ddnet] <timakro>         }
12:55 <+bridge> [ddnet] <timakro> +       else
12:55 <+bridge> [ddnet] <timakro> +       {
12:55 <+bridge> [ddnet] <timakro> +               df.AddItem(MAPITEMTYPE_ENVPOINTS, 0, 0, NULL);
12:55 <+bridge> [ddnet] <timakro> +       }
12:55 <+bridge> [ddnet] <timakro> 
12:55 <+bridge> [ddnet] <timakro>         // finish the data file
12:56 <+bridge> [ddnet] <timakro>         df.Finish();
12:56 <+bridge> [ddnet] <timakro> ```
12:56 <+ChillerDragon> yeee
12:56 <+bridge> [ddnet] <Ryozuki> a modern rust compiler can compile old editions and maybe even fix bugs
12:56 <+bridge> [ddnet] <Ryozuki> i dont know much tho
12:56 <+ChillerDragon> sounds fun and all but ``$ [ "${BASH_VERSINFO:-0}" -ge 4 ] && echo "bash supports associative arrays"`` is still supirior ofc
12:56 <+bridge> [ddnet] <Learath2> But that means you need to carry around legacy cruft and even emulate bugs  sometimes
12:56 <+bridge> [ddnet] <Ryozuki> idk
12:56 <+bridge> [ddnet] <Ryozuki> im sure they have this well thought
12:57 <+ChillerDragon> rust fanboi
12:57 <+bridge> [ddnet] <Ryozuki> > Just to be clear: most features will be available on all editions. People using any edition of Rust will continue to see improvements as new stable releases are made. In some cases however, mainly when new keywords are added, but sometimes for other reasons, there may be new features that are only available in later editions. You only need to upgrade if you want to take advantage of such features.
12:57 <+bridge> [ddnet] <Learath2> All compilers do it. Clang and gcc need to keep support for almost 2 decades of c and C++ standards
12:57 <+ChillerDragon> @fokkonaut
12:58 <+bridge> [ddnet] <Learath2> Ah Rust seems to gate features, that might be a better compromise
12:59 <+bridge> [ddnet] <Comrade> @Learath2 Windows command line has to deal with those codepages for sure, but when your code calls, for example, CreateFileA, it internally converts your string to UTF-16 and forwards it to CreateFileW that does the actual syscall, so everything is in UTF-16 internally
13:00 <+bridge> [ddnet] <Learath2> Afaik its ucs2 for W too
13:00 <+bridge> [ddnet] <Comrade> well, yes, it's not real UTF-16 probably üòÑ
13:00 <+bridge> [ddnet] <Learath2> Fixed width
13:00 <+bridge> [ddnet] <Comrade> exactly
13:01 <+bridge> [ddnet] <Comrade> `sizeof (wchar_t)` returns 2 on Windows while it returns 4 everywhere else üòÑ
13:01 <+bridge> [ddnet] <Comrade> what a mess
13:02 <+bridge> [ddnet] <Learath2> My mantra is, if you are using a wchar, you are probably doing sth wrong
13:02 <+bridge> [ddnet] <Comrade> good mantra üòÑ
13:02 <+bridge> [ddnet] <Comrade> UTF-8 for the win
13:02 <+bridge> [ddnet] <Ryozuki> my mantra is dont use windows
13:02 <+bridge> [ddnet] <Ryozuki> <a:sadSnail:785072987815804929>
13:03 <+bridge> [ddnet] <Learath2> If only we could get mainstream adoption of linux :P
13:03 <+bridge> [ddnet] <Learath2> Won't happen without the flatpak bloar gettinf much much more popular
13:03 <+bridge> [ddnet] <Comrade> oh no üòÑ
13:03 <+bridge> [ddnet] <Learath2> Bloat*
13:04 <+bridge> [ddnet] <Comrade> isn't Flatpak basically reinventing Windows with additional security due to sandboxing?
13:05 <+bridge> [ddnet] <Learath2> Very similar, it packs every dependency though so it's even larger
13:06 <+bridge> [ddnet] <Comrade> Windows apps have to carry most of its dependencies as well
13:06 <+bridge> [ddnet] <Learath2> Critically windows apps dont carry msvcrt
13:07 <+bridge> [ddnet] <Learath2> Flatpaks carry libc iirc
13:08 <+bridge> [ddnet] <Learath2> Oh, btw has anyone seen qubesos?
13:09 <+bridge> [ddnet] <Learath2> Sounds like a great idea if you have a threadripper or a xeon workstation with many cores
13:09 <+bridge> [ddnet] <Learath2> Especially since kvm is blazing fast
13:10 <+bridge> [ddnet] <Ryozuki> @timakro nice bible u writing there
13:10 <+bridge> [ddnet] <Ryozuki> üëÄ
13:10 <+bridge> [ddnet] <Comrade> @Learath2 it does full virtualization, right?
13:11 <+bridge> [ddnet] <Learath2> @Comrade yep, sounds like the best attempt at privacy so far
13:11 <+bridge> [ddnet] <Comrade> i think it's just a waste of performance because containers can do the same with lower performance impact (shared kernel ettc)
13:11 <+bridge> [ddnet] <Learath2> I like apples approach on iOS too, they really know how to do sandboxes well
13:11 <+bridge> [ddnet] <Comrade> i think it's just a waste of performance because containers can do the same with lower performance impact (shared kernel etc)
13:12 <+bridge> [ddnet] <Learath2> Problem with containers is that they are just not as safe
13:12 <+bridge> [ddnet] <Comrade> even full virtualization is not safe üòÑ
13:12 <+bridge> [ddnet] <Comrade> VM escape is real thing
13:13 <+bridge> [ddnet] <Comrade> but yes, containers are slightly safe always
13:13 <+bridge> [ddnet] <Learath2> Well ofc, but find a bug in kvm and you'll be compromising a whole lot of hosters infrastructures
13:13 <+bridge> [ddnet] <Comrade> *slightly less safe
13:13 <+bridge> [ddnet] <Learath2> Containers are much better nowadays though
13:13 <+bridge> [ddnet] <Ryozuki> docker and its loads of gb per container
13:14 <+bridge> [ddnet] <Comrade> Docker is fail üòÑ
13:14 <+bridge> [ddnet] <Learath2> God I hate docker
13:14 <+bridge> [ddnet] <Comrade> systemd-nspawn is the way
13:14 <+bridge> [ddnet] <Comrade> (no flame war today) üòÑ
13:15 <+bridge> [ddnet] <Learath2> LXC itself is nice, I wish someone else would implement the interface
13:16 <+bridge> [ddnet] <timakro> When the rust club is here I might as well ask a question. For todays advent puzzle I have a program counter variable `pc` which should probably be of type `usize` because it indexes the vector of instructions and I compare it to the length of the vector of instructions. But I want to add an`i32` to `pc` which can be negative. I don't want to fail silently on conversions, thus I can't use `as`. How should I solve this? I have 2 solutions in
13:16 <+bridge> [ddnet] <timakro> 1. When adding to `pc` convert `pc` to `i32` first and then the result back to `usize` like this `pc = usize::try_from(i32::try_from(pc).unwrap() + x).unwrap()`
13:16 <+bridge> [ddnet] <timakro> 2. Make `pc` an `i32` instead and everywhere were I need `usize` write`usize::try_from(pc).unwrap()`
13:16 <+bridge> [ddnet] <Ryozuki> declare it as i32
13:16 <+bridge> [ddnet] <Ryozuki> and cast it
13:16 <+bridge> [ddnet] <Ryozuki> pc as usize
13:16 <+bridge> [ddnet] <Ryozuki> when indexing
13:16 <+bridge> [ddnet] <Ryozuki> i do that
13:17 <+bridge> [ddnet] <Ryozuki> `pc as usize`
13:17 <+bridge> [ddnet] <Ryozuki> ah
13:17 <+bridge> [ddnet] <Ryozuki> ah
13:17 <+bridge> [ddnet] <Ryozuki> u dont want as
13:17 <+bridge> [ddnet] <Ryozuki> but i think its not a problem in this puzzle
13:18 <+bridge> [ddnet] <timakro> l
13:18 <+bridge> [ddnet] <timakro> o
13:18 <+bridge> [ddnet] <timakro> l
13:18 <+bridge> [ddnet] <Ryozuki> ?
13:18 <+bridge> [ddnet] <Ryozuki> lol
13:19 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785842872100192266/unknown.png
13:19 <+bridge> [ddnet] <Ryozuki> <a:sadSnail:785072987815804929>
13:19 <+bridge> [ddnet] <timakro> yeah whatever I should do that
13:20 <+bridge> [ddnet] <timakro> but why does rust make the unsafe option the nice and short one to write and for TryInto you even need to import stuff first
13:21 <+bridge> [ddnet] <Ryozuki> well u need to import that trait
13:22 <+bridge> [ddnet] <timakro> put it in prelude
13:22 <+bridge> [ddnet] <Ryozuki> i dont think its common enough
13:28 <+bridge> [ddnet] <timakro> ```
13:28 <+bridge> [ddnet] <timakro>     for i in &mut instr {
13:28 <+bridge> [ddnet] <timakro>         if let Instr::ACC(a) = *i {
13:28 <+bridge> [ddnet] <timakro>             *i = Instr::NOP(a);
13:28 <+bridge> [ddnet] <timakro>         } else if let Instr::NOP(a) = *i {
13:28 <+bridge> [ddnet] <timakro>             *i = Instr::ACC(a);
13:28 <+bridge> [ddnet] <timakro>         }
13:28 <+bridge> [ddnet] <timakro>         if let SimResult::Term(acc) = simulate(&instr) {
13:28 <+bridge> [ddnet] <timakro>             println!("Found solution, accumulator is {}", acc);
13:28 <+bridge> [ddnet] <timakro>         }
13:28 <+bridge> [ddnet] <timakro>     }
13:28 <+bridge> [ddnet] <timakro> ```
13:28 <+bridge> [ddnet] <timakro> ```
13:28 <+bridge> [ddnet] <timakro> error[E0502]: cannot borrow `instr` as immutable because it is also borrowed as mutable
13:28 <+bridge> [ddnet] <timakro>   --> src/main.rs:62:48
13:28 <+bridge> [ddnet] <timakro>    |
13:28 <+bridge> [ddnet] <timakro> 56 |     for i in &mut instr {
13:28 <+bridge> [ddnet] <timakro>    |              ----------
13:28 <+bridge> [ddnet] <timakro>    |              |
13:28 <+bridge> [ddnet] <timakro>    |              mutable borrow occurs here
13:28 <+bridge> [ddnet] <timakro>    |              mutable borrow later used here
13:28 <+bridge> [ddnet] <timakro> ...
13:28 <+bridge> [ddnet] <timakro> 62 |         if let SimResult::Term(acc) = simulate(&instr) {
13:28 <+bridge> [ddnet] <timakro>    |                                                ^^^^^^ immutable borrow occurs here
13:28 <+bridge> [ddnet] <timakro> ```
13:29 <+bridge> [ddnet] <timakro> I never really understood why those struct borrow rules. Thread safety I guess, but I have no threads ...
13:29 <+bridge> [ddnet] <timakro> I never really understood why those strict borrow rules. Thread safety I guess, but I have no threads ...
13:29 <+bridge> [ddnet] <Ryozuki> wats instr
13:29 <+bridge> [ddnet] <timakro> a `Vec<Instr>`
13:30 <+bridge> [ddnet] <Ryozuki> try instr.iter()
13:30 <+bridge> [ddnet] <Ryozuki> and put the &mut in the i
13:30 <+bridge> [ddnet] <Ryozuki> iirc
13:30 <+bridge> [ddnet] <Ryozuki> ah
13:30 <+bridge> [ddnet] <Ryozuki> @time
13:30 <+bridge> [ddnet] <Ryozuki> @timakro iter_mut()
13:31 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785845933366706206/unknown.png
13:31 <+bridge> [ddnet] <timakro> It's the same
13:31 <+bridge> [ddnet] <Ryozuki> remove the &
13:31 <+bridge> [ddnet] <Ryozuki> in the simulate
13:31 <+bridge> [ddnet] <Ryozuki> hmm
13:31 <+bridge> [ddnet] <timakro> I want to borrow though
13:31 <+bridge> [ddnet] <Ryozuki> try it
13:32 <+bridge> [ddnet] <timakro> It takes &Instr?
13:32 <+bridge> [ddnet] <timakro> sry
13:32 <+bridge> [ddnet] <timakro> &Vec<Instr>
13:32 <+bridge> [ddnet] <timakro> I can ofc iterate over the indices
13:32 <+bridge> [ddnet] <timakro> I doubt I'll ever be able to write rust and be sure  that it compiles
13:33 <+bridge> [ddnet] <timakro> It's more like trial and error
13:33 <+bridge> [ddnet] <Ryozuki> u just dont know well enough how the borrow stuff works
13:33 <+bridge> [ddnet] <Ryozuki> can u send me the code u have
13:33 <+bridge> [ddnet] <timakro> I guess spoiled by other languages, I'll never get used to those borrow restrictions
13:34 <+bridge> [ddnet] <timakro> It's not that I can't make it work, just thinking of the best/idiomatic solution
13:34 <+bridge> [ddnet] <Ryozuki> well if u dont have the will to do so i guess
13:34 <+bridge> [ddnet] <Ryozuki> yeah and i want to try to show u
13:36 <+bridge> [ddnet] <Ryozuki> i guess this is what u want to achieve right
13:36 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785847261376151602/unknown.png
13:36 <+bridge> [ddnet] <timakro> @Ryozuki https://termbin.com/bj9l
13:43 <+bridge> [ddnet] <timakro> Ok, I just iterated over the indices now and solved the puzzle ü•≥
13:43 <+bridge> [ddnet] <timakro> But I still want to understand the purpose of the borrow rules. That would be the only way for me to learn them
13:44 <+bridge> [ddnet] <timakro> I never got behind the purpose really
13:44 <+bridge> [ddnet] <Ryozuki> @timakro
13:44 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785849260594692116/unknown.png
13:44 <+bridge> [ddnet] <Ryozuki> yeah iterating with indices and using get_mut is the best choice here
13:45 <+bridge> [ddnet] <timakro> because I need to swap it back later anyways I'm just indexing now
13:46 <+bridge> [ddnet] <timakro> ```
13:46 <+bridge> [ddnet] <timakro>     for i in 0..instr.len() {
13:46 <+bridge> [ddnet] <timakro>         if let Instr::JMP(a) = instr[i] {
13:46 <+bridge> [ddnet] <timakro>             instr[i] = Instr::NOP(a);
13:46 <+bridge> [ddnet] <timakro>         } else if let Instr::NOP(a) = instr[i] {
13:46 <+bridge> [ddnet] <timakro>             instr[i] = Instr::JMP(a);
13:46 <+bridge> [ddnet] <timakro>         }
13:46 <+bridge> [ddnet] <timakro>         if let SimResult::Term(acc) = simulate(&instr) {
13:46 <+bridge> [ddnet] <timakro>             println!("Found solution, accumulator is {}", acc);
13:46 <+bridge> [ddnet] <timakro>         }
13:46 <+bridge> [ddnet] <timakro>         if let Instr::JMP(a) = instr[i] {
13:46 <+bridge> [ddnet] <timakro>             instr[i] = Instr::NOP(a);
13:46 <+bridge> [ddnet] <timakro>         } else if let Instr::NOP(a) = instr[i] {
13:46 <+bridge> [ddnet] <timakro>             instr[i] = Instr::JMP(a);
13:46 <+bridge> [ddnet] <timakro>         }
13:46 <+bridge> [ddnet] <timakro>     }
13:46 <+bridge> [ddnet] <timakro> ```
13:47 <+bridge> [ddnet] <Ryozuki> @timakro maybe reading this helps https://rust-unofficial.github.io/too-many-lists/index.html
13:47 <+bridge> [ddnet] <Ryozuki> idk why i prefer using .get instead of indexing directly
13:48 <+bridge> [ddnet] <Ryozuki> u can handle the error
13:48 <+bridge> [ddnet] <timakro> Well, this example from the book really blew my mind
13:48 <+bridge> [ddnet] <timakro> ```
13:48 <+bridge> [ddnet] <timakro>     let mut v = vec![1, 2, 3, 4, 5];
13:48 <+bridge> [ddnet] <timakro> 
13:48 <+bridge> [ddnet] <timakro>     let first = &v[0];
13:48 <+bridge> [ddnet] <timakro> 
13:48 <+bridge> [ddnet] <timakro>     v.push(6);
13:48 <+bridge> [ddnet] <timakro> 
13:48 <+bridge> [ddnet] <timakro>     println!("The first element is: {}", first);
13:48 <+bridge> [ddnet] <timakro> ```
13:48 <+bridge> [ddnet] <timakro> I was like why doesn't it compile. But the explanation is
13:48 <+bridge> [ddnet] <timakro> > The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn‚Äôt enough room to put all the elements next to each other where the vector currently is. In that case, t
13:48 <+bridge> [ddnet] <timakro> That's awesome.
13:48 <+bridge> [ddnet] <timakro> 
13:48 <+bridge> [ddnet] <timakro> But in my situation above I don't see a problem. Sure the scope of the loop can mutate the Vector, but it can't do that while the function is running, because well, the function is running
13:49 <+bridge> [ddnet] <Ryozuki> this is why rust isnt a easy language
13:49 <+bridge> [ddnet] <Ryozuki> i also fighted against the borrow checker
13:49 <+bridge> [ddnet] <Ryozuki> xdd
13:49 <+bridge> [ddnet] <Ryozuki> and sometimes still do
13:49 <+bridge> [ddnet] <Ryozuki> but i still like it
13:52 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/nomicon/hrtb.html
13:52 <+bridge> [ddnet] <Ryozuki> i once struggled with this xd
14:06 <+bridge> [ddnet] <Learath2> Day 8 was fun
14:07 <+bridge> [ddnet] <Ryozuki> yeah
14:07 <+bridge> [ddnet] <Ryozuki> but too simple
14:09 <+bridge> [ddnet] <Learath2> Well last year you expanded quite a bit on your "computer" over the days, I guess it'll be like that again
14:09 <+bridge> [ddnet] <Ryozuki> well this is not our computer
14:09 <+bridge> [ddnet] <Ryozuki> its a kid gameboy
14:09 <+bridge> [ddnet] <Ryozuki> i doubt we will be with the kid longer
14:09 <+bridge> [ddnet] <Ryozuki> xd
14:09 <+bridge> [ddnet] <Learath2> we might snatch it üòõ
14:10 <+bridge> [ddnet] <heinrich5991> @timakro you can opt into "single threaded, etc." by wrapping your copyable type in a `Cell`
14:10 <+bridge> [ddnet] <Ryozuki> oh
14:10 <+bridge> [ddnet] <Learath2> I don't quite like my solution today but didn't really feel like cleaning it up
14:10 <+bridge> [ddnet] <heinrich5991> it has `set` and `get` which only take a constant reference
14:10 <+bridge> [ddnet] <Ryozuki> i should look more into Cell
14:11 <+bridge> [ddnet] <Ryozuki> til
14:11 <+bridge> [ddnet] <heinrich5991> @timakro my diff is very small to the original code, before deen changed it
14:12 <+bridge> [ddnet] <Learath2> Oh btw @heinrich5991 we can build with cmake 2.8 there were two broken things and I fixed them üòõ
14:12 <+bridge> [ddnet] <heinrich5991> oh interesting
14:13 <+bridge> [ddnet] <heinrich5991> https://github.com/ddnet/ddnet/compare/a4f13ed4a85a4a2b2e901342a9f4341c779e883c%5E...e805e42a9469c4c3bb47f87903d224469db06c85#diff-472b2e75e6cbd3e80ec9ec50e60d8b0dc61c4b9aa81f67ae395cc5d375875a0eR273
14:13 <+bridge> [ddnet] <heinrich5991> https://github.com/ddnet/ddnet/compare/a4f13ed4a85a4a2b2e901342a9f4341c779e883c%5E...e805e42a9469c4c3bb47f87903d224469db06c85#diff-472b2e75e6cbd3e80ec9ec50e60d8b0dc61c4b9aa81f67ae395cc5d375875a0eR539
14:13 <+bridge> [ddnet] <heinrich5991> these are the only two lines that I changed
14:13 <+bridge> [ddnet] <timakro> @heinrich5991 Oh, didn't see that's the point, I agree then
14:13 <+bridge> [ddnet] <Ryozuki> @heinrich5991 why cell and not refcell?
14:13 <+bridge> [ddnet] <heinrich5991> @Ryozuki because it plays nicer with copyable types
14:13 <+bridge> [ddnet] <heinrich5991> no panicking functions
14:13 <+bridge> [ddnet] <Ryozuki> > Shareable mutable containers exist to permit mutability in a controlled manner, even in the presence of aliasing. Both Cell<T> and RefCell<T> allow doing this in a single-threaded way. However, neither Cell<T> nor RefCell<T> are thread safe (they do not implement Sync). If you need to do aliasing and mutation between multiple threads it is possible to use Mutex, RwLock or atomic types.
14:13 <+bridge> [ddnet] <Ryozuki> nice
14:14 <+bridge> [ddnet] <Ryozuki> so this is what cell stuff is for
14:14 <+bridge> [ddnet] <Ryozuki> very useful
14:14 <+bridge> [ddnet] <heinrich5991> it's a bit annoying to use, because it doesn't has first-class language support
14:16 <+bridge> [ddnet] <heinrich5991> btw, you never need `x.iter()` or `x.iter_mut()` in the parameter of a for loop @Ryozuki. use `&x` or `&mut x` instead
14:16 <+bridge> [ddnet] <Ryozuki> why not
14:16 <+bridge> [ddnet] <Ryozuki> is there a difference
14:17 <+bridge> [ddnet] <heinrich5991> no difference, but I think the rust style is using the latter
14:17 <+bridge> [ddnet] <Learath2> Well the compiler is smart enough to figure it out for you, you usually let it
14:17 <+bridge> [ddnet] <Ryozuki> i thought the style was using iter()
14:20 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/rust-by-example/flow_control/for.html
14:20 <+bridge> [ddnet] <Ryozuki> they dont show that here
14:20 <+bridge> [ddnet] <heinrich5991> interesting. the Vec doc uses & though
14:23 <+bridge> [ddnet] <heinrich5991> I can't find anything about that right now. I assumed it was the other way around because the &/&mut syntax was explicitly introduced after the other syntax already existed
14:23 <+bridge> [ddnet] <Ryozuki> i think iter is more explicit
14:24 <+bridge> [ddnet] <timakro> I think & is shorter :D
14:24 <+bridge> [ddnet] <heinrich5991> https://github.com/rust-lang/rfcs/blob/master/text/0235-collections-conventions.md#benefits-of-intoiterator
14:25 <+bridge> [ddnet] <heinrich5991> oof, that is old. rust used to change a lot back then üòÑ
14:26 <+bridge> [ddnet] <Ryozuki> üëÄ
19:10 <+bridge> [ddnet] <deen> C is more reasonable: https://github.com/def-/adventofcode-2020/blob/master/day08.c
19:28 <+bridge> [ddnet] <Learath2> cute
19:47 <+bridge> [ddnet] <Ryozuki> that switch is smart
19:47 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785940679380697118/unknown.png
19:47 <+bridge> [ddnet] <Ryozuki> :POGGIES:
19:54 <+bridge> [ddnet] <heinrich5991> oof. implicit fallthrough
19:54 <+bridge> [ddnet] <heinrich5991> bad deen
20:25 <+bridge> [ddnet] <Learath2> implicit fallthrough ‚ù§Ô∏è
20:26 <+bridge> [ddnet] <heinrich5991> @Learath2 any reason to not use explicit fallthrough?
20:27 <+bridge> [ddnet] <Learath2> prettier :P\
20:27 <+bridge> [ddnet] <heinrich5991> // fallthrough
20:27 <+bridge> [ddnet] <heinrich5991> ‚Ä¶
20:30 <+bridge> [ddnet] <timakro> // Durchfall
20:36 <+ChillerDragon> oof :D
20:38 <+ChillerDragon> lul github darkmode rlsd
20:39 <+ChillerDragon> rip all the ppl who bought some 3rd party software :D
20:50 <+bridge> [ddnet] <Ryozuki> was it released
20:51 <+bridge> [ddnet] <Ryozuki> omg
20:51 <+bridge> [ddnet] <Ryozuki> true
20:51 <+bridge> [ddnet] <Ryozuki> insane
20:51 <+bridge> [ddnet] <Ryozuki> so many years
20:51 <+bridge> [ddnet] <Ryozuki> for this
20:51 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/785956845369950208/unknown.png
20:54 <+bridge> [ddnet] <timakro> lol
20:54 <+bridge> [ddnet] <timakro> it's dark
20:56 <+bridge> [ddnet] <Learath2> finally...
21:08 <+bridge> [ddnet] <jao> :justatest:
21:56 <+bridge> [ddnet] <NeXus> :PogU:
21:57 <+bridge> [ddnet] <NeXus> :PogU: üëâüèº üåÉ
22:15 <+bridge> [ddnet] <Souly> white themes suck
