00:44 < bridge> <heinrich5991> are github/gitlab written in ruby?
00:45 < bridge> <heinrich5991> same as the C libraries â€” using asm. there's no other way, neither for C nor for Rust as far as I'm aware
01:12 < bridge> <Kaffeine> (yes, both. GitLab: https://gitlab.com/gitlab-org/gitlab shows `Ruby: 69.2%`; for GitHub the percentage is lower but still)
01:50 < bridge> <learath2> modern amd boards can have usb4 which is pretty much on par
01:58 < bridge> <Ewan> itâ€™s 5th gen
02:01 < bridge> <Ewan> usb 4 seems cool
02:01 < bridge> <Ewan> never used it
04:42 < bridge> <teero777> gm bois
04:44 < bridge> <meloÆž> gm teero
04:44 < bridge> <meloÆž> why up so early?
09:27 < bridge> <fokkonaut> ill
09:27 < bridge> <milkeeycat> I asked how I should do some thing at work, and here's the answer:
09:27 < bridge> <milkeeycat> > Think for yourself and face the consequences of your decisions. ðŸ˜›
12:08 < bridge> <heinrich5991> https://docs.rs/splitbits/0.1.2/splitbits/
12:08 < bridge> <heinrich5991> interesting crate, you can use `splitbits!(0b11110000, "aaabbbbb");` to parse a byte into two bit fields
12:34 < bridge> <heinrich5991> https://docs.rs/bitmatch/0.1.1/bitmatch/ even more interesting ðŸ˜„
12:34 < bridge> <heinrich5991> I should write a CPU emulator now using this ^^
13:22 < bridge> <ryozuki> looks nice
13:22 < bridge> <ryozuki> it wouyld be nice to tell docs.rs to regenerate docs using latest rustdocs
13:22 < bridge> <ryozuki> the page doesnt even support dark theme
13:23 < bridge> <ryozuki> 4 year ago last update
14:30 < bridge> <learath2> This might be the coolest macro I've seen yet
14:32 < bridge> <ryozuki> actually this might help my riscv emu
14:33 < bridge> <ryozuki> https://shafik.github.io/c++/llvm/2024/10/17/triaging-clang-fronend-bugs.html
15:08 < bridge> <teero777> hey are the skin proportions and stuff available somewhere?
15:08 < bridge> <Jupstar âœª> $wiki skin render
15:08 < bridge> <Jupstar âœª> $skin
15:08 < bridge> <DDNet> This command was not found.
15:08 < bridge> <Jupstar âœª> $wiki skin
15:08 < bridge> <Jupstar âœª> C'mon
15:08 < bridge> <Jupstar âœª> We had them saved somewhere
15:08 < bridge> <teero777> $wiki pleas help
15:14 < bridge> <robyt3> $wiki skin rendering
15:14 < bridge> <robyt3> weird, shouldn't this find https://wiki.ddnet.org/wiki/Development#About_Tee_Skin_Rendering ?
15:18 < bridge> <Jupstar âœª> @teero777 there you have it
15:18 < bridge> <Jupstar âœª> You can continue writing your OpenGL 4.6 x OpenGL 2.1 mix renderer
15:25 < bridge> <teero777> thanks
16:49 < bridge> <ryozuki> i wanna buy a flipper zero
17:00 < bridge> <Ewan> yea
17:00 < bridge> <Ewan> they look fun
17:02 < bridge> <learath2> I was right about to buy one, then I thought, what would I really do with one
17:04 < bridge> <learath2> If you want a software defined radio to mess with something like a hackrf one is much more capable
17:05 < bridge> <heinrich5991> I (permanently? lol) borrowed a hackrf but haven't done a lot with it yet
17:05 < bridge> <heinrich5991> I tried to clone some gate remote with it
17:06 < bridge> <heinrich5991> but I'm bad at signal processing, it turns out
17:06 < bridge> <heinrich5991> should learn more about thatâ€¦
17:08 < bridge> <learath2> Well a lot of things now are immune to simple replay attacks
17:12 < bridge> <heinrich5991> well, it's one-way communication and not time-based
17:12 < bridge> <heinrich5991> so if the gate does not receive any signal from the remote and I record one "open" signal, the gate should open when I play it back near the gate
17:13 < bridge> <heinrich5991> but I didn't even manage to do that
17:14 < bridge> <learath2> Not time based as in it doesn't contain an RTC or as in the signal never changes no matter how many times you press the button? Because rolling codes are a thing
17:15 < bridge> <heinrich5991> does not contain an RTC
17:15 < bridge> <heinrich5991> it's a rolling code
17:15 < bridge> <heinrich5991> but my proposed setup should work for a rolling code
17:15 < bridge> <learath2> did you make sure you record the signal where the receiver didn't get it?
17:15 < bridge> <heinrich5991> yes
17:16 < bridge> <learath2> Then yeah, it's a signalling issue, I've never been great with signals either ðŸ˜„
18:19 < bridge> <louis> ðŸ¤‘
18:29 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1298684830480863314/20241023_182857.jpg?ex=671a75ff&is=6719247f&hm=52729cbb295d0f1eaa2ec335273819a941102a211d804dedc4112f11040936ef&
18:30 < bridge> <Jupstar âœª> dreams are powerful
18:32 < bridge> <learath2> This man was truly special, It's such a loss that he died so young
18:43 < bridge> <ryozuki> yeah, respect
18:44 < bridge> <learath2> > Imagine that you are on a street with houses marked 1 through n. There is a house in between (x) such that the sum of the house numbers to the left of it equals the sum of the house numbers to its right. If n is between 50 and 500, what are n and x?' This is a bivariate problem with multiple solutions. Ramanujan thought about it and gave the answer with a twist: He gave a continued fraction. The unusual part was that it was the solution to the w
18:46 < bridge> <inv41idu53rn4m3> man got actual hax
18:47 < bridge> <learath2> Divine inspiration, he seemed to have a direct line to god
18:57 < bridge> <Jupstar âœª> the same god that let him die young?
18:57 < bridge> <learath2> Perhaps he insulted god through the direct line, we'll never know ðŸ™ƒ
19:33 < bridge> <milkeeycat> Rust pros, why isn't it possible to drop variable here https://github.com/alumina-lang/alumina/blob/d37bba06ce8882820731cef103cd9c7d77bc547a/src/alumina-boot/src/compiler.rs#L263
19:47 < bridge> <teero777> why does github recognize my c as c++??
19:47 < bridge> <teero777> https://cdn.discordapp.com/attachments/293493549758939136/1298704324615995393/image.png?ex=671a8827&is=671936a7&hm=fbd5c884678d518c114a6d7ffca1482d9a981aa94261666dc074bf2895c94390&
19:49 < bridge> <Jupstar âœª> real c code uses underscores everywhere
19:49 < bridge> <Jupstar âœª> ðŸ˜¬
19:51 < bridge> <ryozuki> god
19:52 < bridge> <ryozuki> i think it recognizes .h files as c++
19:52 < bridge> <learath2> The compiler should be telling you why
19:54 < bridge> <milkeeycat> my reptile brain no understand
19:54 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1298706219653005434/image.png?ex=671a89eb&is=6719386b&hm=6e48807ed03c182720d3cd41ad7b2137ab4048ae888a2db1907c3bdfe84ca01c&
19:54 < bridge> <milkeeycat> BUT
19:55 < bridge> <milkeeycat> if i remove lifetime from self on method
19:55 < bridge> <milkeeycat> it doesn't show the error
19:55 < bridge> <milkeeycat> :thonk:
19:56 < bridge> <ryozuki> @milkeeycat ur holding c which borrows ast
19:56 < bridge> <ryozuki> and trying to drop ast while borrowed
19:56 < bridge> <ryozuki> what is c value?
19:56 < bridge> <ryozuki> is it a ref?
19:56 < bridge> <ryozuki> can u clone() c?
19:58 < bridge> <mclovin5yo> Guys i just got 1.43T score in osu thats like top 5 world
19:59 < bridge> <learath2> Perhaps `parse_path` could return a `PathBuf` instead
20:00 < bridge> <ryozuki> ok
20:02 < bridge> <milkeeycat> Shouldn't it work if I drop c before ast?
20:03 < bridge> <learath2> Just show the new compiler error ðŸ˜„
20:04 < bridge> <ryozuki> ye
20:04 < bridge> <learath2> I've found the best way to figure out what's going on with Rust is to just try it and let borrowck point out the issue. Trying to understand anything more than the basics of the rules of borrows is beyond the capabilities of my human brain
20:04 < bridge> <ryozuki> but u have to imagine c is dropped at the } bracket
20:05 < bridge> <ryozuki> well thats the purpose of borrow checker
20:05 < bridge> <learath2> Might not work with an explicit drop, I remember borrowck having an issue with those combined with explicit lifetimes
20:05 < bridge> <ryozuki> it may invalidate some valid code but it makes all invalid code non compile
20:06 < bridge> <ryozuki> the explicit drop is nothing fancy, it just takes the value by value
20:06 < bridge> <ryozuki> which is like taking ownership
20:06 < bridge> <ryozuki> drop is implemented like fn drop(x: T)  {} literally
20:06 < bridge> <milkeeycat> it's the same .__.
20:06 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1298709140654522368/image.png?ex=671a8ca3&is=67193b23&hm=3ab080654c69f08ff15315d8074f29c88a8803397234ea74505a21c217a42a6a&
20:06 < bridge> <ryozuki> can u show me parse_path fn?
20:06 < bridge> <learath2> Yeah, see, it's not the smartest ðŸ˜„
20:06 < bridge> <ryozuki> pls
20:06 < bridge> <learath2> `pub fn parse_path(&'ast self, path: &'_ str) -> Path<'ast>`
20:07 < bridge> <ryozuki> @milkeeycat what if u put the 
20:07 < bridge> <ryozuki> 
20:07 < bridge> <ryozuki> ```rust
20:07 < bridge> <ryozuki> 
20:07 < bridge> <ryozuki> {
20:07 < bridge> <ryozuki> let c = asdsadsa
20:07 < bridge> <ryozuki> }
20:07 < bridge> <ryozuki> drop
20:07 < bridge> <ryozuki> ```
20:07 < bridge> <ryozuki> do it like this
20:07 < bridge> <ryozuki> i always prefer using brackets for specifing lifetimes
20:07 < bridge> <ryozuki> before drops
20:07 < bridge> <ryozuki> blocks*
20:08 < bridge> <learath2> Yeah, the block might work, I vaguely remember blocks working better
20:08 < bridge> <ryozuki> why does it take 'ast lifetime? shouldnt it take the str lifetime?Â¿
20:09 < bridge> <ryozuki> whats going on
20:09 < bridge> <learath2> idk, not my code https://github.com/alumina-lang/alumina/blob/master/src/alumina-boot/src/ast/mod.rs#L145
20:09 < bridge> <teero777> hmmm i don't think there is a way to fix that righht?
20:09 < bridge> <ryozuki> there is
20:09 < bridge> <ryozuki> find .gitattributes file format on github
20:10 < bridge> <ryozuki> ye its wrong
20:10 < bridge> <teero777> ah i found it thx
20:10 < bridge> <ryozuki> ah no
20:10 < bridge> <ryozuki> idk
20:10 < bridge> <learath2> @milkeeycat if having c inside a block works try with `-Zpolonius` on nightly, I'm just curious
20:11 < bridge> <ryozuki> cmon cat
20:11 < bridge> <ryozuki> answer!
20:11 < bridge> <ryozuki> no purrs
20:11 < bridge> <ryozuki> btw it allocates the path on a arena
20:11 < bridge> <ryozuki> but it doesnt do any interning
20:11 < bridge> <learath2> I think the lifetimes look sane for that method btw, it borrows from the ast, if you want to keep it longer than the ast you need an owned pathbuf instead
20:12 < bridge> <ryozuki> tell them they can optimize it
20:12 < bridge> <ryozuki> yeah, the Path is not the std path, its their own struct
20:12 < bridge> <learath2> Oh, that's interesting
20:12 < bridge> <ryozuki> ```rust
20:12 < bridge> <ryozuki>     pub fn parse_path(&'ast self, path: &'_ str) -> Path<'ast> {
20:12 < bridge> <ryozuki>         let (path, absolute) = if path.starts_with("::") {
20:12 < bridge> <ryozuki>             (path.strip_prefix("::").unwrap(), true)
20:12 < bridge> <ryozuki>         } else {
20:12 < bridge> <ryozuki>             (path, false)
20:12 < bridge> <ryozuki>         };
20:12 < bridge> <ryozuki> 
20:13 < bridge> <ryozuki>         let segments: Vec<_> = path
20:13 < bridge> <ryozuki>             .split("::")
20:13 < bridge> <ryozuki>             .filter_map(|s| {
20:13 < bridge> <ryozuki>                 if s.is_empty() {
20:13 < bridge> <ryozuki>                     None
20:13 < bridge> <ryozuki>                 } else {
20:13 < bridge> <ryozuki>                     Some(PathSegment(s.alloc_on(self)))
20:13 < bridge> <ryozuki>                 }
20:13 < bridge> <ryozuki>             })
20:13 < bridge> <ryozuki>             .collect();
20:13 < bridge> <ryozuki> 
20:13 < bridge> <ryozuki>         Path { absolute, segments }
20:13 < bridge> <ryozuki>     }
20:13 < bridge> <ryozuki> }
20:13 < bridge> <ryozuki> ```
20:13 < bridge> <ryozuki> `Some(PathSegment(s.alloc_on(self)))`
20:13 < bridge> <ryozuki> is the key
20:13 < bridge> <ryozuki> anyway im 99% sure a block works
20:14 < bridge> <teero777> looks better thx
20:14 < bridge> <teero777> https://cdn.discordapp.com/attachments/293493549758939136/1298711071795839106/image.png?ex=671a8e70&is=67193cf0&hm=954f45ed74333ab010edf4c1951da653a1cf6d96392a0bb15de934294dfa4dd8&
20:14 < bridge> <learath2> ```rust
20:14 < bridge> <learath2> pub struct PathSegment<'ast>(pub &'ast str);
20:14 < bridge> <learath2> pub struct Path<'ast> {
20:14 < bridge> <learath2>     pub absolute: bool,
20:14 < bridge> <learath2>     pub segments: Vec<PathSegment<'ast>>,
20:14 < bridge> <learath2> }
20:14 < bridge> <learath2> ```
20:14 < bridge> <learath2> Does seem it behaves similarly though, it is not an owned type, it just refers to the ast
20:14 < bridge> <ryozuki> it calls this
20:14 < bridge> <ryozuki> ```rust
20:14 < bridge> <ryozuki> 
20:14 < bridge> <ryozuki> impl<'gcx, T: Allocatable> ArenaAllocatable<'gcx, AstCtx<'gcx>> for T
20:14 < bridge> <ryozuki> where
20:14 < bridge> <ryozuki>     T: 'gcx,
20:14 < bridge> <ryozuki> {
20:14 < bridge> <ryozuki>     type ReturnType = &'gcx T;
20:14 < bridge> <ryozuki> 
20:14 < bridge> <ryozuki>     fn alloc_on(self, ctx: &'gcx AstCtx<'gcx>) -> Self::ReturnType {
20:14 < bridge> <ryozuki>         ctx.arena.alloc(self)
20:14 < bridge> <ryozuki>     }
20:14 < bridge> <ryozuki> }
20:14 < bridge> <ryozuki> ```
20:14 < bridge> <learath2> Me too, I don't remember exactly why though, something something non lexical lifetime something something?
20:16 < bridge> <ryozuki> i guess with blocks it can make sense of lifetimes easier
20:16 < bridge> <ryozuki> but because its aided by thje block scope
20:16 < bridge> <learath2> Actually doesn't feel like a non-lexical-lifetime thing, there is no control flow here changing the length of borrows
20:17 < bridge> <ryozuki> btw the other day i learnt smth
20:17 < bridge> <learath2> I should one day sit down and actually learn all the semantics of rust borrows, the implicit lifetimes hide so much from you that you can kinda get away with learning it extremely half-assedly and still write code
20:17 < bridge> <ryozuki> ```rust
20:17 < bridge> <ryozuki> let _ = ();
20:17 < bridge> <ryozuki> _ = ();
20:17 < bridge> <ryozuki> ```
20:17 < bridge> <ryozuki> iirc both work fine
20:17 < bridge> <ryozuki> i need to confirm this again
20:17 < bridge> <ryozuki> but _ doesnt need let
20:18 < bridge> <learath2> I wonder if there is something like a flag to disable all lifetime elision
20:18 < bridge> <ryozuki> Compiling playground v0.0.1 (/playground)
20:18 < bridge> <ryozuki>     Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.56s
20:18 < bridge> <ryozuki>      Running `target/debug/playground`
20:18 < bridge> <ryozuki> yep
20:18 < bridge> <learath2> What is this even supposed to do? This is too advanced 5 me
20:18 < bridge> <ryozuki> you use _ when u want to discard a value
20:18 < bridge> <ryozuki> but u can avoid the let
20:18 < bridge> <ryozuki> i guess its because its not rly a binding
20:18 < bridge> <learath2> Ah, interesting, never seen it before
20:20 < bridge> <learath2> Apparently not, a shame, it'd be a great learning tool
20:30 < bridge> <jxsl13> @heinrich5991 you awake?
20:37 < bridge> <milkeeycat> idk wat that does but at least it decreases compile time 10x ðŸ˜¬
20:37 < bridge> <milkeeycat> idk wat that does but at least it increases compile time 10x ðŸ˜¬
20:38 < bridge> <jxsl13> maybe someone else can give some rough pointers. 
20:38 < bridge> <jxsl13> upon map change, the CClients seems to loose its state.
20:39 < bridge> <jxsl13> How does a map change work on a protocol level, dunno myself what I'm asking for ðŸ˜„
20:41 < bridge> <whitekitty> Hey I have this problem when players shoot with all weapons without gun The shot is where the cursor is pointed, but its eyes are looking up or down can someone help me fix it
20:41 < bridge> <whitekitty> https://cdn.discordapp.com/attachments/293493549758939136/1298717930338652181/image.png?ex=671a94d3&is=67194353&hm=143bada66b839c83a582894cd1290949dc77a248c32841901c1e0fceaa2b1beb&
20:45 < bridge> <learath2> Polonius is the "experimental" borrow checker, it has much more advanced lifetime analysis allowing more code to be accepted (like evaluating non-lexical lifetimes)
20:45 < bridge> <milkeeycat> then it's still not smart enough
20:45 < bridge> <learath2> Such advanced analysis comes at the cost of time ðŸ˜„
20:45 < bridge> <learath2> Did the block work?
20:45 < bridge> <milkeeycat> no
20:46 < bridge> <meloÆž> :suizid:
20:46 < bridge> <learath2> Well if the block didn't work I didn't think Polonius would help either
20:47 < bridge> <milkeeycat> should've written my compiler in C :feelsbadman:
20:47 < bridge> <whitekitty> so what can i finally do with it
20:48 < bridge> <learath2> @milkeeycat what did you mean by this? Which method were you talking about?
20:48 < bridge> <meloÆž> i think #developer is the wrong channel to ask, you're better of in #
20:48 < bridge> <meloÆž> i think #developer is the wrong channel to ask, you're better of in #bugs or #questions
20:49 < bridge> <deathgood> does anyone know how to save chat logs in the game as a txt file
20:49 < bridge> <milkeeycat> i broke a lot of other stuff but if I changed
20:49 < bridge> <milkeeycat> ```rust
20:49 < bridge> <milkeeycat> pub fn parse_path(&'ast self, path: &'_ str) -> Path<'ast> {
20:49 < bridge> <milkeeycat> ```
20:49 < bridge> <milkeeycat> to
20:49 < bridge> <milkeeycat> ```rust
20:49 < bridge> <milkeeycat> pub fn parse_path(&self, path: &'_ str) -> Path<'ast> {
20:49 < bridge> <milkeeycat> ```
20:49 < bridge> <milkeeycat> error wasn't shown
20:50 < bridge> <learath2> They are supposed to lose most state
20:50 < bridge> <jxsl13> found OnClientDataPersist
20:51 < bridge> <jxsl13> might help with I'm trying to achieve
20:51 < bridge> <learath2> Yes, that's what we use for persisting stuff past a map reload
20:51 < bridge> <jxsl13> might help with what I'm trying to achieve
20:58 < bridge> <learath2> That is most curious, I'd thinkg the elision rules would just make all those lifetimes `'ast` anyway. This is where my Rust lifetime knowledge ends, you'll have to ask @ryozuki or @heinrich5991
20:58 < bridge> <learath2> That is most curious, I'd think the elision rules would just make all those lifetimes `'ast` anyway. This is where my Rust lifetime knowledge ends, you'll have to ask @ryozuki or @heinrich5991
20:59 < bridge> <milkeeycat> C is the savior
20:59 < bridge> <milkeeycat> no lifetimes, no problems
20:59 < bridge> <learath2> Exactly, come back to the light side, no more of this "safe coding"
21:00 < bridge> <learath2> What is the point of the language being safe if the compiler won't allow you to code the thing you want?
21:00 < bridge> <milkeeycat> it's time to write the compiler in meraki, so I can do watever I want
21:00 < bridge> <meloÆž> :thisemoji:
21:01 < bridge> <milkeeycat> but why does this code work -.-
21:01 < bridge> <milkeeycat> ```rust
21:01 < bridge> <milkeeycat> use std::collections::HashSet;
21:01 < bridge> <milkeeycat> 
21:01 < bridge> <milkeeycat> struct Foo<'a> {
21:01 < bridge> <milkeeycat>     bar: HashSet<&'a str>,
21:01 < bridge> <milkeeycat> }
21:01 < bridge> <milkeeycat> 
21:01 < bridge> <milkeeycat> impl<'a> Foo<'a> {
21:01 < bridge> <milkeeycat>     fn new() -> Self {
21:01 < bridge> <milkeeycat>         Self {
21:01 < bridge> <milkeeycat>             bar: HashSet::new(),
21:01 < bridge> <milkeeycat>         }
21:01 < bridge> <milkeeycat>     }
21:01 < bridge> <milkeeycat> 
21:01 < bridge> <milkeeycat>     fn test(&'a self) -> &'a str {
21:01 < bridge> <milkeeycat>         todo!();
21:01 < bridge> <milkeeycat>     }
21:01 < bridge> <milkeeycat> }
21:01 < bridge> <milkeeycat> 
21:01 < bridge> <milkeeycat> fn main() {
21:01 < bridge> <milkeeycat>     let foo = Foo::new();
21:01 < bridge> <milkeeycat> 
21:02 < bridge> <milkeeycat>     let c = foo.test();
21:02 < bridge> <milkeeycat> 
21:02 < bridge> <milkeeycat>     std::mem::drop(foo);
21:02 < bridge> <milkeeycat> }
21:02 < bridge> <milkeeycat> ```
21:02 < bridge> <learath2> Only Allah and the 4 people on the rust core team know why that works and the other doesn't
21:02 < bridge> <learath2> Try to use c after the drop
21:03 < bridge> <learath2> Perhaps there is an early bail inside borrowck
21:03 < bridge> <milkeeycat> Ye, I can't use it after the drop
21:03 < bridge> <milkeeycat> But in that compiler code it doesn't work even if when it's before
21:04 < bridge> <learath2> Perhaps the todo you have right after? Idk how todo is implemented
21:05 < bridge> <milkeeycat> I changed to `self.bar.get("").unwrap()` and nothing changed
22:00 < bridge> <ryozuki> &'ast self and &self is completly different
22:00 < bridge> <ryozuki> the first asks for a borrow that lasts atleast 'ast
22:01 < bridge> <ryozuki> @milkeeycat where is the parse_ast method?
22:02 < bridge> <milkeeycat> idk :justatest:
22:02 < bridge> <ryozuki> oh parse_path sry i misread
22:02 < bridge> <ryozuki> tbh idk if i had the project at hand it would be easier
22:02 < bridge> <milkeeycat> i sent the link xd
22:05 < bridge> <ryozuki> thats the project that fails?
22:05 < bridge> <ryozuki> or you changed something?
22:05 < bridge> <milkeeycat> uncomment the line and you have the problem
22:05 < bridge> <ryozuki> what line
22:05 < bridge> <ryozuki> i git cloned git@github.com:alumina-lang/alumina.git
22:06 < bridge> <milkeeycat> `src/alumina-boot/src/compiler.r:263`
22:06 < bridge> <milkeeycat> `src/alumina-boot/src/compiler.rs:263`
22:07 < bridge> <jxsl13> I love c++, changed stuff around OnClientDataPersist, application crashes somewhere in db pool
22:08 < bridge> <ryozuki> ```
22:08 < bridge> <ryozuki> error[E0505]: cannot move out of `ast` because it is borrowed
22:08 < bridge> <ryozuki>    --> src/alumina-boot/src/compiler.rs:263:14
22:08 < bridge> <ryozuki>     |
22:08 < bridge> <ryozuki> 102 |             .map(|source_file| {
22:08 < bridge> <ryozuki>     |                  ------------- borrow of `ast` occurs here
22:08 < bridge> <ryozuki> ...
22:09 < bridge> <ryozuki> 112 |                 Ok((parse_tree, ast.parse_path(&source_file.path)))
22:09 < bridge> <ryozuki>     |                                 --- borrow occurs due to use in closure
22:09 < bridge> <ryozuki> ...
22:09 < bridge> <ryozuki> 263 |         drop(ast);
22:09 < bridge> <ryozuki>     |              ^^^
22:09 < bridge> <ryozuki>     |              |
22:09 < bridge> <ryozuki>     |              move out of `ast` occurs here
22:09 < bridge> <ryozuki>     |              borrow later used here
22:09 < bridge> <ryozuki> 
22:09 < bridge> <ryozuki> For more information about this error, try `rustc --explain E0505`.
22:09 < bridge> <ryozuki> error: could not compile `alumina-boot` (bin "alumina-boot") due to 1 previous error
22:09 < bridge> <ryozuki> ```
22:10 < bridge> <learath2> Really even in that context? I'd have thought elision rules would make `pub fn parse_path(&self, path: &'_ str) -> Path<'ast>` into `pub fn parse_path(&'ast self, path: &'_ str) -> Path<'ast>` anyway
22:10 < bridge> <milkeeycat> replace `compile` function body with
22:10 < bridge> <milkeeycat> ```
22:10 < bridge> <milkeeycat> let ast = AstCtx::new();
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat> ast.parse_path(&source_files[0].path);
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat> drop(ast);
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat> todo!();
22:10 < bridge> <milkeeycat> ```
22:11 < bridge> <ryozuki> you know i think the problem is
22:11 < bridge> <ryozuki> ```rust
22:11 < bridge> <ryozuki> pub struct AstCtx<'ast> {
22:11 < bridge> <ryozuki>     pub arena: Bump,
22:11 < bridge> <ryozuki>     pub counter: Cell<usize>,
22:11 < bridge> <ryozuki>     types: RefCell<HashSet<TyP<'ast>>>,
22:11 < bridge> <ryozuki>     strings: RefCell<HashSet<&'ast str>>,
22:11 < bridge> <ryozuki>     lang_items: RefCell<HashMap<Lang, ItemP<'ast>>>,
22:12 < bridge> <ryozuki>     local_names: RefCell<HashMap<Id, &'ast str>>,
22:12 < bridge> <ryozuki>     metadata: RefCell<HashMap<ItemP<'ast>, Metadatum<'ast>>>,
22:12 < bridge> <ryozuki> }
22:12 < bridge> <ryozuki> ```
22:12 < bridge> <learath2> Ah, I'm wrong, I think that would become `pub fn parse_path(&'a self, path: &'b str) -> Path<'ast>`
22:12 < bridge> <milkeeycat> RefCell
22:12 < bridge> <ryozuki> so here 'ast is a lifetime used for items allocated in the arena it has
22:12 < bridge> <ryozuki> which is odd
22:12 < bridge> <ryozuki> tbh
22:13 < bridge> <ryozuki> im trying to think this
22:13 < bridge> <milkeeycat> ```rust
22:13 < bridge> <milkeeycat> use std::cell::RefCell;
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat> struct Foo<'a> {
22:13 < bridge> <milkeeycat>     bar: RefCell<&'a str>,
22:13 < bridge> <milkeeycat> }
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat> impl<'a> Foo<'a> {
22:13 < bridge> <milkeeycat>     fn new() -> Self {
22:13 < bridge> <milkeeycat>         Self {
22:13 < bridge> <milkeeycat>             bar: RefCell::new("foo"),
22:13 < bridge> <milkeeycat>         }
22:13 < bridge> <milkeeycat>     }
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat>     fn test(&'a self) -> &'a str {
22:13 < bridge> <milkeeycat>         &self.bar.borrow()
22:13 < bridge> <milkeeycat>     }
22:13 < bridge> <milkeeycat> }
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat> fn main() {
22:13 < bridge> <milkeeycat>     let foo = Foo::new();
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat>     let c = foo.test();
22:13 < bridge> <milkeeycat> 
22:13 < bridge> <milkeeycat>     std::mem::drop(foo);
22:13 < bridge> <milkeeycat> }
22:13 < bridge> <milkeeycat> ```
22:14 < bridge> <milkeeycat> this code doesn't compile
22:14 < bridge> <ryozuki> i think u dont need &'ast self
22:14 < bridge> <learath2> The fact that you are an expert at this and it's not obvious to you is why I'm not the biggest fan of Rust ðŸ˜„
22:14 < bridge> <ryozuki> xd
22:14 < bridge> <ryozuki> well the code in the repo is more complex
22:14 < bridge> <ryozuki> than the examples here
22:14 < bridge> <ryozuki> but i think its mostly trying to store the stuff in the same struct that "allocates" it
22:14 < bridge> <jxsl13> ```
22:14 < bridge> <jxsl13> sixup: couldn't load map maps7/ctf5.map
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I sixup: disabling 0.7 compatibility
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I ddnet-insta: cleaning up database connection ...
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I ddnet-insta: connecting to database ...
22:14 < bridge> <jxsl13> DDNet-Server(35680,0x16ff13000) malloc: Corruption of tiny freelist 0x107b05370: size too small (0/7)
22:14 < bridge> <jxsl13> DDNet-Server(35680,0x16ff13000) malloc: *** set a breakpoint in malloc_error_break to debug
22:14 < bridge> <jxsl13> ```
22:14 < bridge> <jxsl13> might also be related to metrying to change my map to one map that has no 0.7 version
22:14 < bridge> <jxsl13> ddnet-insta codebase
22:14 < bridge> <jxsl13> ```
22:14 < bridge> <jxsl13> sixup: couldn't load map maps7/ctf5.map
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I sixup: disabling 0.7 compatibility
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I ddnet-insta: cleaning up database connection ...
22:14 < bridge> <jxsl13> 2024-10-23 21:59:19 I ddnet-insta: connecting to database ...
22:14 < bridge> <jxsl13> DDNet-Server(35680,0x16ff13000) malloc: Corruption of tiny freelist 0x107b05370: size too small (0/7)
22:14 < bridge> <jxsl13> DDNet-Server(35680,0x16ff13000) malloc: *** set a breakpoint in malloc_error_break to debug
22:14 < bridge> <jxsl13> ```
22:14 < bridge> <jxsl13> might also be related to me trying to change my map to one map that has no 0.7 version
22:14 < bridge> <jxsl13> ddnet-insta codebase
22:14 < bridge> <ryozuki> which is problematic in rust
22:14 < bridge> <learath2> Borrow checking and lifetimes feel like they are impossible to master
22:15 < bridge> <learath2> Unless you are dtolnay that is
22:15 < bridge> <learath2> ASan should instantly figure this out I guess
22:15 < bridge> <jxsl13> me too dumb for that ._.
22:15 < bridge> <jxsl13> please teach
22:15 < bridge> <jxsl13> got lldb to work
22:15 < bridge> <learath2> I think we have something you can copy paste in the README
22:15 < bridge> <meloÆž> get asan
22:15 < bridge> <meloÆž> get pc
22:15 < bridge> <meloÆž> boot up chatgpt
22:15 < bridge> <meloÆž> say you have problem
22:15 < bridge> <meloÆž> let computer fix computer
22:15 < bridge> <meloÆž> 
22:15 < bridge> <meloÆž> ...
22:15 < bridge> <meloÆž> profit
22:15 < bridge> <learath2> https://github.com/ddnet/ddnet?tab=readme-ov-file#using-addresssanitizer--undefinedbehavioursanitizer-or-valgrinds-memcheck
22:16 < bridge> <jxsl13> found a line
22:16 < bridge> <jxsl13> of coke
22:16 < bridge> <jxsl13> :kek:
22:16 < bridge> <jxsl13> to copy*
22:17 < bridge> <learath2> That gives you ubsan too, which is fine, even better
22:17 < bridge> <learath2> though ubsan does add a bit of slowdown
22:18 < bridge> <ryozuki> @learath2 i found something
22:18 < bridge> <ryozuki> https://users.rust-lang.org/t/lifetime-problem-and-cannot-move-out-of/99674
22:18 < bridge> <ryozuki> > foo is not trivially droppable, because foo.guard implements Drop which can have observable side effect, so the compiler will not end foo's lifetime early. your Foo wrapper type is a red herring. you get the same error if you use the MutexGuard directly: let guard = bar.mutex.lock().unwrap(); â€¦
22:19 < bridge> <ryozuki> i guess that ast is not trivially droppable (in fact it has many things non trivially in it
22:19 < bridge> <ryozuki> ok
22:19 < bridge> <ryozuki> nvm
22:19 < bridge> <ryozuki> its not this problem
22:19 < bridge> <ryozuki> xdd
22:20 < bridge> <jxsl13> is it supposed to create some dump or more output in case of a crash?
22:20 < bridge> <milkeeycat> > all their RefCell<'ast> types inside AstCtx are basically this
22:20 < bridge> <milkeeycat> > Basically, while you can make things with &'a T<'a> compile, it's not interoperable with many core rust features.
22:20 < bridge> <milkeeycat> > Theirs only works because the AstCtx is never moved to another function (either up or down the stack), which is what drop is supposed to do.
22:20 < bridge> <milkeeycat> Other rustacean's opition
22:21 < bridge> <milkeeycat> > all their RefCell<'ast> types inside AstCtx are basically this
22:21 < bridge> <milkeeycat> > Basically, while you can make things with &'a T<'a> compile, it's not interoperable with many core rust features.
22:21 < bridge> <milkeeycat> > Theirs only works because the AstCtx is never moved to another function (either up or down the stack), which is what drop is supposed to do.
22:21 < bridge> <milkeeycat> Other rustacean's opinion
22:21 < bridge> <ryozuki> yeah thats what i kind of guessed
22:21 < bridge> <ryozuki> .
22:22 < bridge> <ryozuki> .
22:22 < bridge> <ryozuki> i would refactor this in a more rusty way
22:22 < bridge> <ryozuki> imho the easy way would be to just not have the arena: Bump in the struct
22:26 < bridge> <milkeeycat> now I can finally check da stuff I was looking for in the first place xd
22:29 < bridge> <jxsl13> hm, san files
22:52 < bridge> <jxsl13> ```cpp
22:52 < bridge> <jxsl13> void CSnapshotStorage::PurgeAll()
22:52 < bridge> <jxsl13> {
22:52 < bridge> <jxsl13>     while(m_pFirst)
22:52 < bridge> <jxsl13>     {
22:52 < bridge> <jxsl13>         CHolder *pNext = m_pFirst->m_pNext;
22:52 < bridge> <jxsl13>         free(m_pFirst->m_pSnap);
22:52 < bridge> <jxsl13>         free(m_pFirst->m_pAltSnap);
22:52 < bridge> <jxsl13>         free(m_pFirst);
22:52 < bridge> <jxsl13>         m_pFirst = pNext;
22:52 < bridge> <jxsl13>     }
22:52 < bridge> <jxsl13>     m_pLast = nullptr;
22:52 < bridge> <jxsl13> }
22:52 < bridge> <jxsl13> ```
22:52 < bridge> <jxsl13> does m_pFirst also need to be reset to null after the loop?
22:53 < bridge> <jxsl13> ```
22:53 < bridge> <jxsl13> =================================================================
22:53 < bridge> <jxsl13> ==43980==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000018208 at pc 0x0001057de03c bp 0x00016b373320 sp 0x00016b373318
22:54 < bridge> <jxsl13> READ of size 8 at 0x606000018208 thread T0
22:54 < bridge> <jxsl13>     #0 0x1057de038 in CSnapshotStorage::PurgeAll() snapshot.cpp:624
22:54 < bridge> <jxsl13>     #1 0x104b3e03c in CServer::CClient::Reset() server.cpp:214
22:54 < bridge> <jxsl13>     #2 0x104badcc0 in CServer::Run() server.cpp:2897
22:54 < bridge> <jxsl13>     #3 0x104ad90e4 in main main.cpp:198
22:54 < bridge> <jxsl13>     #4 0x196a68270  (<unknown module>)
22:54 < bridge> <jxsl13> 
22:54 < bridge> <jxsl13> 0x606000018208 is located 8 bytes inside of 56-byte region [0x606000018200,0x606000018238)
22:54 < bridge> <jxsl13> freed by thread T0 here:
22:54 < bridge> <jxsl13>     #0 0x10735cd40 in free+0x98 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x54d40)
22:54 < bridge> <jxsl13>     #1 0x1057de28c in CSnapshotStorage::PurgeAll() snapshot.cpp:627
22:54 < bridge> <jxsl13>     #2 0x104beff24 in CSnapshotStorage::~CSnapshotStorage() snapshot.h:137
22:54 < bridge> <jxsl13>     #3 0x104befeac in CSnapshotStorage::~CSnapshotStorage() snapshot.h:137
22:54 < bridge> <jxsl13>     #4 0x104befe34 in CServer::CClient::~CClient() server.h:109
22:54 < bridge> <jxsl13>     #5 0x104b42ff4 in CServer::CClient::~CClient() server.h:109
22:54 < bridge> <jxsl13>     #6 0x104b51690 in CServer::gCTFState(int) const server.cpp:670
22:54 < bridge> <jxsl13>     #7 0x104e9b4e8 in CGameContext::OnClientDataPersist(int, void*) gamecontext.cpp:1681
22:54 < bridge> <jxsl13>     #8 0x104bace14 in CServer::Run() server.cpp:2878
22:54 < bridge> <jxsl13>     #9 0x104ad90e4 in main main.cpp:198
22:54 < bridge> <jxsl13>     #10 0x196a68270  (<unknown module>)
22:54 < bridge> <jxsl13> 
22:54 < bridge> <jxsl13> previously allocated by thread T0 here:
22:54 < bridge> <jxsl13>     #0 0x10735cc04 in malloc+0x94 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x54c04)
22:54 < bridge> <jxsl13>     #1 0x1057dea3c in CSnapshotStorage::Add(int, long long, unsigned long, void const*, unsigned long, void const*) snapshot.cpp:665
22:54 < bridge> <jxsl13>     #2 0x104b5b630 in CServer::DoSnapshot() server.cpp:956
22:54 < bridge> <jxsl13>     #3 0x104bb1bcc in CServer::Run() server.cpp:2989
22:54 < bridge> <jxsl13>     #4 0x104ad90e4 in main main.cpp:198
22:54 < bridge> <jxsl13>     #5 0x196a68270  (<unknown module>)
22:55 < bridge> <jxsl13> hm     #7 0x104e9b4e8 in CGameContext::OnClientDataPersist(int, void*) gamecontext.cpp:1681
22:56 < bridge> <jxsl13> I recognize stuff that I broke, lol
22:56 < bridge> <jxsl13> :kek:
23:26 < bridge> <heinrich5991> try asking the compiler instead of the language server
23:26 < bridge> <heinrich5991> the compiler might give better errors
23:27 < bridge> <heinrich5991> `drop` doesn't get rid of the variable, just of its value. the type is still there
23:28 < bridge> <heinrich5991> calling it discard is dangerous. `let _ = a;` is a no-op, it doesn't move out of `a`
23:29 < bridge> <heinrich5991> remove the `'a` from `self`
23:29 < bridge> <heinrich5991> `todo!()` is irrelevant
23:29 < bridge> <learath2> Can you help me understand why the `'a` changes things there?
23:30 < bridge> <heinrich5991> note that the lifetime parameter isn't declared at the function, it might also appears elsewhere
23:30 < bridge> <ryozuki> its a struct that owns and has reference to data it owns
23:30 < bridge> <ryozuki> so it gives problems with drop
23:30 < bridge> <heinrich5991> nah, I think I mostly understand them
23:31 < bridge> <learath2> Ok, so it's dtolnay, you and the rest of the core team ðŸ˜›
23:32 < bridge> <ryozuki> the explicit drop is a move
23:32 < bridge> <ryozuki> so thats why u cant with it
23:34 < bridge> <heinrich5991> the function signature is
23:34 < bridge> <heinrich5991> ```rs
23:34 < bridge> <heinrich5991> fn test<'a>(self: &'a Foo<'a>) -> &'a str;
23:34 < bridge> <heinrich5991> // vs
23:34 < bridge> <heinrich5991> fn test<'a, 'b>(self: &'b Foo<'a>) -> &'a str
23:34 < bridge> <heinrich5991> ```
23:34 < bridge> <heinrich5991> in the former case, the returned lifetime depends on the lifetime of the `self` reference and the inner lifetime of `Foo`
23:34 < bridge> <heinrich5991> in the latter case, it only depends on the inner lifetime of `Foo`
23:34 < bridge> <learath2> Ah the lifetime of the reference vs the inner lifetime, yeah that makes sense
23:35 < bridge> <heinrich5991> there's a bit magic involved there, too
23:35 < bridge> <heinrich5991> the rust compiler knows that it can change the inner `Foo` lifetime to shorter ones
23:36 < bridge> <learath2> So by adding the 'a there you are "accidentally" forcing the borrow to exist as long as `Foo` exists?
23:36 < bridge> <heinrich5991> because it looks into the `struct` and sees that the lifetime is used in a reference there
23:36 < bridge> <heinrich5991> you are forcing the compiler to select a shorter lifetime
23:36 < bridge> <heinrich5991> for the function
23:36 < bridge> <heinrich5991> namely the shorter one of the inner lifetime and the `self` reference
23:36 < bridge> <heinrich5991> which is always going to be the lifetime of the `self` reference
23:37 < bridge> <ryozuki> :poggers2:
23:37 < bridge> <heinrich5991> so now the returned string has the lifetime of the `self` reference
23:38 < bridge> <ryozuki> i guess im no expert
23:38 < bridge> <ryozuki> im a rust nobo <a:sadSnail:785072987815804929>
23:38 < bridge> <learath2> So you can't drop the reference, since the returned strings lifetime would have to end there but it doesn't
23:38 < bridge> <ryozuki> i wonder if its that, or that u simply cant move the object
23:39 < bridge> <ryozuki> because of the reference lifetimes
23:39 < bridge> <ryozuki> drop needs a move but the implicit drop doesnt i think
23:39 < bridge> <learath2> I still maintain my position that Rust (especially the borrow checker) is very resistant to mastery. Lifetime elision makes things sooo opaque that most people just never have to understand it at all, then they suddenly hit a brick wall
23:39 < bridge> <ryozuki> so its more a question of being able to "move" it or not
23:39 < bridge> <ryozuki> not about dropping
23:39 < bridge> <heinrich5991> yes
23:40 < bridge> <learath2> Well a drop is a move, no?
23:40 < bridge> <ryozuki> the explicit drop call is
23:40 < bridge> <ryozuki> drop()
23:40 < bridge> <ryozuki> a implicit drop doesnt need to move it just deallocs in place no?
23:40 < bridge> <ryozuki> thats my understanding
23:40 < bridge> <ryozuki> idk
23:40 < bridge> <heinrich5991> the problem is AFAIK that the variable exists beyond the drop
23:40 < bridge> <heinrich5991> after the block ends, the variable is no longer there
23:41 < bridge> <heinrich5991> it's just the instance that you `drop`
23:41 < bridge> <ryozuki> well, u mostly hit this stuff with self referential stuff
23:42 < bridge> <learath2> If you were forced to write the lifetimes all the time you'd have a better understanding of them by the time you get to the weird stuff ðŸ˜„
23:42 < bridge> <ryozuki> idk, i code rust daily at work and i rarely hit issues like this
23:42 < bridge> <ryozuki> and i dont do simple stuff
23:42 < bridge> <ryozuki> idk it would be lot of work
23:43 < bridge> <heinrich5991> I guess I was forced to learn with a stricter borrow checker
23:43 < bridge> <learath2> You were there before 1.0?
23:43 < bridge> <heinrich5991> people say it's become more complicated to teach the borrow checker since it got relaxed. because the easy examples simply compile nowadays
23:44 < bridge> <heinrich5991> yes, but the borrow checker also got laxer after 1.0
23:44 < bridge> <learath2> I meant as like an option to disable it completely
23:44 < bridge> <learath2> I would totally disable it for a couple months to learn better
23:44 < bridge> <ryozuki> https://doc.rust-lang.org/nomicon/dropck.html
23:45 < bridge> <heinrich5991> I recently noticed that I can claim 10 years of rust experience ðŸ˜„
23:45 < bridge> <ryozuki> damn
23:45 < bridge> <ryozuki> i started on 2018
23:45 < bridge> <ryozuki> 4 years i guess
23:46 < bridge> <heinrich5991> matricks was at least among the people who got me into rust
23:48 < bridge> <inv41idu53rn4m3> I have still yet to convince myself to start trying to use Rust
23:48 < bridge> <inv41idu53rn4m3> it's a damn cult I tell ya
23:48 < bridge> <inv41idu53rn4m3> something fishy about those guys
23:48 < bridge> <ryozuki> just do it
23:48 < bridge> <ryozuki> u will learn something
23:48 < bridge> <ryozuki> even if u dont like it or use it
23:49 < bridge> <ryozuki> and nothing bad comes from leanring more languages
23:49 < bridge> <inv41idu53rn4m3> We should write more Haskell
23:49 < bridge> <ryozuki> im learning ocaml now
23:49 < bridge> <ryozuki> and nothing bad comes from learning more languages
23:49 < bridge> <learath2> The functional people are the real cult ðŸ˜„
23:49 < bridge> <ryozuki> @learath2 honestly, functiona llangs have nice stuff
23:49 < bridge> <ryozuki> like partial application
23:49 < bridge> <learath2> God forbid I mutate a variable
23:50 < bridge> <ryozuki> https://en.wikipedia.org/wiki/Partial_application
23:50 < bridge> <heinrich5991> did you see that rust is making the libcs make `exit` thread-safe? ^^
23:50 < bridge> <learath2> How can exit become thread-safe even?
23:51 < bridge> <ryozuki> epic win
23:51 < bridge> <inv41idu53rn4m3> I enjoy writing pointless code
23:51 < bridge> <heinrich5991> did you know that calling `exit` on two different threads is instant UB in C? ^^
23:51 < bridge> <inv41idu53rn4m3> point free programming my beloved
23:51 < bridge> <learath2> I did
23:52 < bridge> <heinrich5991> I did not and found it insane. but that's probably changing in the future
23:52 < bridge> <heinrich5991> i.e. `exit` will likely become threadsafe in the future
23:52 < bridge> <learath2> I also thought it was unfixable though
23:52 < bridge> <inv41idu53rn4m3> Isn't it only natural that you can't exit more than once?
23:52 < bridge> <heinrich5991> just take a lock at the start of the `exit` impl
23:53 < bridge> <heinrich5991> and never drop it
23:53 < bridge> <learath2> Oh, just bolting on a lock, yeah I guess you can make it thread-safe like that
23:53 < bridge> <ryozuki> did you know ocaml functions only take 1 argument
23:53 < bridge> <jxsl13> hm, seemingly when switching from a 0.6 only map to a map that has a 0.6 and 0.7 version, sixup is not enabled again
23:54 < bridge> <heinrich5991> (in fact, glibc is taking a lock at the start of the `exit` impl, but dropping it under certain circumstances later on. meaning that `exit` was usually threadsafe in glibc, but not always)
23:55 < bridge> <heinrich5991> if you want to be more performant, you can do an atomic compare-and-exchange
23:55 < bridge> <jxsl13> ChillerDragon ðŸ˜®
23:55 < bridge> <learath2> Hm, if the solution is holding a lock, can't rust provide it's own exit that does it properly? Why is libc changing it?
23:55 < bridge> <robyt3> See #7669
23:55 < bridge> <DDNet> https://github.com/ddnet/ddnet/issues/7669
23:55 < bridge> <learath2> (I mean, it's fine, should be nice that libc also fixes it, just wondering why it's being done on that side)
23:56 < bridge> <heinrich5991> because rust tries to interoperate with the world. you can't make it safe to `exit` if not everyone takes the same lock
23:56 < bridge> <learath2> As in the ffi case or if someone bypasses the rust wrapper?
23:56 < bridge> <heinrich5991> e.g. python calling `sys.exit` concurrently with a rust library calling `std::process::exit` should ideally not be UB
23:57 < bridge> <heinrich5991> if a rust library is called from python, for example
