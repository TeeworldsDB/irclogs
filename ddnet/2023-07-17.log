06:17 < bridge_> <Ewan> i am a huge fan of how transparent they are
06:49 < bridge_> <TsFreddie> i just switched to zoho :justatest:
10:15 < bridge_> <fokkonaut> Hah
10:16 < bridge_> <fokkonaut> Its nothint Special
10:30 < bridge_> <cyberFighter> u
10:38 < ChillerDragon> jopsti can you belive it i cant game during a zoom call w out fps drops
10:38 < ChillerDragon> i need better hardware
10:39 < bridge_> <cyberFighter> or just... DONT CONNECT 4 DUMMIES!!!
10:40 < ChillerDragon> ._. im just using 1 client
10:41 < ChillerDragon> https://zillyhuhn.com/cs/.1689583295.png
10:41 < ChillerDragon> i dont even max out
10:41 < ChillerDragon> how do computers work
10:42 < ChillerDragon> heat throtle?
10:42 < bridge_> <Jupstar ‚ú™> Try open box xd
10:42 < ChillerDragon> trol
10:42 < ChillerDragon> i need my gnome pro
10:42 < ws-client> <Jupstar> i tested openbox lately and had a lag
10:43 < ws-client> <Jupstar> since then its clear to me
10:43 < ws-client> <Jupstar> i have to use terminal only
10:43 < ws-client> <Jupstar> rip
10:43 < ChillerDragon> +1
10:43 < ws-client> <Jupstar> sad that wayland is still broken
10:43 < ws-client> <Jupstar> its faster
10:43 < ChillerDragon> https://www.youtube.com/watch?v=D0tpwp2QN6A
10:43 < ws-client> <Jupstar> maybe no more lags with it
10:43 < ChillerDragon> this best tw client
10:56 < ws-client> <Jupstar> chillerdragon: what client did u use to have the zoom call? browser, native(aka browser over electron xdd)?
12:27 < bridge_> <deen> Cool, didn't know https://github.com/Syllo/nvtop
12:28 < bridge_> <ryozuki> ye i mentioned it to chiller
12:28 < bridge_> <deen> Doesn't work for Apple GPUs, too bad üòÑ
12:28 < bridge_> <ryozuki> f
12:29 < bridge_> <deen> Might be Linux-only anyway
12:29 < bridge_> <chillerdragon> Browser
12:29 < bridge_> <chillerdragon> (<@749222324980416602_ws-client>)
12:31 < ws-client> <Jupstar> chillerdragon: cristal clear, firefox issue
12:31 < ws-client> <Jupstar> xd
12:32 < ws-client> <Jupstar> "Nvtop stands for Neat Videocard TOP". LMAO
12:34 < ws-client> <Jupstar> radeontop is still better for amd enjoyers i guess, bcs more detailed
13:16 < bridge_> <ryozuki> @jupeyy_keks :justatest:
13:32 < bridge_> <Jupstar ‚ú™> @robyt3 did smth change recently. Second time I saw this lately
13:35 < bridge_> <robyt3> Looks like it's related to tee rendering in kill messages, see decoded crash dump I posted in the issue
13:37 < bridge_> <taylor_smith> Do you know that you can earn $5,000 or more weekly from crypto Trading? With Just $500‚Ä¶ 100% Inbox Admin on Telegram for more details üëáüëáüëáüëáüëáüëá https://t.me/PROFITSWITHSTEVE
13:42 < bridge_> <Jupstar ‚ú™> Pls send the crash logs. 
13:42 < bridge_> <Jupstar ‚ú™> 
13:42 < bridge_> <Jupstar ‚ú™> @robyt3 it must be a recent change i guess.
13:50 < ws-client> <Jupstar> @murpi can u also share the assert log, it might say if some image could not be loaded or similar
13:52 < bridge_> <murpi> Jupstar: There's this in the assert log:
13:52 < bridge_> <murpi> `2023-07-17 18:04:47 I libpng: warning for file "skins/glow_preamy.png": iCCP: known incorrect sRGB profile`
13:52 < bridge_> <murpi> That's about it, the rest is just chat messages
13:52 < ws-client> <Jupstar> that shouldnt matter. Ok
13:56 < bridge_> <learath2> It might be time to work on some classic spam prevention algorithms
13:57 < bridge_> <ryozuki> https://en.wikipedia.org/wiki/Bag-of-words_model
14:28 < ws-client> <Jupstar> @murpi do you remember if you were in a started + unlocked team xd
14:30 < bridge_> <murpi> That's not my crash, I'll ask.
14:31 < ws-client> <Jupstar> maybe the info might not help anyway. the question would be rather if any tee on the server was in a strated + unlocked team
14:31 < ws-client> <Jupstar> maybe they can recover whats left from the autodemo
14:41 < bridge_> <murpi> He says the crash happened after they finished a map in a team.
14:42 < ws-client> <Jupstar> so quite possible, esp on ddmax where teams are often killed after finish
14:43 < ChillerDragon> omg watfak
14:43 < ChillerDragon> i have fps cap at 666
14:43 < ChillerDragon> and it bugs up to 1000 fps xxxd but feels like 3
14:43 < ChillerDragon> zoom is fakin virus
14:43 < ws-client> <Jupstar> it doesnt bug to 1000
14:44 < ChillerDragon> ok it features up to 1000
14:44 < ws-client> <Jupstar> it probably has a bad frame, and tries to stabilize that frame
14:44 < ws-client> <Jupstar> how do you cap fps?
14:44 < ChillerDragon> gfx moment
14:44 < ws-client> <Jupstar> with cl_refresh_rate?
14:44 < ChillerDragon> na dat 0
14:44 < ChillerDragon> gfx rate
14:45 < ws-client> <Jupstar> yeah then i guess its not actually at 1000 fps.. 
14:45 < ws-client> <Jupstar> at least not longer than like 1000/60 ms
14:46 < ws-client> <Jupstar> someone good with client network code?
14:46 < ws-client> <Jupstar> i wonder if `m_RenderInfo` in the client array in gameclient ever gets cleared
14:47 < ws-client> <Jupstar> // clear out unneeded client data 	for(int i = 0; i < MAX_CLIENTS; ++i) 	{ 		if(!m_Snap.m_apPlayerInfos[i] && m_aClients[i].m_Active) 		{ 			m_aClients[i].Reset(); 			m_aStats[i].Reset(); 		} 	}
14:47 < ws-client> <Jupstar> irc moment
14:47 < ChillerDragon> lol
14:47 < ws-client> <Jupstar> chillerdragon: when multiline
14:47 < ChillerDragon> soon(tm)
14:47 < ChillerDragon> first gotta fix 0.7 axaxax
14:48 < ws-client> <Jupstar> that just adds even more bugs to our bad af code
14:48 < ws-client> <Jupstar> robyte fixes 20000000000000 bugs per day. still we never have fewer bugs
14:48 < ws-client> <Jupstar> xdd
14:48 < ChillerDragon> more bugs?
14:48 < ws-client> <Jupstar> i dunno
14:48 < ws-client> <Jupstar> i guess it stays the same
14:48 < ChillerDragon> the still doesnt make sense
14:49 < ws-client> <Jupstar> well he fixes a bug and unhides a hidden one
14:49 < ws-client> <Jupstar> from 2 million years ago
14:49 < ws-client> <Jupstar> when the dinosours played ddnet
14:55 < ChillerDragon> xd
14:58 < bridge_> <smetanolub> idk how
14:59 < bridge_> <murpi> You can find your crash logs in %appdata%\DDNet\dumps or %appdata%\Teeworlds\dumps
14:59 < bridge_> <murpi> Paste the files into this channel
15:01 < bridge_> <smetanolub> https://cdn.discordapp.com/attachments/293493549758939136/1130484426992779294/DDNet_win64_crash_log_2023-07-15_22-42-44_8432_29ec71ad337d3e48730ac45023dc427c8af4f173.RTP
15:02 < bridge_> <Jupstar ‚ú™> Thanks üëç
17:18 < bridge_> <warner6439> it there a way to switch to ddnet's auth system in the rcon? make it ask for a username with the password
17:22 < bridge_> <fokkonaut> there is a netmsg for that, yes
17:34 < bridge_> <robyt3> Yes, it will be used once you add the first user/password pair (see `auth_*` commands)
17:51 < bridge_> <learath2> @ryozuki can you send the rust memory cheatsheet again?
17:52 < bridge_> <ryozuki> u can google it xd
17:52 < bridge_> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1130527425810419742/rust-memory-container-cs-3840x2160-dark-back-low-contrast.png
17:52 < bridge_> <learath2> Smart
17:52 < bridge_> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1130527482391568415/rust-memory-container-cs-1920x1080-dark-back-high-contrast.png
17:53 < bridge_> <ryozuki> @learath2 u missing #off-topic
17:54 < bridge_> <learath2> I'm too busy having trouble deciding on a design
17:54 < bridge_> <ryozuki> xd
17:54 < bridge_> <ryozuki> what u doin
17:54 < bridge_> <learath2> For some reason nothing I make looks good to me this week
17:55 < bridge_> <learath2> I want to finally replace the python bot completely
17:55 < bridge_> <ryozuki> nice
17:55 < bridge_> <ryozuki> @learath2 i think u tend to overcomplicate
17:55 < bridge_> <ryozuki> or over engineer
17:55 < bridge_> <ryozuki> do the simplest route to the result
17:55 < bridge_> <ryozuki> and then expand
17:55 < bridge_> <ryozuki> for example the Any db
17:55 < bridge_> <ryozuki> just choose 1 fixed
17:56 < bridge_> <learath2> But idk I really want per module context without passing it around with all the other context :/
17:56 < bridge_> <ryozuki> but u wont finish this this week then :/
17:56 < bridge_> <ryozuki> also if u just arc it its a cheap copy
17:56 < bridge_> <ryozuki> clone*
17:56 < bridge_> <learath2> If I can find something that looks good to me I can produce code really fast
17:56 < bridge_> <learath2> but I just write stuff, it doesn't look very good, I just start again üòÑ
17:56 < bridge_> <ryozuki> xd
17:57 < bridge_> <ryozuki> and u have nothing to show
17:57 < bridge_> <ryozuki> :justatest:
17:57 < bridge_> <learath2> Like an Arc with three RwLocks in it is eeeeeeeeh
17:57 < bridge_> <ryozuki> its ok
17:57 < bridge_> <learath2> Even needing a lock for this is also very eeeeeeeeh anyway, I technically write most of this just once, after one memory fence it'll be the same everywhere
17:57 < bridge_> <ryozuki> once cell then
17:58 < bridge_> <ryozuki> or simply init it before putting it in the contex
17:58 < bridge_> <ryozuki> context
17:58 < bridge_> <learath2> You are right though, maybe I should just power through with the RwLock and I can clean it up after I have something working
17:58 < bridge_> <ryozuki> yeah
17:58 < bridge_> <ryozuki> and u probs wont have  perf problems anyway
17:58 < bridge_> <learath2> No but it'll forever annoy me that I didn't write it properly
17:59 < bridge_> <ryozuki> but if u have so much trouble finding the proper way
17:59 < bridge_> <learath2> 5 years later I'll wake up in cold sweats
17:59 < bridge_> <ryozuki> maybe there isnt? a proper your way
17:59 < bridge_> <ryozuki> u need to protect the data, u use locks
17:59 < bridge_> <ryozuki> or make non racy hardware kek
18:00 < bridge_> <ryozuki> @learath2 maybe u can look at axum
18:00 < bridge_> <ryozuki> it has type checked state
18:00 < bridge_> <ryozuki> https://docs.rs/axum/latest/axum/extract/struct.State.html
18:00 < bridge_> <ryozuki> its awesome
18:01 < bridge_> <ryozuki> https://docs.rs/axum/latest/axum/index.html#sharing-state-with-handlers
18:01 < bridge_> <learath2> `let mut lock = ctx.modules.write().await.unwrap().database.write().await;`
18:01 < bridge_> <learath2> This looks horrendous
18:01 < bridge_> <ryozuki> why is modules behind a lock?
18:01 < bridge_> <ryozuki> and im sure it can be read()
18:01 < bridge_> <ryozuki> locks use interior mutabiity
18:02 < bridge_> <ryozuki> they dotn need to be mut self
18:02 < bridge_> <learath2> Ah yes, that one can be read()
18:02 < bridge_> <ryozuki> is the code somewhere
18:02 < bridge_> <learath2> Not yet, as it currently does nothing
18:03 < bridge_> <ryozuki> why not simply ctx.database.write()
18:03 < bridge_> <learath2> but I guess I could push it, maybe you have some structural idea
18:03 < bridge_> <ryozuki> also if u use sqlx
18:03 < bridge_> <learath2> You write more Rust
18:03 < bridge_> <ryozuki> the database handle is already thread safe
18:03 < bridge_> <ryozuki> well if u use a pool it is
18:04 < bridge_> <ryozuki> ye, for me its always harder to interpret what others says than looking at code
18:04 < bridge_> <ryozuki> code never lies
18:06 < bridge_> <ryozuki> @learath2 i thought about smallvec in cpp, in rust thanks to enum optimizations it will probs find a way to put the heap vec ptrs inside the stack allocated array
18:06 < bridge_> <ryozuki> but on cpp?
18:06 < bridge_> <ryozuki> a union?
18:06 < bridge_> <ryozuki> rly unsafe
18:07 < bridge_> <ryozuki> @learath2 i thought about smallvec in cpp, in rust thanks to enum optimizations it will probs find a way to put the heap vec ptrs inside the stack allocated array when using the vec variant
18:09 < bridge_> <learath2> https://github.com/Learath2/ddnet-discordbot-ng it's just me messing around with structure trying to find something I like
18:09 < bridge_> <learath2> The goals are to be able to add `modules` easily
18:09 < bridge_> <ryozuki> what does a module do
18:10 < bridge_> <learath2> It can be anything really, it's like a `CComponent` it has hooks that the main will call into as needed
18:11 < bridge_> <ryozuki> this looks like the perfect job for a trait
18:12 < bridge_> <learath2> Yeah, sounds like a good idea, I might do that
18:13 < bridge_> <learath2> Each module can add stuff to the config and stuff to the context, that's the part I'm mostly trying to figure out now
18:13 < bridge_> <ryozuki> dont but the db behind a lock
18:13 < bridge_> <ryozuki> use the type system in ur favour
18:13 < bridge_> <ryozuki> rust will let u know when u need a lock trust me xd
18:13 < bridge_> <ryozuki> sqlitepool is thread safe  from sqlx
18:14 < bridge_> <learath2> I was trying to keep it symmetric
18:14 < bridge_> <ryozuki> and yeah u have a structure that fits traits i think
18:16 < bridge_> <learath2> Are async traits even a thing btw?
18:16 < bridge_> <ryozuki> soon tm
18:16 < bridge_> <ryozuki> for now use async_trait
18:16 < bridge_> <learath2> They didn't use to be last I gave this an attempt
18:16 < bridge_> <ryozuki> ```rust
18:16 < bridge_> <ryozuki> 
18:16 < bridge_> <ryozuki> #[async_trait::async_trait]
18:16 < bridge_> <ryozuki> pub trait Module {
18:17 < bridge_> <ryozuki>     async fn init(ctx: Arc<BotContext>);
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn register_commands();
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn handle_interaction(interaction: &Interaction);
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn handle_message(message: &Message);
18:17 < bridge_> <ryozuki> }
18:17 < bridge_> <ryozuki> ```
18:17 < bridge_> <ryozuki> u dont need to pass BotContext on all calls
18:17 < bridge_> <ryozuki> simply save it on self
18:17 < bridge_> <ryozuki> well i missed self there xd
18:17 < bridge_> <ryozuki> ```rust
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki> #[async_trait::async_trait]
18:17 < bridge_> <ryozuki> pub trait Module {
18:17 < bridge_> <ryozuki>     async fn init(&self, ctx: Arc<BotContext>);
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn register_commands(&self);
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn handle_interaction(&self, interaction: &Interaction);
18:17 < bridge_> <ryozuki> 
18:17 < bridge_> <ryozuki>     async fn handle_message(&self, message: &Message);
18:17 < bridge_> <ryozuki> }
18:17 < bridge_> <ryozuki> ```
18:17 < bridge_> <learath2> Yeah, there was no self in this initial attempt, I guess that's a good idea, make modules actual objects
18:18 < bridge_> <ryozuki> btw self can be : 
18:18 < bridge_> <ryozuki> ```
18:18 < bridge_> <ryozuki> &self
18:18 < bridge_> <ryozuki> &mut self
18:18 < bridge_> <ryozuki> Pin<&mut self>
18:18 < bridge_> <ryozuki> Pin<&self>
18:18 < bridge_> <ryozuki> ```
18:18 < bridge_> <learath2> Good ideas, let me give it another go
18:18 < bridge_> <learath2> This will be about the 5th time I've rewritten up to this point üòÑ
18:18 < bridge_> <ryozuki> u can also make the trait generic if u need more
18:18 < bridge_> <ryozuki> xd
18:18 < bridge_> <ryozuki> anmd honestly
18:19 < bridge_> <ryozuki> i wouldnt put the database as a module
18:19 < bridge_> <ryozuki> i would put it part of bot context
18:19 < bridge_> <ryozuki> and modules use the database
18:19 < bridge_> <ryozuki> modules would be then a vec of objects implementing the module trait
18:19 < bridge_> <ryozuki> without a lock
18:19 < bridge_> <ryozuki> the locks are inside the objects
18:19 < bridge_> <ryozuki> isnt it better to lock less scope
18:20 < bridge_> <learath2> Yeah not the worst idea, it'd also take care of the weird asymmetry
18:20 < bridge_> <ryozuki> @learath2 btw u may be able to forego the option
18:20 < bridge_> <ryozuki> in rust u can partially initialize a struct
18:20 < bridge_> <ryozuki> pub database: Option<database::Context>,
18:20 < bridge_> <ryozuki>     pub ddnet_bans: Option<ddnet_bans::Context>,
18:20 < bridge_> <ryozuki> i mean this
18:20 < bridge_> <ryozuki> idk why its a option
18:20 < bridge_> <ryozuki> just make it always be there? xd
18:21 < bridge_> <ryozuki> ah well
18:21 < bridge_> <ryozuki> u solve this problem using a vec of modules
18:21 < bridge_> <ryozuki> simply dont care about them specifically
18:21 < bridge_> <ryozuki> then implement ur full blown ipc between modules, and reach mars
18:21 < bridge_> <learath2> Ah this part is actually a bit of an issue, with this new vec of modules I now don't really have an easy way to generate the config struct
18:22 < bridge_> <ryozuki> @learath2 make a trait
18:22 < bridge_> <ryozuki> or part of trait
18:22 < bridge_> <ryozuki> that returns the needed config for a module
18:22 < bridge_> <ryozuki> hmm
18:23 < bridge_> <ryozuki> u make a global config
18:23 < bridge_> <ryozuki> it has the modules name , module_name: T
18:23 < bridge_> <ryozuki> where T is simply deserialize
18:23 < bridge_> <learath2> Types aren't first class so I can't return them, but maybe an associated type?
18:23 < bridge_> <ryozuki> u pass T to the trait method
18:23 < bridge_> <ryozuki> there is first class
18:23 < bridge_> <ryozuki> depending o nwhat u using
18:23 < bridge_> <ryozuki> is it json?
18:23 < bridge_> <ryozuki> serde_json::Value
18:23 < bridge_> <learath2> toml
18:23 < bridge_> <ryozuki> deserializes anything
18:24 < bridge_> <ryozuki> and u can get T from Value
18:24 < bridge_> <learath2> But that's not what I meant, I mean the global config struct, I need to somehow be able to generate it
18:24 < bridge_> <ryozuki> :justatest:
18:24 < bridge_> <learath2> Currently it's just `modules: ModuleConfig`, and `ModuleConfig` is just a struct of the configs from each module
18:25 < bridge_> <ryozuki> hmm
18:25 < bridge_> <ryozuki> each module should be a toml table
18:25 < bridge_> <ryozuki> vec of Table(Table)?
18:25 < bridge_> <ryozuki> u deserialize that to the T provided by the module trait
18:26 < bridge_> <learath2> I think we are losing eachother again, let me code it up a bit then I can show more then we can talk more
18:29 < bridge_> <ryozuki> ```rust
18:29 < bridge_> <ryozuki> #[derive(Deserialize, Debug)]
18:29 < bridge_> <ryozuki> pub struct Config2 {
18:29 < bridge_> <ryozuki>     pub modules: Vec<toml::Table>,
18:29 < bridge_> <ryozuki> }
18:29 < bridge_> <ryozuki> 
18:29 < bridge_> <ryozuki> #[derive(Deserialize, Debug)]
18:29 < bridge_> <ryozuki> pub struct RyoModule {
18:29 < bridge_> <ryozuki>     pub hello: String,
18:29 < bridge_> <ryozuki> }
18:29 < bridge_> <ryozuki> 
18:29 < bridge_> <ryozuki> pub fn parse_config2(path: &Path) -> anyhow::Result<Config2> {
18:29 < bridge_> <ryozuki>     let mut file = File::open(path)?;
18:29 < bridge_> <ryozuki>     let mut file_contents = String::new();
18:29 < bridge_> <ryozuki>     file.read_to_string(&mut file_contents)?;
18:29 < bridge_> <ryozuki> 
18:29 < bridge_> <ryozuki>     Ok(toml::from_str(&file_contents)?)
18:29 < bridge_> <ryozuki> }
18:30 < bridge_> <ryozuki> 
18:30 < bridge_> <ryozuki> pub fn parse_config_from_module(config: &toml::Table) -> anyhow::Result<RyoModule> {
18:30 < bridge_> <ryozuki>     Ok(RyoModule::deserialize(config["ryo"].clone())?)
18:30 < bridge_> <ryozuki> }
18:30 < bridge_> <ryozuki> ```
18:30 < bridge_> <ryozuki> @learath2
18:30 < bridge_> <ryozuki> wait
18:30 < bridge_> <ryozuki> ```rust
18:30 < bridge_> <ryozuki> #[derive(Deserialize, Debug)]
18:30 < bridge_> <ryozuki> pub struct Config2 {
18:30 < bridge_> <ryozuki>     pub modules: toml::Table,
18:30 < bridge_> <ryozuki> }
18:30 < bridge_> <ryozuki> 
18:30 < bridge_> <ryozuki> #[derive(Deserialize, Debug)]
18:30 < bridge_> <ryozuki> pub struct RyoModule {
18:30 < bridge_> <ryozuki>     pub hello: String,
18:30 < bridge_> <ryozuki> }
18:30 < bridge_> <ryozuki> 
18:30 < bridge_> <ryozuki> pub fn parse_config2(path: &Path) -> anyhow::Result<Config2> {
18:30 < bridge_> <ryozuki>     let mut file = File::open(path)?;
18:30 < bridge_> <ryozuki>     let mut file_contents = String::new();
18:30 < bridge_> <ryozuki>     file.read_to_string(&mut file_contents)?;
18:30 < bridge_> <ryozuki> 
18:30 < bridge_> <ryozuki>     Ok(toml::from_str(&file_contents)?)
18:30 < bridge_> <ryozuki> }
18:30 < bridge_> <ryozuki> 
18:30 < bridge_> <ryozuki> pub fn parse_config_from_module(config: &toml::Table) -> anyhow::Result<RyoModule> {
18:30 < bridge_> <ryozuki>     Ok(RyoModule::deserialize(config["ryo"].clone())?)
18:30 < bridge_> <ryozuki> }
18:31 < bridge_> <ryozuki> ```
18:31 < bridge_> <ryozuki> now
18:31 < bridge_> <ryozuki> u dont need a vec
18:31 < bridge_> <ryozuki> just table
18:31 < bridge_> <ryozuki> xd
18:31 < bridge_> <_voxeldoesart> Ok()
18:31 < bridge_> <ryozuki> i think its a table
18:31 < bridge_> <ryozuki> idk toml rn
18:31 < bridge_> <ryozuki> but u get the idea
18:31 < bridge_> <_voxeldoesart> 100 years ago this would have no meaning
18:38 < bridge_> <ryozuki> learath dieded
18:41 < bridge_> <learath2> How?
18:43 < bridge_> <ryozuki> with unsafe
18:43 < bridge_> <ryozuki> https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field
18:43 < bridge_> <ryozuki> ```rust
18:43 < bridge_> <ryozuki> #[derive(Debug, PartialEq)]
18:43 < bridge_> <ryozuki> pub struct Foo {
18:43 < bridge_> <ryozuki>     name: String,
18:43 < bridge_> <ryozuki>     list: Vec<u8>,
18:43 < bridge_> <ryozuki> }
18:43 < bridge_> <ryozuki> 
18:43 < bridge_> <ryozuki> let foo = {
18:43 < bridge_> <ryozuki>     let mut uninit: MaybeUninit<Foo> = MaybeUninit::uninit();
18:43 < bridge_> <ryozuki>     let ptr = uninit.as_mut_ptr();
18:43 < bridge_> <ryozuki> 
18:43 < bridge_> <ryozuki>     // Initializing the `name` field
18:43 < bridge_> <ryozuki>     // Using `write` instead of assignment via `=` to not call `drop` on the
18:43 < bridge_> <ryozuki>     // old, uninitialized value.
18:43 < bridge_> <ryozuki>     unsafe { addr_of_mut!((*ptr).name).write("Bob".to_string()); }
18:43 < bridge_> <ryozuki> 
18:43 < bridge_> <ryozuki>     // Initializing the `list` field
18:43 < bridge_> <ryozuki>     // If there is a panic here, then the `String` in the `name` field leaks.
18:43 < bridge_> <ryozuki>     unsafe { addr_of_mut!((*ptr).list).write(vec![0, 1, 2]); }
18:43 < bridge_> <ryozuki> 
18:43 < bridge_> <ryozuki>     // All the fields are initialized, so we call `assume_init` to get an initialized Foo.
18:43 < bridge_> <ryozuki>     unsafe { uninit.assume_init() }
18:43 < bridge_> <ryozuki> };
18:43 < bridge_> <ryozuki> ```
19:04 < bridge_> <Jupstar ‚ú™> OH YEAH MILESTONE HIT
19:04 < bridge_> <Jupstar ‚ú™> 500 issues
19:04 < bridge_> <Jupstar ‚ú™> epic
19:05 < bridge_> <Jupstar ‚ú™> @ryozuki gz to us, we at least tried to prevent this dark milestone from happening xd
19:06 < bridge_> <ryozuki> xddd
19:08 < bridge_> <Jupstar ‚ú™> https://github.com/ddnet/ddnet/issues/4001#issuecomment-1638541682
19:08 < bridge_> <Jupstar ‚ú™> 
19:08 < bridge_> <Jupstar ‚ú™> üò¨
19:09 < bridge_> <Jupstar ‚ú™> next milestone is 600
19:21 < bridge_> <Jupstar ‚ú™> robyte destroyed the milestone
19:21 < bridge_> <Jupstar ‚ú™> üò¨
19:25 < bridge_> <robyt3> 373 "relevant" issues
19:26 < bridge_> <Jupstar ‚ú™> we really need better ways to reproduce issues
19:45 < bridge_> <learath2> @ryozuki why do you think `&toml::Value` can't be deserialized from? I can clone just fine, just interested why it can't borrow
19:46 < bridge_> <ryozuki> @learath2 idk why rn
19:46 < bridge_> <ryozuki> deserialize stuff?
19:46 < bridge_> <ryozuki> maybe it only implements deserializeowned or smth
19:48 < bridge_> <_voxeldoesart> is it me or are old prs like #2754 doing infinitely long checks
19:48 < bridge_> <DDNet> https://github.com/ddnet/ddnet/pull/2754
19:51 < bridge_> <Jupstar ‚ú™> the timed out eventually
19:51 < bridge_> <Jupstar ‚ú™> i dont think they still use any resources
19:51 < bridge_> <Jupstar ‚ú™> they probably simply have a "pending" state and the client parses that and shows a yellow circle
19:52 < bridge_> <Jupstar ‚ú™> they timed out eventually
19:54 < bridge_> <_voxeldoesart> ah
20:22 < bridge_> <learath2> I never really looked into the internals of serde, when I derive `Deserialize` I wonder what that implements
20:26 < bridge_> <ryozuki> serde is dtolnay grand creation
20:26 < bridge_> <ryozuki> https://docs.rs/serde/latest/serde/de/trait.DeserializeOwned.html
20:26 < bridge_> <ryozuki> https://serde.rs/lifetimes.html
20:27 < bridge_> <ryozuki> https://tweaked.cc/
20:28 < bridge_> <ryozuki> this is the best minecraft mod
20:28 < bridge_> <ryozuki> sadly its lua
20:28 < bridge_> <ryozuki> i wonder if this can be made with rust
20:28 < bridge_> <derp5211> what does this do?
20:29 < bridge_> <learath2> @ryozuki serde does zero copy deserialization, right? How can I get copy deserialization? üòÑ
20:29 < bridge_> <ryozuki> lifetimes
20:29 < bridge_> <ryozuki> &str
20:30 < bridge_> <ryozuki> but u rly wanna complicate it
20:30 < bridge_> <ryozuki> when u dont even have a solid design first
20:30 < bridge_> <ryozuki> üò¨
20:30 < bridge_> <learath2> I'm an advocate for proper learning, I don't use things I don't understand
20:31 < bridge_> <learath2> When I need to clone something that will get dropped in a minute it doesn't really compute in my brain
20:31 < bridge_> <ryozuki> it doesnt mean inproper learning
20:31 < bridge_> <ryozuki> it means steps
20:31 < bridge_> <ryozuki> i dont think adding lifetimes later is gonna be a big issue
20:32 < bridge_> <learath2> It means improper learning, if you just put a `.clone()` there and it kinda works you haven't understood shit
20:32 < bridge_> <ryozuki> XD
20:32 < bridge_> <ryozuki> no
20:32 < bridge_> <ryozuki> for u it means
20:32 < bridge_> <ryozuki> "i understand this is not the best but since i want to get a result fast for now ill leave it and refactor in the future, when  igot a proper structure"
20:32 < bridge_> <learath2> Don't care would rather have no bot then one I coded by randomly inserting stuff
20:33 < bridge_> <ryozuki> xd
20:33 < bridge_> <ryozuki> ok
20:33 < bridge_> <ryozuki> i think its not hard anyway
20:33 < bridge_> <learath2> Also I think you misunderstood my question, I explicitly want copy, not zero-copy
20:33 < bridge_> <learath2> With lifetimes I could achieve zero-copy, I cba
20:33 < bridge_> <ryozuki> by copy u mean the trait?
20:33 < bridge_> <ryozuki> u can only copy types that impl copy
20:34 < bridge_> <ryozuki> and structs that all fields are copy
20:34 < bridge_> <learath2> I have a `&toml::Value`, I should be able to deserialize out of this, no? It gives access to all the data needed to deserialize
20:34 < bridge_> <ryozuki> im now more confused
20:34 < bridge_> <ryozuki> i think u need to pass it by value
20:35 < bridge_> <ryozuki> since it doesnt know the underlying types
20:35 < bridge_> <ryozuki> its opaque
20:35 < bridge_> <ryozuki> it has to deserialize owning it
20:35 < bridge_> <ryozuki> i think thats the rationale
20:35 < bridge_> <learath2> So you can't deserialize from a borrowed type?
20:35 < bridge_> <ryozuki> u cant from &toml::Value specifically i think
20:35 < bridge_> <ryozuki> if u have a Deserialize struct
20:35 < bridge_> <ryozuki> i think u can
20:36 < bridge_> <ryozuki> ```rust
20:36 < bridge_> <ryozuki> /// Interpret a `toml::Value` as an instance of type `T`.
20:36 < bridge_> <ryozuki>     ///
20:36 < bridge_> <ryozuki>     /// This conversion can fail if the structure of the `Value` does not match the
20:36 < bridge_> <ryozuki>     /// structure expected by `T`, for example if `T` is a struct type but the
20:36 < bridge_> <ryozuki>     /// `Value` contains something other than a TOML table. It can also fail if the
20:36 < bridge_> <ryozuki>     /// structure is correct but `T`'s implementation of `Deserialize` decides that
20:36 < bridge_> <ryozuki>     /// something is wrong with the data, for example required struct fields are
20:36 < bridge_> <ryozuki>     /// missing from the TOML map or some number is too big to fit in the expected
20:36 < bridge_> <ryozuki>     /// primitive type.
20:36 < bridge_> <ryozuki>     pub fn try_into<'de, T>(self) -> Result<T, crate:üá©üá™:Error>
20:36 < bridge_> <ryozuki>     where
20:36 < bridge_> <ryozuki>         T: de::Deserialize<'de>,
20:36 < bridge_> <ryozuki>     {
20:36 < bridge_> <ryozuki>         d
20:36 < bridge_> <ryozuki> ```
20:36 < bridge_> <ryozuki> they impl it on self
20:36 < bridge_> <ryozuki> not &self
20:37 < bridge_> <ryozuki> ask them
20:37 < bridge_> <learath2> Ah, now I see
20:37 < bridge_> <ryozuki> @learath2 werent u the one saying the only truth is source code or smth
20:37 < bridge_> <ryozuki> i always check the type stuff
20:38 < bridge_> <ryozuki> control click on vscode
20:38 < bridge_> <learath2> True, idk why I didn't think to just check the source
20:39 < bridge_> <ryozuki> https://www.lelanthran.com/chap9/content.html
20:39 < bridge_> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1130569459074076765/duty_calls.png
20:39 < bridge_> <ryozuki> The C Programming Language: Myths and Reality (1)
20:40 < bridge_> <ryozuki> > 
20:40 < bridge_> <ryozuki> > 
20:40 < bridge_> <ryozuki> >     The Internet is the first thing that humanity has built that humanity doesn‚Äôt understand, the largest experiment in anarchy that we have ever had.
20:40 < bridge_> <ryozuki> > 
20:40 < bridge_> <ryozuki> >     -- Eric Schmidt
20:40 < bridge_> <ryozuki> xd
21:02 < bridge_> <louis.place> i love cooking up dumpster fire frontend code on company internships :poggers2:
21:14 < bridge_> <Ewan> https://cdn.discordapp.com/attachments/293493549758939136/1130578167325802536/image.png
21:14 < bridge_> <Ewan> awesome
21:16 < bridge_> <Ewan> not awesome
21:16 < bridge_> <Ewan> https://cdn.discordapp.com/attachments/293493549758939136/1130578767140622346/image.png
21:17 < bridge_> <Ewan> ü´•
21:17 < bridge_> <ryozuki> well this is for companies
21:17 < bridge_> <ryozuki> but ferrous systems is good
21:17 < bridge_> <Ewan> kdab is also epic
21:17 < bridge_> <ryozuki> they made the "ferrous standard reference" for rust
21:17 < bridge_> <ryozuki> idk kdab
21:18 < bridge_> <Ewan> kdab are 3d and qt/cpp specialists
21:18 < bridge_> <Ewan> but they maintain the awesome code browser that used to be woboq
21:18 < bridge_> <Ewan> and have a really cool newsletter and blogs
21:19 < bridge_> <ryozuki> https://ferrous-systems.com/blog/ferrocene-language-specification/
21:19 < bridge_> <ryozuki> ferrous are The Rust Specialists
21:19 < bridge_> <ryozuki> xd
21:20 < bridge_> <Ewan> i'm not sure it is for businesses based on the email i got
21:20 < bridge_> <Ewan> but idk
21:20 < bridge_> <Ewan> https://cdn.discordapp.com/attachments/293493549758939136/1130579756266573925/image.png
21:20 < bridge_> <ryozuki> https://spec.ferrocene.dev/
21:20 < bridge_> <ryozuki> @learath2
21:21 < bridge_> <ryozuki> @mpft but i wouldnt waste money learning the basics
21:21 < bridge_> <ryozuki> in fact i would go to them once i know a lot
21:21 < bridge_> <ryozuki> i want expert knowledge
21:21 < bridge_> <Ewan> xd maybe
21:21 < bridge_> <Ewan> not like i have that money anyway
21:21 < bridge_> <Ewan> seems like a cool thing though
21:22 < bridge_> <Ewan> i have to go
21:22 < bridge_> <Ewan> i bought a large bag of candied almonds at the renaissance festival yesterday and i wont be able to eat them for a while cuz i have a dentist appt xd
21:23 < bridge_> <ryozuki> xd
22:06 < bridge_> <chairn> how long to learn rust @ryozuki ? 
22:07 < bridge_> <chairn> https://www.reddit.com/r/ProgrammerHumor/comments/15240i5/programmingishard/
22:09 < bridge_> <ryozuki> xd
22:16 < bridge_> <_voxeldoesart> i got a code learning app and it doesnt have rust
22:16 < bridge_> <_voxeldoesart> lol
22:17 < bridge_> <_voxeldoesart> sololearn
22:25 < bridge_> <milkeeycat> code learning app üíÄ
22:30 < bridge_> <_voxeldoesart> and
22:34 < bridge_> <milkeeycat> I love them
22:36 < bridge_> <_voxeldoesart> oh ok
22:37 < bridge_> <Ewan> it‚Äôs 2:30 and my tooth hurty
22:37 < bridge_> <Ewan> excellent
