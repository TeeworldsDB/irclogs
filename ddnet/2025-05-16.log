02:34 < bridge> <cedex> Hey is there anywhere we can suggest features for the client ?
02:36 < bridge> <kebscs> #town-hall or github issues
02:37 < bridge> <teero777> @essigautomat you broke the speeder max speed bug. it's needed by some maps
02:37 < bridge> <teero777> https://cdn.discordapp.com/attachments/293493549758939136/1372734702368325672/Broken_brain.map?ex=6827da51&is=682688d1&hm=69e0010f750425aa5f0aa0be155cb22bb18be04e7e5938b94b119645db251854&
02:41 < bridge> <teero777> the prediction still predicts the bug tho
02:41 < bridge> <teero777> leads to a flicker
03:15 < bridge> <teero777> or someone else did xd
03:16 < bridge> <teero777> i instinctively blame assa
03:32 < bridge> <teero777> @alw5 finish on the same time 60 more times and then you have an illegal team size finish XD
03:33 < bridge> <teero777> would be the first in history
03:33 < bridge> <teero777> @alw5 finish with the same time 60 more times and then you have an illegal team size finish XD
03:33 < bridge> <teero777> @alw5 finish with the same time 124 more times and then you have an illegal team size finish XD
03:33 < bridge> <teero777> thats an epic bug tho
03:34 < bridge> <teero777> me omw to make a 1000 player teamrank
03:34 < bridge> <always> the tassers when they hear this one
03:35 < bridge> <cedex> I'd like to get started on contributing, where could I start from ?
03:36 < bridge> <always> https://github.com/ddnet/ddnet/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22good%20first%20issue%22
03:36 < bridge> <cedex> Thank you
03:36 < bridge> <always> this sorts open issues that have the label "good first issue"
03:43 < bridge> <kebscs> This only happens on bad maps tho :)
06:55 < bridge> <ryozuki> morning crude oil processors and others
06:55 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1372799573956886578/image.png?ex=682816bb&is=6826c53b&hm=ec58db39f75beef778507775ce1cd77124b3b048459805b8afccbf7e73f309f0&
07:34 < bridge> <meloƞ> What time complexity is this
07:45 < bridge> <inv41idu53rn4m3> crude oil
08:12 < bridge> <matodor> > if you want to change tune lock from 3 to 4, you would need to put unlock 3 and lock 4
08:12 < bridge> <matodor> 
08:12 < bridge> <matodor> have you fixed this yet?
08:12 < bridge> <matodor> it would be much more convenient to just touch lock 4, instead of put unlock 3 before
08:28 < bridge> <Assa> I didn't, I only added new speedtiles without that bug.
08:30 < bridge> <Assa> Went into server, still working.
08:56 < bridge> <milkeeycat> i felt this one today
08:56 < bridge> <ryozuki> xd
08:57 < bridge> <milkeeycat> man, my backend was going so smooth but it looks like I would need to make one more ir
09:22 < bridge> <matodor> https://cdn.discordapp.com/attachments/293493549758939136/1372836483073048739/image.png?ex=6828391b&is=6826e79b&hm=cc181cc8b4e754a0001a23b0ada4338f33b52aa593317c79b2451ae7143940fa&
10:08 < bridge> <kebscs> I can
10:08 < bridge> <kebscs> If wanted
10:09 < bridge> <matodor> @louis.place
10:13 < bridge> <Jupstar ✪> on which server did that happen
10:15 < bridge> <matodor> im join on LoopRay map -> open editor -> Load current map -> idk im just make some random changes in map -> press CTRL+SHIFT+E for exit from editor -> crash
10:15 < bridge> <matodor> cant' reproduce
10:15 < bridge> <Jupstar ✪> ok
17:54 < bridge> <kebscs> what about disable now?
17:54 < bridge> <kebscs> should it disable all only only of number?
18:01 < bridge> <matodor> idk, only if you can implement stack of locked tunezones, if no - maybe just tune lock off without number will be enough
18:04 < bridge> <kebscs> i think should disable all now that lock can lock any
18:04 < bridge> <kebscs> would be confusing to make parts
18:38 < bridge> <kebscs> #9793
18:38 < bridge> <kebscs> Changed to:
18:38 < bridge> <kebscs> Tune Lock tile now always locks new values, you no longer need to remove the lock
18:38 < bridge> <kebscs> Tune Unlock always unlocks, there's no need to match the same number
18:38 < bridge> <DDNet> https://github.com/ddnet/ddnet/pull/9793
19:23 < bridge> <gorp_tw> so u can't just do 0 index for tunelock to remove?
19:23 < bridge> <gorp_tw> i guess makes sense like other tiles
19:26 < bridge> <kebscs> i could ig
19:26 < bridge> <kebscs> so its only 1 new tile
19:31 < bridge> <gorp_tw> that was my idea of it but EHM some people here are zeroist
19:31 < bridge> <gorp_tw> they say its INVALID
19:35 < bridge> <louis> it's another thing u have to know / learn
19:42 < bridge> <Solly (bun bun)> do you ever want like some container and instead of just implementing it, you implement the most general case of it?
19:42 < bridge> <Solly (bun bun)> ```cpp
19:43 < bridge> <Solly (bun bun)> #include <atomic>
19:43 < bridge> <Solly (bun bun)> #include <chrono>
19:43 < bridge> <Solly (bun bun)> #include <condition_variable>
19:43 < bridge> <Solly (bun bun)> #include <cstdint>
19:43 < bridge> <Solly (bun bun)> #include <shared_mutex>
19:43 < bridge> <Solly (bun bun)> 
19:43 < bridge> <Solly (bun bun)> template<typename Value>
19:43 < bridge> <Solly (bun bun)> class RWLockedWithCon {
19:43 < bridge> <Solly (bun bun)> private:
19:43 < bridge> <Solly (bun bun)>     std::shared_mutex mtx;
19:43 < bridge> <Solly (bun bun)>     std::condition_variable con;
19:43 < bridge> <Solly (bun bun)>     std::mutex conMtx;
19:43 < bridge> <Solly (bun bun)>     std::atomic<uint8_t> written;
19:43 < bridge> <Solly (bun bun)>     Value value;
19:43 < bridge> <Solly (bun bun)>     class RWLockedWithConR {
19:43 < bridge> <Solly (bun bun)>     private:
19:43 < bridge> <Solly (bun bun)>         const Value& value;
19:43 < bridge> <Solly (bun bun)>         std::shared_lock<std::shared_mutex> lock;
19:43 < bridge> <Solly (bun bun)>     public:
19:43 < bridge> <Solly (bun bun)>         RWLockedWithConR(const Value& v, std::shared_mutex& m)
19:43 < bridge> <Solly (bun bun)>             : value(v), lock(m) {}
19:43 < bridge> <Solly (bun bun)>         const Value& operator*() { return value; }
19:43 < bridge> <Solly (bun bun)>         const Value* operator->() { return value; }
19:43 < bridge> <Solly (bun bun)>     };
19:43 < bridge> <Solly (bun bun)>     class RWLockedWithConW {
19:43 < bridge> <Solly (bun bun)>     private:
19:43 < bridge> <Solly (bun bun)>         Value& value;
19:43 < bridge> <Solly (bun bun)>         std::unique_lock<std::shared_mutex> lock;
19:43 < bridge> <Solly (bun bun)>         std::condition_variable& con;
19:43 < bridge> <Solly (bun bun)>         std::atomic<uint8_t>& written;
19:43 < bridge> <Solly (bun bun)> somethings wrong with me
20:04 < bridge> <gorp_tw> but yes
23:18 < bridge> <milkeeycat> rust pros, send help. I want to have one enum with common opcodes and others can "extend" it with its own variants. I made this monstrosity. Is it possible to write better? xd
23:18 < bridge> <milkeeycat> ```rust
23:18 < bridge> <milkeeycat> #![feature(variant_count)]
23:18 < bridge> <milkeeycat> 
23:18 < bridge> <milkeeycat> trait Opcode {
23:18 < bridge> <milkeeycat>     fn to_usize(&self) -> usize;
23:18 < bridge> <milkeeycat> }
23:18 < bridge> <milkeeycat> 
23:18 < bridge> <milkeeycat> #[derive(Clone, Copy)]
23:18 < bridge> <milkeeycat> enum GeneralOpcode {
23:18 < bridge> <milkeeycat>     Add,
23:19 < bridge> <milkeeycat> }
23:19 < bridge> <milkeeycat> 
23:19 < bridge> <milkeeycat> impl Opcode for GeneralOpcode {
23:19 < bridge> <milkeeycat>     fn to_usize(&self) -> usize {
23:19 < bridge> <milkeeycat>         *self as usize
23:19 < bridge> <milkeeycat>     }
23:19 < bridge> <milkeeycat> }
23:19 < bridge> <milkeeycat> 
23:19 < bridge> <milkeeycat> #[repr(usize)]
23:19 < bridge> <milkeeycat> enum CustomOpcode {
23:19 < bridge> <milkeeycat>     General(GeneralOpcode),
23:19 < bridge> <milkeeycat>     Add,
23:19 < bridge> <milkeeycat> }
23:19 < bridge> <milkeeycat> 
23:19 < bridge> <milkeeycat> impl Opcode for CustomOpcode {
23:19 < bridge> <milkeeycat>     fn to_usize(&self) -> usize {
23:19 < bridge> <milkeeycat>         match self {
23:19 < bridge> <milkeeycat>             Self::General(g) => g.to_usize(),
23:19 < bridge> <milkeeycat>             other => unsafe {
23:19 < bridge> <milkeeycat>                 std::mem::variant_count::<GeneralOpcode>()
23:37 < bridge> <Ewan> bizarre
23:43 < bridge> <Jupstar ✪> I'd use an others enum separately. Then you can write the parteq better
23:44 < bridge> <Jupstar ✪> Without unsafe
23:44 < bridge> <Jupstar ✪> You can still unify them in a allcodes enum
