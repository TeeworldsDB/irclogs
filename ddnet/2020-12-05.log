06:11 <+bridge> [ddnet] <heinrich5991> god damn it. today was very possible to get in the top100 ðŸ˜¦
09:14 <+ChillerDragon> flex
10:21 <+bridge> [ddnet] <Ryozuki> i dont get the second part
10:21 <+bridge> [ddnet] <Ryozuki> the meaning
10:21 <+bridge> [ddnet] <Ryozuki> :tee_thinking:
10:22 <+bridge> [ddnet] <Ryozuki> ahhh
10:25 <+bridge> [ddnet] <Ryozuki> done
10:26 <+bridge> [ddnet] <Ryozuki> <https://github.com/edg-l/adventofcode-2020/blob/master/day5.rs>
10:26 <+bridge> [ddnet] <Ryozuki> i think i got a pretty solution
10:31 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/784713507312369674/AmKPEqRG-RHyl2q577eDtoJxVmD8PCBwjntRPbJ8P6s.png
10:31 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
11:36 <+bridge> [ddnet] <becc> I did just ||sum from lowest to highest - sum all given ids||
11:36 <+bridge> [ddnet] <Ryozuki> read full msgs bro
11:36 <+bridge> [ddnet] <Ryozuki> i already did it
11:36 <+bridge> [ddnet] <becc> Yeah but you iterate and sort, pah :d
13:28 <+bridge> [ddnet] <deen> @Ryozuki I chose nim and abused binary search ðŸ˜„ https://github.com/def-/adventofcode-2020/blob/master/day5.nim
13:29 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
14:42 <+bridge> [ddnet] <timakro> Is `set` a hash set in nim?
14:44 <+bridge> [ddnet] <timakro> I just replaced F and B with 0 and 1 respectively to get binary and than used a standard lib function to convert to a number
15:36 <+bridge> [ddnet] <TsFreddie> :cirBlech:
15:38 <+bridge> [ddnet] <deen> @timakro yes, but I didn't use the regular hash sets (https://nim-lang.org/docs/sets.html) but instead the more efficient bit sets: https://nim-lang.org/docs/system.html#system-module-sets
15:39 <+bridge> [ddnet] <deen> thus also limited to int16
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> on codewars there was "count number of vowels a-e-i-o-u in string" and I was able to remove all branches :happy: 
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> 
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> ```cpp
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> int getCount(const std::string& inputStr){
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„>   int num_vowels = 0;
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„>   for (auto i : inputStr){
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„>     num_vowels += (0x208222 >> (i & 0x9F)) & 0x1;
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„>   }
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„>   return num_vowels;
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> }
15:54 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
15:55 <+bridge> [ddnet] <deen> nice
15:55 <+bridge> [ddnet] <ReD | allocaãƒ„> thanks :brownbear:
16:57 <+bridge> [ddnet] <heinrich5991> @allocaãƒ„ looks like undefined behavior. did you mean `(0x208222 >> (i & 0x1f)) & 0x1`?
16:57 <+bridge> [ddnet] <heinrich5991> (which probably also represents what your code will compile to)
17:00 <+bridge> [ddnet] <heinrich5991> indeed, they compile to the same assembly: https://godbolt.org/z/865Kez
17:02 <+bridge> [ddnet] <heinrich5991> these are the characters you count:
17:02 <+bridge> [ddnet] <heinrich5991> ```
17:02 <+bridge> [ddnet] <heinrich5991> >>> [chr(i) for i in range(128) if (0x208222 >> (i & 0x1F)) & 0x1]
17:02 <+bridge> [ddnet] <heinrich5991> ['\x01', '\x05', '\t', '\x0f', '\x15', '!', '%', ')', '/', '5', 'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u']
17:02 <+bridge> [ddnet] <heinrich5991> ```
17:02 <+bridge> [ddnet] <heinrich5991> these are the characters you count:
17:02 <+bridge> [ddnet] <heinrich5991> ```
17:02 <+bridge> [ddnet] <heinrich5991> >>> "".join([chr(i) for i in range(128) if (0x208222 >> (i & 0x1F)) & 0x1])
17:02 <+bridge> [ddnet] <heinrich5991> '\x01\x05\t\x0f\x15!%)/5AEIOUaeiou'
17:02 <+bridge> [ddnet] <heinrich5991> ```
17:03 <+bridge> [ddnet] <ReD | allocaãƒ„> the inputStr only contains lower case numbers and space, so I only considered that range
17:03 <+bridge> [ddnet] <heinrich5991> lowercase letters? ah okay
17:03 <+bridge> [ddnet] <ReD | allocaãƒ„> if it was whole range I would need to think about something else ðŸ˜„
17:03 <+bridge> [ddnet] <heinrich5991> nice optimization then ðŸ˜‰
17:06 <+bridge> [ddnet] <ReD | allocaãƒ„> thanks
17:06 <+bridge> [ddnet] <ReD | allocaãƒ„> I will think about the "all characters challenge" ðŸ˜‰
17:11 <+bridge> [ddnet] <Chairn> How did you find the 2 constants (0x208222, 0x9F)?
17:46 <+bridge> [ddnet] <Ryozuki> curious aswell
17:46 <+bridge> [ddnet] <Ryozuki> some math stuff?
17:46 <+bridge> [ddnet] <Ryozuki> xD
17:47 <+bridge> [ddnet] <nuborn> binary I think
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> ok let's explain :D
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> we start with character `i`
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> &ing 0x9F is just subtracting 96. it's useful because 'a' == 97, so it's just one off
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 0x208222 is 1000001000001000100010 in binary
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> which has 5 binary digits at positions : 1, 5, 9, 14 and 21
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> this corresponds to the position of vowels after 96 PLUS 1 because we only subtracted 96 :
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 'a' = 97 + 0
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 'e' = 97 + 4
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 'i' = 97 + 8
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 'o' = 97 + 14
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 'u' = 97 + 20
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:47 <+bridge> [ddnet] <ReD | allocaãƒ„> and after having rightshifting, if the last bit is `1` it must be a vowel
17:47 <+bridge> [ddnet] <Ryozuki> ohh
17:47 <+bridge> [ddnet] <Ryozuki> nice
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> ok let's explain :D
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> we start with character `i`
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> &ing 0x9F is just subtracting 96
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> because 0x9f = 1001'1111, and &ing this removes the 64 and 32 bit (which adds to 96)
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> it's useful because 'a' == 97, so it's just one off
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 0x208222 is 1000001000001000100010 in binary
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> which has 5 binary digits at positions : 1, 5, 9, 14 and 21
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> this corresponds to the position of vowels after 96 PLUS 1 because we only subtracted 96 :
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 'a' = 97 + 0
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 'e' = 97 + 4
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 'i' = 97 + 8
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 'o' = 97 + 14
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 'u' = 97 + 20
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> 
17:50 <+bridge> [ddnet] <ReD | allocaãƒ„> and after having rightshifting, if the last bit is `1` it must be a vowel
18:04 <+bridge> [ddnet] <ReD | allocaãƒ„> ok let's explain :D
18:04 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> we start with character `i`
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> &ing 0x9F is just subtracting 96
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> because 0x9f = 1001'1111, and &ing this removes the 64 and 32 bit (which adds to 96)
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> it's useful because 'a' == 97, so it's just one off
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 0x208222 is 1000001000001000100010 in binary
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> which has 5 binary digits at positions : 1, 5, 9, 14 and 21
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> this corresponds to the position of vowels after 96  :
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 'a' = 97 + 0        == 96 + 1
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 'e' = 97 + 4        == 96 + 5
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 'i' = 97 + 8        == 96 + 9
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 'o' = 97 + 14       == 96 + 14
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 'u' = 97 + 20       == 96 + 21
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:05 <+bridge> [ddnet] <ReD | allocaãƒ„> and after rightshifting, if the last bit is `1` it must be a vowel
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> ok let's explain :D
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> we start with character `i`
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> &ing 0x9F is just subtracting 96
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> because 0x9f = 1001'1111, and &ing this removes the 64 and 32 bit (which adds to 96)
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> it's useful because 'a' == 97, so it's just one off
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 0x208222 is 1000001000001000100010 in binary
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> which has 5 binary digits at positions : `1`, `5`, `9`, `14` and `21`
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> this corresponds to the position of vowels after 96  :
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 'a' = 97 + 0        == 96 + 1
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 'e' = 97 + 4        == 96 + 5
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 'i' = 97 + 8        == 96 + 9
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 'o' = 97 + 14       == 96 + 14
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 'u' = 97 + 20       == 96 + 21
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:06 <+bridge> [ddnet] <ReD | allocaãƒ„> and after rightshifting, if the last bit is `1` it must be a vowel
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> ok let's explain :D
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> we start with character `i`
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> &ing 0x9F is just subtracting 96
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> because 0x9f = 1001'1111, and &ing this removes the 64 and 32 bit (which adds to 96)
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> it's useful because 'a' == 97, so it's just one off
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 0x208222 is 1000001000001000100010 in binary
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> which has 5 binary digits at positions : `1`, `5`, `9`, `14` and `21`
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> this corresponds to the position of vowels after 96  :
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 'a' = 97 + 0        == 96 + 1
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 'e' = 97 + 4        == 96 + 5
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 'i' = 97 + 8        == 96 + 9
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 'o' = 97 + 14       == 96 + 14
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> 'u' = 97 + 20       == 96 + 21
18:16 <+bridge> [ddnet] <ReD | allocaãƒ„> ```
18:17 <+bridge> [ddnet] <ReD | allocaãƒ„> 
18:17 <+bridge> [ddnet] <ReD | allocaãƒ„> so if after rightshifting 0x208222 by (`i` - 96) the last bit is `1` ,it must be a vowel
18:20 <+bridge> [ddnet] <ReD | allocaãƒ„> @heinrich5991 and 0x9F and 0x1F compile into the same binaries because if a character was greater than 128 (96 + 32) than 0x208222 >> 32 results in 0, which has no `1` at the last bit . but this is undefined behavior (ISO 9899:2011 6.5.7 Bitwise shift operators) so you are correct that I should use 0x1F instead of 0x9F ðŸ˜„
18:22 <+bridge> [ddnet] <ReD | allocaãƒ„> @heinrich5991 and 0x9F and 0x1F compile into the same binaries because if a character was greater than 128 (96 + 32) than 0x208222 >> 32 results in 0, which has no `1` at the last bit . it doesn't matter for this string range, but this *could* lead to undefined behavior (ISO 9899:2011 6.5.7 Bitwise shift operators) which is avoidable, so you are correct that I should use 0x1F instead of 0x9F ðŸ˜„
18:24 <+bridge> [ddnet] <nils> just had this happen to two ppl on korean ddnet server. dk why
18:24 <+bridge> [ddnet] <nils> https://cdn.discordapp.com/attachments/293493549758939136/784832464992075826/corrupted_data.png
19:58 <+bridge> [ddnet] <deen> @nils send me their map and savecode (or name) in DM
