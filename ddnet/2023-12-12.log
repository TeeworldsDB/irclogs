01:26 < bridge> <blaiszephyr> winter depression is a serious illness!
01:39 < bridge> <_voxeldoesart> good
08:54 < bridge> <ryozuki> https://bughunters.google.com/blog/4805571163848704/llvm-cfi-and-cross-language-llvm-cfi-support-for-rust
10:11 < bridge> <Ewan> morning
10:26 < bridge> <ryozuki> morn
10:27 < bridge> <kekomonter> ing
11:20 < bridge> <teero777> gni
11:21 < bridge> <devinci24> nrom
11:22 < bridge> <teero777> üöó
11:50 < bridge> <Bota> Choo Choo
12:59 < bridge> <badoumed> Hello !
12:59 < bridge> <badoumed> 
12:59 < bridge> <badoumed> I have a little problem, my hook ingame have a delay.
12:59 < bridge> <badoumed> It's not anti-ping, i also try to off/on my pc and is not working :/
12:59 < bridge> <badoumed> I have a delay of 200 ms on my hook ...
13:17 < bridge> <Jupstar ‚ú™> turn off vsync
13:17 < bridge> <proudguy> Hello
13:17 < bridge> <proudguy> i have a problem
13:17 < bridge> <proudguy> so i refreshed DDNet and i have so low fps idk why
13:18 < bridge> <Jupstar ‚ú™> how low?
13:18 < bridge> <proudguy> i had 200FPS before
13:18 < bridge> <proudguy> 20FPS
13:18 < bridge> <Jupstar ‚ú™> do you know nightly builds?
13:18 < bridge> <proudguy> and its locked so it stucks at 20 max
13:18 < bridge> <proudguy> no
13:18 < bridge> <badoumed> The vsync is off
13:18 < bridge> <proudguy> its off
13:18 < bridge> <Jupstar ‚ú™> https://ddnet.org/news/nightly-build-revived/
13:18 < bridge> <Jupstar ‚ú™> 
13:18 < bridge> <Jupstar ‚ú™> can you try this ^ ?
13:19 < bridge> <Jupstar ‚ú™> was the delay always there?
13:19 < bridge> <badoumed> no
13:19 < bridge> <badoumed> i didn't play on my pc since 5 month and when i cb the delay was there but only on my hook the mouvement ect are normal
13:20 < bridge> <Jupstar ‚ú™> mh dunno, reset config maybe
13:20 < bridge> <Jupstar ‚ú™> rename ddnet in %appdata% for that
13:20 < bridge> <Jupstar ‚ú™> else look in your mouse settings
13:20 < bridge> <proudguy> wow i have 340FPS thx
13:51 < bridge> <dogy777> Windows 10
13:51 < bridge> <dogy777> https://cdn.discordapp.com/attachments/293493549758939136/1184115357598875768/image.png?ex=658acc5d&is=6578575d&hm=9794e2f5f278fa5f3b6b45b639fe1fa14168a43f4a85d2009a2ea0ebf342555e&
13:53 < bridge> <_voxeldoesart> chad windows 10 user
13:55 < bridge> <dogy777> help pls ‚ù§Ô∏è
13:59 < bridge> <Jupstar ‚ú™> that's a warning not an error
13:59 < bridge> <Jupstar ‚ú™> if you dont show the error nobody here can help
14:02 < bridge> <Ewan> someone really ought to go through and find all inappropriate c style casts and replace them
14:03 < bridge> <Ewan> there is very very very rarely an instance where you need a c cast
14:05 < bridge> <Jupstar ‚ú™> c style casts are simpler to type
14:06 < bridge> <Jupstar ‚ú™> i rarely ever used c++ casts
14:12 < bridge> <Fussel> c++ make it easier to avoid errors, and they more clearly state the intent
14:12 < bridge> <Fussel> c++ casts make it easier to avoid errors, and they more clearly state the intent
14:14 < bridge> <ryozuki> @learath2 do u think a malloc done within a JIT engine from llvm needs to be freed manually (the process calling the jit engine is alive all time) or when the jit engine is done its fred
14:14 < bridge> <ryozuki> i wonder if llvm jit has some docs on this
14:14 < bridge> <Jupstar ‚ú™> i dunno, i'd not agree with that tbh üòÑ
14:15 < bridge> <ryozuki> @jupeyy_keks best casts are pointer method casts in rust
14:15 < bridge> <ryozuki> they are type checked
14:15 < bridge> <ryozuki> i mean .cast() ans .const_cast()
14:15 < bridge> <learath2> Hm, I have no idea on how llvm jit works. You'll have to dig around it's docs
14:16 < bridge> <learath2> Modern C++ casts look so ugly and are so annoying to type, but they are better in every other aspect
14:16 < bridge> <ryozuki> https://doc.rust-lang.org/std/primitive.pointer.html#method.cast_const
14:16 < bridge> <ryozuki> my grip is there are lot of types of casts and they have long names
14:16 < bridge> <ryozuki> and also ub
14:17 < bridge> <Jupstar ‚ú™> i dislike dynamic cast, bcs it's simply overhead.
14:17 < bridge> <Jupstar ‚ú™> 
14:17 < bridge> <Jupstar ‚ú™> const_cast is basically c cast
14:17 < bridge> <Jupstar ‚ú™> 
14:17 < bridge> <Jupstar ‚ú™> and reinterpret cast should be avoided anyway
14:17 < bridge> <Jupstar ‚ú™> or static cast
14:17 < bridge> <ryozuki> isnt const cast for constness?
14:18 < bridge> <ryozuki> i forgot
14:18 < bridge> <Jupstar ‚ú™> does it even exist?
14:18 < bridge> <ryozuki> oh u mean rust?
14:18 < bridge> <ryozuki> its named cast_const xd
14:18 < bridge> <ryozuki> *mut to *const
14:18 < bridge> <ryozuki> `*mut T ` to `*const T`
14:18 < bridge> <ryozuki> `*mut A ` to `*const T`
14:19 < bridge> <learath2> You almost always want a static_cast, if you are a polymorphism enjoyer a dynamic_cast, if you are an opaque datatype enjoyer a reinterpret_cast and if you are doing blackmagic a bit_cast
14:19 < bridge> <ryozuki> @learath2 do u think its sensible to expect the jit malloc and rust libc dep to be same
14:19 < bridge> <ryozuki> and would a malloc from inside jit be ok with free from rust with libc
14:19 < bridge> <learath2> Oh and when you hate that the type system doesn't have nice sane const, you use const_cast üòÑ
14:20 < bridge> <Ewan> evil answer: garbage collected
14:20 < bridge> <_voxeldoesart> polymorphism fan vs opaque datatype enjoyer
14:20 < bridge> <Jupstar ‚ú™> https://cdn.discordapp.com/attachments/293493549758939136/1184122554047283280/image.png?ex=658ad310&is=65785e10&hm=5f1f192bac4342c8d77498ce11c0edcc2e08eaaa2056f15ce5f3f4d0eca896fa&
14:20 < bridge> <Ewan> mmh where you hear that
14:20 < bridge> <Jupstar ‚ú™> funny how fast one can forget c++ üò¨
14:20 < bridge> <Jupstar ‚ú™> i used too much rust lately
14:20 < bridge> <learath2> Uhh, this is something I have no idea about. If they really both use dynamically linked libc and the same libc, yes
14:20 < bridge> <Jupstar ‚ú™> hear what?
14:21 < bridge> <ryozuki> i think const cast is used when u face a badly designed api not using const
14:21 < bridge> <ryozuki> same bro
14:21 < bridge> <learath2> Problem is due to how const and overrides work some apis just cant be const correct
14:21 < bridge> <ryozuki> actually implementing garbage collection can be orders of magnitude harder
14:21 < bridge> <ryozuki> specially if u want a competitive gc
14:21 < bridge> <learath2> Overloads*
14:21 < bridge> <Ewan> const T *const_ptr;
14:21 < bridge> <Ewan> auto ptr = const_cast<T *>(const_ptr);
14:21 < bridge> <ryozuki> ill probs just refcount mallocs or smth
14:22 < bridge> <learath2> Implement mark and sweep gc, go
14:22 < bridge> <ryozuki> at my free time i started a weird project
14:22 < bridge> <ryozuki> im implementing pascal in mlir
14:22 < bridge> <ryozuki> cuz im bad at designing a language
14:22 < bridge> <ryozuki> i picked a easy one
14:22 < bridge> <Ewan> avoid reinterpret and static cast
14:22 < bridge> <Ewan> those are the 2 safest
14:23 < bridge> <ryozuki> avoid c++
14:23 < bridge> <ryozuki> thats the safest
14:23 < bridge> <Ewan> shut up pls
14:23 < bridge> <ryozuki> :3
14:23 < bridge> <Jupstar ‚ú™> reinterpret
14:23 < bridge> <Jupstar ‚ú™> the word alone is unsafe xD
14:23 < bridge> <learath2> There are a scant few legit uses of reinterpret cast
14:23 < bridge> <Ewan> hmmm
14:24 < bridge> <Ewan> hard to get much done without it when you have a base type and your derived objects are managed as points of the based type
14:24 < bridge> <learath2> You almost always want a static_cast
14:24 < bridge> <Ewan> e.g. every object oriented system
14:24 < bridge> <Jupstar ‚ú™> that sounds more like dynamic cast
14:24 < bridge> <Ewan> you are casting the ptrs
14:24 < bridge> <Jupstar ‚ú™> and dynamic casts have:
14:24 < bridge> <Jupstar ‚ú™> - overhead
14:25 < bridge> <Jupstar ‚ú™> - can return null ptrs (kinda bcs of above)
14:25 < bridge> <ryozuki> @learath2 is there a way to "try to free" a pointer but not segfault if u cant?
14:25 < bridge> <Jupstar ‚ú™> bcs they do type checks
14:25 < bridge> <Ewan> dynamic casts arw 100% runtime overhead avoid them
14:25 < bridge> <learath2> You mean upcasting?
14:25 < bridge> <Ewan> yes
14:26 < bridge> <learath2> Static casts work just fine there if you already know for sure the type
14:26 < bridge> <Fussel> Someone: ¬ªtoday I made me a toast hawaii¬´
14:26 < bridge> <Fussel> Ryozuki: ¬ªbut in rust ‚Ä¶¬´
14:26 < bridge> <learath2> And a dynamic cast just uses rtti to make sure the type is correct if you dont have another mechanism to figure it out
14:27 < bridge> <Jupstar ‚ú™> i mean if the roaster would write "software written in rust"
14:27 < bridge> <Jupstar ‚ú™> 
14:27 < bridge> <Jupstar ‚ú™> i'd buy it just for that
14:27 < bridge> <Jupstar ‚ú™> ngl xd
14:27 < bridge> <Jupstar ‚ú™> would be insanely funny
14:27 < bridge> <learath2> Nope
14:27 < bridge> <Jupstar ‚ú™> rusty toaster
14:27 < bridge> <_voxeldoesart> funniest rust advocate
14:28 < bridge> <Fussel> that's why when freeing a pointer you shoud set it to nullptr afterwards
14:28 < bridge> <learath2> The issue with c style casts is the fallback behaviour that no one really knows off the top of their head
14:28 < bridge> <Fussel> that's why when freeing a pointer you should set it to nullptr afterwards
14:28 < bridge> <Fussel> that's why when freeing a pointer you should set it to `nullptr` afterwards
14:29 < bridge> <Jupstar ‚ú™> or simply use unique_ptr
14:29 < bridge> <ryozuki> welcome to #developer home of rust
14:29 < bridge> <ryozuki> non zero cost üò¨
14:29 < bridge> <_voxeldoesart> ddnet is still 90% cpp
14:29 < bridge> <Jupstar ‚ú™> debugging ptr stuff is also not zero cost
14:29 < bridge> <Jupstar ‚ú™> üòè
14:30 < bridge> <ryozuki> üò¨
14:30 < bridge> <ryozuki> rust
14:30 < bridge> <learath2> I mean I know it off the top of my head but most people just put a cast there and dont care. But you usually dont want it to fallback to reinterpret cast since at that point it's usually a mistake
14:30 < bridge> <ryozuki> üò¨
14:30 < bridge> <Jupstar ‚ú™> üò¨
14:30 < bridge> <ryozuki> omg learath i wanted to surround it with faces
14:30 < bridge> <learath2> Nooo bad timing
14:30 < bridge> <Jupstar ‚ú™> @learath2 please delete your message
14:30 < bridge> <Fussel> repeating it over and over again does not make it right, you know
14:30 < bridge> <Jupstar ‚ú™> xd
14:30 < bridge> <ryozuki> lmao
14:30 < bridge> <learath2> Fixed
14:30 < bridge> <Jupstar ‚ú™> @learath2 lmao
14:30 < bridge> <ryozuki> we shown u its right tho
14:31 < bridge> <_voxeldoesart> https://tenor.com/view/brick-wall-talk-gif-5290288
14:31 < bridge> <Jupstar ‚ú™> i mean tbf, when using LTO, i am not sure
14:31 < bridge> <Jupstar ‚ú™> it might or might not be zero cost, depends on how the compiler performs
14:31 < bridge> <Ewan> super low %
14:31 < bridge> <learath2> It's still not 0 cost but it's like 0.00000001 cost üòÑ
14:31 < bridge> <Jupstar ‚ú™> i see
14:31 < bridge> <learath2> You get unlucky with caching and it's even 0.000001 cost
14:32 < bridge> <Ewan> my question is when will this actually matter. like who the hell cares. it‚Äôs so negligible you‚Äôre spending more effort talking about it than people will ever spend trying to counteract it
14:32 < bridge> <learath2> If you also are still running ancient dram modules it might even be 0.1 cost
14:32 < bridge> <ryozuki> idc i use it on my holy fight for rust
14:32 < bridge> <ryozuki> :NekoEvil:
14:32 < bridge> <_voxeldoesart> guys be silent im going to become funny to ddnet devs
14:32 < bridge> <Ewan> i like rust but people behaving the way you are is what makes people dislike it
14:32 < bridge> <Ewan> that alone
14:33 < bridge> <ryozuki> xDD
14:33 < bridge> <Ewan> is what gives the lang a bad rep
14:33 < bridge> <_voxeldoesart> what even is   100 cost
14:33 < bridge> <ryozuki> im trolling a bit but ok
14:33 < bridge> <_voxeldoesart> üòÇ üòÇ windows : üòÇ üòÇ üòÇ üòÇ
14:33 < bridge> <ryozuki> ill fix it for you
14:33 < bridge> <ryozuki> c++ best lang
14:33 < bridge> <ryozuki> thank god we code in c++
14:33 < bridge> <Jupstar ‚ú™> i see it more as comedy
14:33 < bridge> <Ewan> cpp isn‚Äôt usually the best choice
14:33 < bridge> <Ewan> just be realistic
14:33 < bridge> <Ewan> you can‚Äôt do rust everything
14:33 < bridge> <_voxeldoesart> comedy involves it being funny
14:33 < bridge> <learath2> At the scale of cost we are talking about with unique_ptr windows would be like TREE(3) cost
14:34 < bridge> <Jupstar ‚ú™> you don't find it funny, how brainwashed he is?
14:34 < bridge> <ryozuki> @learath2 realloc moving the ptr to a new addr doesnt mean i got to free the old addr right
14:34 < bridge> <ryozuki> ur my libc docs now
14:34 < bridge> <_voxeldoesart> me when i dont find the same joke told 2763 times funny
14:34 < bridge> <learath2> No, if realloc gives you a new addr that's the one ur responsible with freeing
14:34 < bridge> <Ewan> pointer points to same spot
14:35 < bridge> <Jupstar ‚ú™> it's like in animes.. the joke was never funny. it will still be done 50000 more times
14:35 < bridge> <ryozuki> thats the neat part, u can do rust everywhere u do c++
14:35 < bridge> <Ewan> you can‚Äôt
14:35 < bridge> <ryozuki> only limitation is maybe gcc on a weird platform
14:35 < bridge> <ryozuki> that no one uses
14:35 < bridge> <ryozuki> but soon thats fixed
14:35 < bridge> <ryozuki> with the rust gcc
14:35 < bridge> <Ewan> or maybe existing code and standards and knowledge and experience and unit tests and other infrastructure
14:35 < bridge> <Ewan> you can‚Äôt just ‚Äú‚Äùuse rust‚Äù‚Äù anywhere
14:36 < bridge> <ryozuki> ah u mean legally bound? i give u that
14:36 < bridge> <ryozuki> technically rust can be used everywhere c++ is used
14:36 < bridge> <Ewan> sure
14:36 < bridge> <Ewan> depending upon the revision
14:36 < bridge> <ryozuki> thats what i meant
14:36 < bridge> <ryozuki> u should learn rust already
14:36 < bridge> <Ewan> i like cpp better
14:36 < bridge> <ryozuki> jupstar was rly pro cpp
14:36 < bridge> <ryozuki> i remember
14:36 < bridge> <Jupstar ‚ú™> bad memory
14:37 < bridge> <ryozuki> no üò¨
14:37 < bridge> <Jupstar ‚ú™> 100%
14:37 < bridge> <learath2> Well Rust and C++ are both turing complete. You can technically do everything with them
14:37 < bridge> <Ewan> ryo u ask rudimentary cpp questions so i think your perception of pro cpp is a bit different
14:37 < bridge> <_voxeldoesart> you better dip asap
14:37 < bridge> <_voxeldoesart> every second you're around them they're just gonna poke at yoy
14:37 < bridge> <learath2> It's just that the cost of migrating 2 decades of legacy code is extremely prohibitive
14:37 < bridge> <_voxeldoesart> you better dip asap
14:37 < bridge> <_voxeldoesart> every second you're around them they're just gonna poke at you
14:37 < bridge> <ryozuki> im asking this basic stuff cuz i havent used libc for long xd and im lazy to check
14:38 < bridge> <Ewan> just saying
14:38 < bridge> <learath2> He used to be good. Then he got enlightened by the rust tree and deleted his knowledge of other inferior languages
14:38 < bridge> <ryozuki> u rly think my definition of someone pro at a programming lang is knowing library functions
14:38 < bridge> <Ewan> i think u misunderstood what i said
14:38 < bridge> <Ewan> but i am too tired to repeat myself
14:38 < bridge> <ryozuki> ok
14:39 < bridge> <ryozuki> i will hardly have advanced cpp questions because i literally dont use cpp
14:39 < bridge> <ryozuki> and dont want to anymore
14:39 < bridge> <ryozuki> advanced rust is more fun
14:39 < bridge> <Ewan> i looked into reinterpret cast and i suppose it‚Äôs only uniquely good for opaque data types like incomplete types or void ptrs
14:39 < bridge> <Ewan> but otherwise equivalent to static cast
14:40 < bridge> <learath2> void ptrs are safe to cast from/to with static too. So only opaque data types and some very niche tricks
14:40 < bridge> <Ewan> i suppose
14:41 < bridge> <Ewan> i don‚Äôt see the harm anyway
14:41 < bridge> <Ewan> i feel like in some circumstances casting between void ptrs can get you in trouble with more pedantic compiler settings
14:42 < bridge> <Ewan> strict aliasing?
14:42 < bridge> <ryozuki> that reminds me of something but ppl will get too mad
14:43 < bridge> <_voxeldoesart> ryo knowing limits? crazy
14:43 < bridge> <ryozuki> @mpft do u know about pointer provenance
14:43 < bridge> <ryozuki> "quick google"
14:43 < bridge> <Ewan> yea idk the term lol
14:43 < bridge> <ryozuki> https://www.ralfj.de/blog/2020/12/14/provenance.html
14:43 < bridge> <Ewan> is this just about ptr arithmetic
14:44 < bridge> <learath2> void and char ptrs are allowed to alias anything. So I'm unsure whether it can cause a strict aliasing issue, but even if it can the type of cast won't save you there
14:44 < bridge> <Ewan> true
14:44 < bridge> <learath2> Pointer provenance is arcane black magic that you will almost never have to care about. I wouldn't even read about it
14:44 < bridge> <learath2> Especially in C++
14:45 < bridge> <Ewan> isn‚Äôt it just like uint8_t * != uint16_t * because sizeof() for each is different?
14:45 < bridge> <learath2> It only ever is an issue if you use a placement new
14:45 < bridge> <Ewan> placement new is bonkers stuff that nobody in their right mind should use
14:45 < bridge> <ryozuki> üò¨
14:45 < bridge> <Ewan> use your words
14:46 < bridge> <Ewan> I‚Äôm not reading this blog post
14:46 < bridge> <Ewan> except for the time I recommended it be used for the ddnet kernel object or something
14:46 < bridge> <learath2> If you are tight on memory there are some uses to it üòÑ
14:47 < bridge> <Ewan> perhaps
14:47 < bridge> <learath2> Pointer provenance becomes an issue if you construct a new object of a different type in place of another
14:48 < bridge> <ryozuki> provenance distingishes different pointers to the same address, its cuz due to optimizations u can get unexpected results
14:48 < bridge> <Ewan> right
14:48 < bridge> <Ewan> so it‚Äôs basically what i said
14:48 < bridge> <ryozuki> this one is a rust definition
14:48 < bridge> <ryozuki> > The provenance of a pointer is used to distinguish pointers that point to the same memory address (i.e., pointers that, when cast to usize, will compare equal). Provenance is extra state that only exists in the Rust Abstract Machine; it is needed to specify program behavior but not present any more when the program runs on real hardware. In other words, pointers that only differ in their provenance can not be distinguished any more in the final b
14:48 < bridge> <learath2> The old pointer you held refers to a lifetime that has already ended, thus is technically invalid to access through. Which the compiler can optimize out causing UB
14:49 < bridge> <ryozuki> no not exactly
14:50 < bridge> <ryozuki> ```c
14:50 < bridge> <ryozuki> char p[1], q[1] = {0};
14:50 < bridge> <ryozuki> uintptr_t ip = (uintptr_t)(p+1);
14:50 < bridge> <ryozuki> uintptr_t iq = (uintptr_t)q;
14:50 < bridge> <ryozuki> if (iq == ip) {
14:50 < bridge> <ryozuki>   *(char*)iq = 10;
14:50 < bridge> <ryozuki>   print(q[0]);
14:50 < bridge> <ryozuki> }
14:50 < bridge> <ryozuki> ```
14:50 < bridge> <ryozuki> this is the example from the blog
14:50 < bridge> <Ewan> i see
14:50 < bridge> <learath2> As far as C++ is concerned it's about a way to break strict aliasing without invoking UB
14:50 < bridge> <Ewan> preposterous
14:50 < bridge> <Ewan> any way of circumventing optimizations may as well be IB
14:51 < bridge> <Ewan> ub
14:51 < bridge> <learath2> https://youtu.be/5HXCbLilIzs?si=9YxrUMbpbXZOOONw if you wanna hear about a C++ feature you'll never have any use for
14:51 < bridge> <Ewan> i think i read about it
14:51 < bridge> <ryozuki> novice cpp
14:51 < bridge> <ryozuki> üò¨
14:52 < bridge> <Ewan> what are you talking about
14:52 < bridge> <ryozuki> nothing
14:52 < bridge> <Jupstar ‚ú™> you know what is funny.
14:52 < bridge> <Jupstar ‚ú™> All concepts i now use in rust, were ideas i had long before i've ever touched rust:
14:52 < bridge> <Jupstar ‚ú™> 
14:52 < bridge> <Jupstar ‚ú™> https://discord.com/channels/252358080522747904/293493549758939136/994267418220306462
14:52 < bridge> <Jupstar ‚ú™> 
14:52 < bridge> <Jupstar ‚ú™> https://discord.com/channels/252358080522747904/293493549758939136/966359790672556144
14:52 < bridge> <Jupstar ‚ú™> 
14:52 < bridge> <Jupstar ‚ú™> https://discord.com/channels/252358080522747904/293493549758939136/997967609863602207
14:52 < bridge> <Jupstar ‚ú™> 
14:52 < bridge> <Jupstar ‚ú™> I often agreed that rust solves the memory related stuff. Tbf i did not expect that proc macros solve a few of my issues for logic errors. Besides that i never am _really_ pro any language that exists yet.
14:52 < bridge> <Jupstar ‚ú™> I'd need a language that is preventing logic errors to be as fanboy as you are about rust üò¨ 
14:52 < bridge> <Jupstar ‚ú™> 
14:52 < bridge> <Jupstar ‚ú™> I do think rust is better than cpp (with few exceptions), but i am defs less of a fanboy of rust than you think xD
14:52 < bridge> <Jupstar ‚ú™> @ryozuki thanks for reading my ted talk
14:52 < bridge> <Jupstar ‚ú™> üò¨
14:53 < bridge> <ryozuki> i also always said if a lang with better borrow checker or same idea comes
14:53 < bridge> <learath2> My 3 favourite things about rust are:
14:53 < bridge> <learath2> - Sum types/Error handling
14:53 < bridge> <learath2> - Traits
14:53 < bridge> <learath2> - proc_macros
14:53 < bridge> <ryozuki> ill be first to switch
14:53 < bridge> <Jupstar ‚ú™> üò¨
14:53 < bridge> <Jupstar ‚ú™> trur
14:53 < bridge> <Jupstar ‚ú™> tsur*
14:53 < bridge> <learath2> I'm not a huge fan of the whole fearless concurrency and automatic memory management. I'm an old man
14:53 < bridge> <Jupstar ‚ú™> tsur > rust
14:53 < bridge> <ryozuki> invent tsur
14:54 < bridge> <learath2> Send + Sync, borrowck too smart for me
14:54 < bridge> <ryozuki> i just like how it makes so much sense
14:54 < bridge> <Ewan> i leave since it seems ryo is just trying to troll
14:54 < bridge> <ryozuki> ???
14:54 < bridge> <ryozuki> xd
14:54 < bridge> <Ewan> get someone‚Äôs goat. not sure whose
14:54 < bridge> <Ewan> good night üåô
14:55 < bridge> <learath2> If I were to make a language it'd take these 3 and transplant it into a clean version of C
14:55 < bridge> <ryozuki> i was just making a snark remark at u for the pro cpp thing
14:55 < bridge> <ryozuki> good night!
14:55 < bridge> <Jupstar ‚ú™> what do you like about traits, if i may ask?
14:55 < bridge> <learath2> I'd also steal namespaces from C++
14:56 < bridge> <learath2> I like the idea of methods acting on objects. I don't enjoy polymorphism that much though
14:56 < bridge> <learath2> Traits are a nice compromise
14:56 < bridge> <Jupstar ‚ú™> yeah i agree, i still try to generally minimize using them, except for containers or other "global" structures
14:57 < bridge> <learath2> It gives me methods and a way to define shared behaviour
14:58 < bridge> <learath2> I probably would also omit the automatic dereferencing in my language. It's just too much to think about for me
14:58 < bridge> <ryozuki> uh why
14:58 < bridge> <ryozuki> i find modules on rust best
14:58 < bridge> <Jupstar ‚ú™> i think my top 3 are:
14:58 < bridge> <Jupstar ‚ú™> - enum structs (and ofc the resulting pattern matching)
14:58 < bridge> <Jupstar ‚ú™> - proc macros
14:58 < bridge> <Jupstar ‚ú™> - easier ecosystem (e.g. adding deps etc.)
14:58 < bridge> <ryozuki> actually includes in c c++ are thing of past
14:58 < bridge> <Jupstar ‚ú™> well headers are from hell
14:58 < bridge> <Jupstar ‚ú™> lets face it
14:58 < bridge> <learath2> I could take Rust modules too yeah. I need some way to group things together the one namespace in C is so dirty
14:58 < bridge> <Jupstar ‚ú™> i never in my life thought: oh now write the shit in headers is so much fun
14:59 < bridge> <ryozuki> its harder to parse a header than anything else
14:59 < bridge> <ryozuki> what u mean b enums is ADT algebraic data types
14:59 < bridge> <_voxeldoesart> when remove header files
15:00 < bridge> <ryozuki> https://en.wikipedia.org/wiki/Algebraic_data_type
15:00 < bridge> <ryozuki> this should be basis for any new lang
15:00 < bridge> <Jupstar ‚ú™> yep, but e.g. in typescript it completely sucks
15:00 < bridge> <Jupstar ‚ú™> without pattern matching it's kinda useless
15:00 < bridge> <ryozuki> ye
15:00 < bridge> <ryozuki> pattern matching is important
15:01 < bridge> <ryozuki> strong typing
15:01 < bridge> <learath2> 1 thing I like about header files is how they are like a summary of the class. I might have to figure out some way to separate that in my language too
15:01 < bridge> <ryozuki> ts has a ez escape hatch from type system
15:01 < bridge> <ryozuki> as any
15:01 < bridge> <ryozuki> `as any`
15:01 < bridge> <Jupstar ‚ú™> true, sometimes reading the functions of a class in headers is easier üòÑ
15:01 < bridge> <ryozuki> rust is also more grepable than c
15:01 < bridge> <ryozuki> grep fn
15:01 < bridge> <Jupstar ‚ú™> but not smth an editor could not do
15:01 < bridge> <ryozuki> to list functions
15:02 < bridge> <learath2> I might steal the modern function declaration syntax too, but I also don't really want to break "declaration follows use"
15:05 < bridge> <ryozuki> i also like i64
15:05 < bridge> <ryozuki> vs int
15:05 < bridge> <learath2> I can also takes lambdas from C++. I'll also need to patch together an async system. Something less fearless
15:08 < bridge> <learath2> Maybe the idea of executors from rust, impeccable usability of ES6 promises, multiple executors from folly, and a Stream wrapper inspired by rxjs Observable, might make a nice unholy combination
15:09 < bridge> <learath2> Some sort of coroutines would also be cool but it's a bit difficult to do
15:09 < bridge> <Jupstar ‚ú™> do es6 promises finally add yield?
15:10 < bridge> <Jupstar ‚ú™> i die without it
15:10 < bridge> <learath2> No yield still
15:11 < bridge> <Jupstar ‚ú™> i mean i only have like 3-4 use cases
15:11 < bridge> <learath2> Wait which sort of yield are you talking about?
15:11 < bridge> <learath2> Like yielding a value?
15:11 < bridge> <Jupstar ‚ú™> it just hard without a notifier/notify system
15:12 < bridge> <Jupstar ‚ú™> since js also doesnt have this
15:12 < bridge> <Jupstar ‚ú™> i could live with a yield
15:12 < bridge> <learath2> Are Observables perhaps what you are looking for?
15:13 < bridge> <learath2> They are pretty enjoyable to use
15:13 < bridge> <Jupstar ‚ú™> i'll look into it
15:13 < bridge> <ryozuki> is nodejs thread safe?
15:13 < bridge> <Jupstar ‚ú™> well webworkers have only limited functionality
15:14 < bridge> <Jupstar ‚ú™> so you dont really have multi threading i'd say
15:14 < bridge> <learath2> What does it mean for a js runtime to be thread safe?
15:14 < bridge> <Bota> Chillerdragon you know of an js / ts lib to connect a client with acess to rcon? If not id rather do Network sniffer. If both dont work ill try writing something for reading remote dumps (then ill be sad tho)
15:14 < bridge> <learath2> You really might have an easier time just building a client that does this
15:15 < bridge> <Bota> Learning c++ from scratch is easier?
15:15 < bridge> <Jupstar ‚ú™> the problem already is:
15:15 < bridge> <Jupstar ‚ú™> js / ts have no udp support
15:15 < bridge> <Jupstar ‚ú™> i dunno if nodejs has modules for it... maybe
15:15 < bridge> <Jupstar ‚ú™> then you could maybe built ddnet to wasm
15:15 < bridge> <Jupstar ‚ú™> and use it with js xd
15:15 < ws-client> <ChillerDragon> @Bota yea as jopsti said if it is in the browser it wont work. Are you doing it in the frontend or backend?
15:16 < ws-client> <ChillerDragon> @Bota also nudel said he did not add rcon so it might not work
15:16 < bridge> <learath2> Ah, I thought you knew C++. Then that's a no go
15:16 < ws-client> <ChillerDragon> @Bota i think my ruby client has rcon and it is really easy to use. Does the server you want it for accept 0.7 connections?
15:17 < bridge> <Jupstar ‚ú™> @alex0006 have you ever checked how often log.txt is written by the client?
15:17 < bridge> <Jupstar ‚ú™> 
15:17 < bridge> <Jupstar ‚ú™> i bet u can just add a `flush` somewhere and read from it live
15:17 < ws-client> <ChillerDragon> https://github.com/ChillerDragon/teeworlds_network/blob/97de34f1518018292aa81aae3e0fb7d3ea91d6e0/docs/classes/TeeworldsClient.md#on_rcon_line
15:17 < bridge> <Jupstar ‚ú™> then u _almost_ have to not alter the client
15:17 < bridge> <learath2> Log probably doesnt contain rcon though
15:17 < bridge> <Bota> I have a web framework for displaying
15:18 < ws-client> <ChillerDragon> yea regular log does not contain rcon 
15:18 < ws-client> <ChillerDragon> there is console dump but it is not live
15:18 < bridge> <Bota> Getting data outside the project is only possible via requests
15:18 < bridge> <Jupstar ‚ú™> @alex0006 didnt u just want chat? xd
15:18 < bridge> <Bota> I need chat data
15:18 < bridge> <Jupstar ‚ú™> so no need for rcon right?
15:18 < bridge> <Bota> I need ips
15:18 < bridge> <Jupstar ‚ú™> lmao
15:19 < ws-client> <ChillerDragon> @Jupstar ‚ú™ no need for flush its pretty live
15:19 < bridge> <Jupstar ‚ú™> isnt there a e-con?
15:19 < bridge> <Jupstar ‚ú™> yeah but you on the master race linux
15:19 < ws-client> <ChillerDragon> o
15:19 < bridge> <learath2> There is but it's not enabled on ddnet servers and it wouldn't really be available to mods anyway
15:19 < bridge> <Jupstar ‚ú™> makes sense
15:19 < bridge> <Bota> Idk what a 0.7 server is.
15:19 < ws-client> <ChillerDragon> whats the ip of the server
15:20 < ws-client> <ChillerDragon> i can tell you
15:20 < bridge> <learath2> He wants to use it on ddnet servers
15:20 < bridge> <Bota> Official ddnet servers
15:20 < ws-client> <ChillerDragon> they have 0.7 support
15:20 < ws-client> <ChillerDragon> so you can use the ruby lib
15:20 < bridge> <cyberfighter> the ip is 127.0.0.1
15:20 < bridge> <Bota> So ur ruby lib is a client easy to modify?
15:21 < ws-client> <ChillerDragon> yea
15:21 < ws-client> <ChillerDragon> lemme quikcly test if it can really join ddnet
15:21 < ws-client> <ChillerDragon> or just vanilla
15:22 < bridge> <Bota> Well ill just send the data from ur ruby client to my display frontend via http then. Figuring that out shouldn‚Äôt be hard
15:23 < bridge> <Bota> In worst case ill let chatgpt do the coding
15:23 < ws-client> <ChillerDragon> yea works
15:23 < bridge> <Bota> Nice
15:23 < ws-client> <ChillerDragon> i can also write the boilerplate code for u sec
15:24 < bridge> <Bota> Im at work and i come late home, no rush üôÇ But ty
15:30 < ws-client> <ChillerDragon> https://paste.zillyhuhn.com/hH
15:30 < ws-client> <ChillerDragon> here u go
15:30 < ws-client> <ChillerDragon> i realized it is a bit bugged and gets chat messages multiple times <:justatest:572499997178986510> 
15:30 < ws-client> <ChillerDragon> if you really start using that i will investigate that and fix my lib :) 
15:32 < bridge> <Bota> Ty if its that easy I‚Äôll probably use it
15:32 < ws-client> <ChillerDragon> yea ruby is really easy to use. The code makes sense does it?
15:32 < bridge> <Bota> I can understand it
15:32 < ws-client> <ChillerDragon> poggies
15:33 < bridge> <Bota> For syntax ill have to look a bit but it looks very doable
15:33 < ws-client> <ChillerDragon> thats where chatgpt will help
15:33 < bridge> <Bota> Y
15:33 < ws-client> <ChillerDragon> also feel free to ask me. You are the first user of that lib im still motivated to give support hehe
15:34 < bridge> <Bota> Ill make the whole mod team use it if it has all i want üôÇ
15:35 < bridge> <Bota> The first frontend as backend to frontend application
15:35 < bridge> <Bota> Lol
15:36 < bridge> <Jupstar ‚ú™> just be careful to make it secure then xd
15:39 < bridge> <Bota> The whole thing will be running only locally
15:39 < bridge> <Jupstar ‚ú™> i c
15:39 < bridge> <Bota> No Security needed
15:40 < bridge> <Bota> If my poc work ill try something properly
15:42 < ws-client> <ChillerDragon> If you want this client to talk with a front end this might be interesting for you too https://github.com/ChillerDragon/teeworlds_rest_client
15:43 < ws-client> <ChillerDragon> its the same client but now with a rest api 
15:43 < ws-client> <ChillerDragon> but you would have to extend it your self to have also rcon endpoints
15:45 < bridge> <Bota> Thats a whole client?!
15:45 < ws-client> <ChillerDragon> the link i sent you is a webserver that uses the same library under the hood i showed you earlier
15:45 < ws-client> <ChillerDragon> so if you start the webserver you can access api endpoints to get chat messages or make it move in game
15:49 < bridge> <Bota> That webserver would be all i need
15:49 < bridge> <Bota> Ill look at all of it when im home
15:50 < ws-client> <ChillerDragon> i have to warn you i quickly hacked it together and it was the first test run of the underlying tw network lib and its all a bit wonkey
15:50 < ws-client> <ChillerDragon> and you have to write some code for it also to expose the rcon stuff in the api but then yea it will be super close to what you need
15:51 < bridge> <Bota> Once i get the data i need to develop the frontend. It should take a while.
15:52 < bridge> <Bota> Like months
15:53 < bridge> <Bota> In the meantime a lot can happen/ change
15:53 < ws-client> <ChillerDragon> you mean i have a lot of time to fix the lib? :D 
15:53 < bridge> <Bota> And if you don‚Äôt touch ill i will try my luck. Thats not a lot of code
15:53 < bridge> <Bota> If you want to üôÇ
15:54 < bridge> <Bota> Having someone on my project will be nice:D
15:54 < ws-client> <ChillerDragon> yea the http thing is not a lot of code because all the teeworlds procotol is abstracted away by the other tw network lib
15:54 < bridge> <Bota> Smart
15:55 < bridge> <Bota> It‚Äôs fascinating how those dependency chains work somehow
16:03 < ws-client> <ChillerDragon> lerato so i can use ``std::launder`` to fix ub? sounds pog
16:14 < bridge> <heinrich5991> not on windows
16:15 < bridge> <heinrich5991> got any evidence to the contrary?
16:16 < bridge> <heinrich5991> it doens't follow you can do everything the hardware supports with them
16:16 < bridge> <heinrich5991> brainfuck is also turing complete
16:17 < bridge> <heinrich5991> sounds like zig or so
16:17 < bridge> <Fussel> I posted something about 1-2 days ago, I think. it's extendable
16:18 < bridge> <heinrich5991> rustdoc
16:19 < bridge> <heinrich5991> link?
16:20 < bridge> <Fussel> https://cdn.discordapp.com/attachments/293493549758939136/1184152681284108328/image.png?ex=658aef1f&is=65787a1f&hm=296468336010ecd9909c1538d4a6b9233d53c5111b19411de46db22e54deba3e&
16:20 < bridge> <Fussel> I don't see an overhead.
16:21 < bridge> <Jupstar ‚ú™> it depends on the program size anyway. the compiler can also optimize away heap allocations completely
16:21 < bridge> <Jupstar ‚ú™> and if not program size, then other parameters
16:21 < bridge> <ryozuki> https://firedbg.sea-ql.org/blog/2023-12-12-introducing-firedbg/
16:26 < bridge> <Fussel> just to clarify: I don't care if there would be a small overhead, because 1. don't do premature optimization and 2. I avoid using `unique_ptr` anyway
16:26 < bridge> <Fussel> it's just wrong ^^
16:26 < bridge> <Jupstar ‚ú™> 1. i understand that
16:26 < bridge> <Jupstar ‚ú™> 2. what is the alternative?
16:27 < bridge> <Jupstar ‚ú™> micro optimizations are often waste of time.
16:27 < bridge> <Jupstar ‚ú™> if your product isn't already almost perfect, they won't be the biggest bottleneck
16:28 < bridge> <Jupstar ‚ú™> in bigger software it's usually some algorithms that are slow, or design flaws that prevent parallelizm
16:28 < bridge> <Jupstar ‚ú™> i dont understand their example, but generally sounds funny. but also not very useful for complex programs xdd
16:30 < bridge> <Fussel> @jupeyy_keks references wherever possible, `shared_ptr` where it's semantically correct, or raw pointer where I can't avoid them. The problem with `unique_ptr` is, that STL containers expect their `::value_type` to be copy constructible, so you cannot use `unique_ptr` there
16:32 < bridge> <ryozuki> yeah
16:32 < bridge> <Jupstar ‚ú™> say it
16:32 < bridge> <Jupstar ‚ú™> SAY IT
16:32 < bridge> <Jupstar ‚ú™> üòÑ
16:32 < bridge> <ryozuki> i want to state that i am indeed trolling a bit the c++ users out there xd
16:32 < bridge> <ryozuki> but at the end rust box is the truly zero cost üò¨
16:33 < bridge> <ryozuki> fearless concurrency
16:33 < bridge> <Jupstar ‚ú™> YEAH
16:33 < bridge> <ryozuki> xd
16:34 < bridge> <ryozuki> actually rust provides better value here
16:34 < bridge> <ryozuki> due to the protection against data races
16:34 < bridge> <Fussel> zZz
16:34 < bridge> <ryozuki> but we all know fussel is pro like learath and can do concurrency without an issue
16:34 < bridge> <ryozuki> üò¨
16:35 < bridge> <Fussel> did even write my own mutexes because i needed some with at most 1 byte in size
16:35 < bridge> <ryozuki> @jupeyy_keks clang tooling itself shows the need for it, with their tsan
16:35 < bridge> <Fussel> so yes, concurrency isn't that difficult
16:35 < bridge> <Jupstar ‚ú™> wait 3 seconds and u get 20 crates that do the same
16:35 < bridge> <Jupstar ‚ú™> lmao
16:35 < bridge> <ryozuki> i wrote my own kernel in rust, so what
16:36 < bridge> <ryozuki> üò¨
16:36 < bridge> <ryozuki> he said it!!
16:36 < bridge> <Jupstar ‚ú™> even in rust concurrency is hard
16:36 < bridge> <Jupstar ‚ú™> fearless, but very hard
16:36 < bridge> <ryozuki> its among the biggest programming hurdles
16:36 < bridge> <Jupstar ‚ú™> yes
16:37 < bridge> <Jupstar ‚ú™> same for async
16:37 < bridge> <ryozuki> even rust
16:37 < bridge> <ryozuki> doesnt protect for this https://en.wikipedia.org/wiki/ABA_problem
16:37 < bridge> <ryozuki> and more
16:37 < bridge> <Jupstar ‚ú™> ok async is kind of concurrency
16:37 < bridge> <Jupstar ‚ú™> 
16:37 < bridge> <Jupstar ‚ú™> but i assume you meant multi threading
16:37 < bridge> <ryozuki> just so many problems come out of multithreading
16:37 < bridge> <ryozuki> but its not that hard
16:37 < bridge> <ryozuki> kek
16:38 < bridge> <ryozuki> https://github.com/ddnet/ddnet/issues?q=segfault+
16:38 < bridge> <ryozuki> @jupeyy_keks
16:38 < bridge> <ryozuki> üò¨
16:39 < bridge> <Jupstar ‚ú™> lm ao
16:39 < bridge> <ryozuki> https://github.com/ddnet/ddnet/issues/3326
16:39 < bridge> <ryozuki> https://github.com/ddnet/ddnet/issues/1131
16:40 < bridge> <Jupstar ‚ú™> bcs concurrency is hard
16:40 < bridge> <Jupstar ‚ú™> üòõ
16:40 < bridge> <ryozuki> ü§≠
16:40 < bridge> <Fussel> so many problems come out of using pointers, as long as you don't do it right
16:40 < bridge> <Fussel> where is the point?
16:40 < bridge> <ryozuki> the point is with safe rust u cant get that problem (segfaults)
16:41 < bridge> <Jupstar ‚ú™> but imo that's also not directly comparable
16:41 < bridge> <Jupstar ‚ú™> multi threading is so much
16:41 < bridge> <Jupstar ‚ú™> 
16:41 < bridge> <Jupstar ‚ú™> let alone some stupid dead lock
16:41 < bridge> <ryozuki> but also the borrow checker itself with the exclusive mutability protects already u in mt
16:41 < bridge> <Jupstar ‚ú™> u easily extend the lifetime of stuff, which can lead to leaks etc.
16:41 < bridge> <ryozuki> it doesnt protect from deadlockes
16:42 < bridge> <Jupstar ‚ú™> timing stuff
16:42 < bridge> <Jupstar ‚ú™> just so hard
16:42 < bridge> <Fussel> @ryozuki there is a programming language to solve the problem of programmers not proper formatting code. It's one python's key feature to ‚Ä∫solve‚Äπ a problem, a language should not try to solve.
16:42 < bridge> <ryozuki> @jupeyy_keks did u ever check https://github.com/tokio-rs/loom
16:43 < bridge> <Fussel> @ryozuki there is a programming language to solve the problem of programmers not properly formatting code. It's one python's key feature to ‚Ä∫solve‚Äπ a problem, a language should not try to solve.
16:43 < bridge> <Jupstar ‚ú™> not really, but i like that
16:43 < bridge> <Fussel> same goes with java, and rust too: solving problems a language should not solve ‚Ä¶
16:43 < bridge> <ryozuki> uh
16:43 < bridge> <ryozuki> i dislike that argument, its like saying no to progress xd
16:43 < bridge> <ryozuki> i cant rebate that
16:44 < bridge> <ryozuki> if u dont like progress thats it
16:44 < bridge> <Jupstar ‚ú™> the python syntax sucks, bcs i have a formatter that formats my code üòõ
16:44 < bridge> <ryozuki> the problems rust solves are among the most important in the field
16:44 < bridge> <Fussel> I don't like haskell. but I readily admit it's something useful
16:44 < bridge> <Jupstar ‚ú™> so python syntax only forces the code to have few less keywords as `;`
16:44 < bridge> <ryozuki> for me c++ is not useful
16:44 < bridge> <ryozuki> rust is
16:44 < bridge> <ryozuki> also for me haskell isnt rly useful
16:45 < bridge> <Fussel> In matters of ‚Ä∫progress‚Äπ not of ‚Ä∫personal taste‚Äπ
16:45 < bridge> <ryozuki> python is useful as a scripting lang, rust is useful for safe systems, c++ is useful to get segfaults to test ur kernel page protection
16:45 < bridge> <ryozuki> üò¨
16:45 < bridge> <Jupstar ‚ú™> but what if u write a rust interpreter
16:45 < bridge> <Jupstar ‚ú™> üòè
16:45 < bridge> <ryozuki> xd
16:46 < bridge> <Fussel> c++ offers you facilities to easily avoid segfault. so if you get one, it's your fault ^^
16:46 < bridge> <ryozuki> in matters of progress, rust is the biggest in language progress
16:46 < bridge> <ryozuki> its hilarious to deny that
16:46 < bridge> <Jupstar ‚ú™> anyway, one thing in this discussion is important.
16:46 < bridge> <Jupstar ‚ú™> 
16:46 < bridge> <Jupstar ‚ú™> Rust at least partially tries to fight against/solve problems of c++.
16:47 < bridge> <Jupstar ‚ú™> 
16:47 < bridge> <Jupstar ‚ú™> it does not really try to solve problems of python etc.
16:47 < bridge> <Fussel> sry @ryozuki didn't want to shit in your bible üò¶
16:47 < bridge> <ryozuki> ??? xd
16:47 < bridge> <ryozuki> what bible
16:47 < bridge> <ryozuki> its a fact
16:48 < bridge> <ryozuki> wait i give u the paper
16:48 < bridge> <ryozuki> https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf
16:48 < bridge> <ryozuki> good read
16:49 < bridge> <ryozuki> @jupeyy_keks we got a c++ supremacist on chat
16:49 < bridge> <ryozuki> we got competence now
16:49 < bridge> <Jupstar ‚ú™> you are right. but once you use these components you kinda force yourself into an ecosystem anyway.
16:49 < bridge> <Jupstar ‚ú™> 
16:49 < bridge> <Jupstar ‚ú™> Rust is higher level than cpp. just is cpp STL higher level than coding in c directly
16:49 < bridge> <ryozuki> cpp can offer all the new facilities, but always have those old ones
16:49 < bridge> <ryozuki> and many c++ code is old using those
16:49 < bridge> <ryozuki> so u have to adapt to it
16:50 < bridge> <learath2> If we are pedantic, yes. But I thought it was obvious that neither language would allow anything the hardware doesn't allow
16:52 < bridge> <ryozuki> tbh my point there was that rust can also be used in the fields where c++ is used
16:52 < bridge> <ryozuki> well its where it should be used most
16:53 < bridge> <learath2> Immediately after that I illustrated the overhead in question. Which was summarily dismissed for some reason üòÑ
16:54 < bridge> <ryozuki> ye he is ignoring the godbolt link
16:54 < bridge> <ryozuki> i resent it actually xd
16:55 < bridge> <ryozuki> also from a economical standpoint, at corpo level, rust would be a safer bet than c++
16:55 < bridge> <learath2> No matter how you look at it Rust is indeed a good replacement to C++
16:55 < bridge> <ryozuki> u cant expect all ur engineers to have a master level in c++ where they know wont do ub ever ever
16:56 < bridge> <ryozuki> like our chatters here
16:56 < bridge> <learath2> To C is a bit more doubtful. Embedded Rust didn't look very ergonomic last I took a look at it
16:56 < bridge> <ryozuki> its getting a bit better
16:56 < bridge> <ryozuki> u can follow the embedded rust newsletter
16:56 < bridge> <Jupstar ‚ú™> xD
16:56 < bridge> <Jupstar ‚ú™> our prophet has spoken
16:57 < bridge> <ryozuki> ok maybe its in TWIR
16:57 < bridge> <ryozuki> i read from time to in in rust reddit
16:57 < bridge> <ryozuki> https://github.com/rust-embedded/wg
16:58 < bridge> <ryozuki> i think the kernel is helping rust become a doable replacement
16:58 < bridge> <ryozuki> for example the try api for allocating
16:58 < bridge> <ryozuki> on some places
16:58 < bridge> <ryozuki> i forgor
16:59 < bridge> <ryozuki> https://github.com/rust-lang/rfcs/pull/2116
17:01 < bridge> <learath2> futex/waitonaddress? Any other way to achieve this without kernel help can't have very nice properties under contention I imagine
17:01 < bridge> <Fussel> `std::atomic`s
17:01 < bridge> <_voxeldoesart> post ddnet code in it and go "ugh.. too much c++ ü•±" and see if some madlad actually rewrites 300 files and over 8000 lines of code in rust
17:02 < bridge> <_voxeldoesart> post ddnet code in it and go "ugh.. too much c++ yawning_face" and see if some madlad actually rewrites 300 files and over 8000 lines of code in rust
17:02 < bridge> <_voxeldoesart> (wrong reply)
17:02 < bridge> <ryozuki> xd
17:02 < bridge> <ryozuki> there have been rust madlads
17:02 < bridge> <ryozuki> https://tenor.com/view/programming-rust-c-lang-cpp-cplusplus-gif-26743262
17:02 < bridge> <_voxeldoesart> if someone actually does that i would finally have respect
17:03 < bridge> <ryozuki> https://doc.rust-lang.org/std/sync/atomic/
17:04 < bridge> <learath2> In C++20 you can just wait on them, and that is implemented by futex/waitonaddress and if neither are available it'll poll with some backoff. Polling with backoff has very meh behaviour under contention. That's why I was curious
17:05 < bridge> <Jupstar ‚ú™> would you join that guy in a team as graphic designer if it were about teeworlds?
17:05 < bridge> <_voxeldoesart> i mean if it doesnt have to rely on backwards compat then maybe
17:05 < bridge> <Jupstar ‚ú™> epic
17:05 < bridge> <_voxeldoesart> ddnet is pretty much a fish out of water now
17:06 < bridge> <ryozuki> best language is assembly without libc
17:07 < bridge> <learath2> Only on processors with no pipelining, no reordering
17:07 < bridge> <Jupstar ‚ú™> speaking about critical sections:
17:07 < bridge> <Jupstar ‚ú™> i saw a blog about this benchmark
17:07 < bridge> <Jupstar ‚ú™> https://github.com/matklad/lock-bench
17:07 < bridge> <Jupstar ‚ú™> 
17:07 < bridge> <Jupstar ‚ú™> and then tested it on my pc:
17:07 < bridge> <Jupstar ‚ú™> ```
17:07 < bridge> <Jupstar ‚ú™> std::sync::Mutex     avg 15.508196ms  min 11.315727ms  max 16.916332ms 
17:07 < bridge> <Jupstar ‚ú™> parking_lot::Mutex   avg 172.935745ms min 161.698901ms max 182.067695ms
17:07 < bridge> <Jupstar ‚ú™> spin::Mutex          avg 15.546313ms  min 11.218683ms  max 37.585821ms 
17:07 < bridge> <Jupstar ‚ú™> AmdSpinlock          avg 14.614385ms  min 12.399496ms  max 18.728032ms 
17:07 < bridge> <Jupstar ‚ú™> 
17:07 < bridge> <Jupstar ‚ú™> std::sync::Mutex     avg 15.30766ms   min 12.545613ms  max 16.991576ms 
17:08 < bridge> <Jupstar ‚ú™> parking_lot::Mutex   avg 168.617568ms min 144.948258ms max 178.966609ms
17:08 < bridge> <Jupstar ‚ú™> spin::Mutex          avg 15.319146ms  min 12.435505ms  max 26.911885ms 
17:08 < bridge> <Jupstar ‚ú™> AmdSpinlock          avg 14.980674ms  min 12.09597ms   max 20.006563ms 
17:08 < bridge> <Jupstar ‚ú™> ```
17:08 < bridge> <Jupstar ‚ú™> 
17:08 < bridge> <Jupstar ‚ú™> 1. it's interesting that his spin locks are so insanely slow
17:08 < bridge> <Jupstar ‚ú™> 2. WTF is happening with parking_lot on my pc
17:08 < bridge> <Jupstar ‚ú™> my results are just completely different than his lmao
17:08 < bridge> <Jupstar ‚ú™> ^ above is extreme contention btw
17:09 < bridge> <Jupstar ‚ú™> i am only interesting in light contention, but wanted to test all out
17:09 < bridge> <learath2> 127ms waiting on a spin damn. Could it be an OS thing?
17:10 < bridge> <Jupstar ‚ú™> yeah very probably, but i once read that linux is actually not the best OS when it comes to spin, bcs of the thread schedular
17:10 < bridge> <Jupstar ‚ú™> bcs it cannot cleanly assume that a spinning thread can be paused
17:10 < bridge> <Jupstar ‚ú™> but i am on linux.. and it's super fast
17:10 < bridge> <Jupstar ‚ú™> üò¨
17:10 < bridge> <learath2> I remember a chromium bug that happened because the NT Kernel would preempt a thread right as it was about to start waiting on an uncontested mutex
17:11 < bridge> <ryozuki> i think they explained somewhere
17:11 < bridge> <ryozuki> but on recent rust std uses the futexes
17:11 < bridge> <ryozuki> 1.62
17:13 < bridge> <ryozuki> @learath2 u can change the scheduler when compiling kernel right
17:13 < bridge> <ryozuki> > New scheduler in Linux 6.6 will boost performance
17:13 < bridge> <ryozuki> > 
17:13 < bridge> <ryozuki> > A core element of any operating system are the scheduling systems, which organize and schedule how different operations will execute and in what order.
17:13 < bridge> <ryozuki> > 
17:13 < bridge> <ryozuki> > The Linux 6.6 kernel introduces the new Earliest Eligible Virtual Deadline First (EEVDF) scheduler that will replace the existing Completely Fair Scheduler (CFS) that has been the primary CPU scheduler since 2007.
17:13 < bridge> <ryozuki> > 
17:14 < bridge> <ryozuki> > EEVDF aims to improve on CFS in areas like latency handling to boost overall performance. EEVDF calculates a lag value for each process representing the difference between its allocated CPU time and how much it has actually received. Processes with positive lag are deemed ‚Äúeligible‚Äù to run. It also calculates a virtual deadline for each process based on its lag and assigned time slice. The scheduler runs the process with the earliest virtual 
17:14 < bridge> <ryozuki> > 
17:14 < bridge> <ryozuki> > By assigning smaller time slices to latency-sensitive processes, EEVDF can prioritize giving them quick access to the CPU when needed.
17:14 < bridge> <ryozuki> > 
17:14 < bridge> <ryozuki> > ‚ÄúIt completely reworks the base scheduler, placement, preemption, picking ‚Äî everything,‚Äù Kernel developer Peter Zijlstra wrote in a Linux kernel mailing list message comparing EEVDF to CFS. ‚ÄúThe only thing they have in common is that they‚Äôre both a virtual time-based scheduler.‚Äù
17:14 < bridge> <Jupstar ‚ú™> anyway, spin locks are still unbeatable if you don't expect contention on my PC.
17:14 < bridge> <Jupstar ‚ú™> 
17:14 < bridge> <Jupstar ‚ú™> parking_lot is very close.
17:14 < bridge> <Jupstar ‚ú™> 
17:14 < bridge> <Jupstar ‚ú™> so i guess i can live with using parking_lot in most my projects
17:14 < bridge> <Jupstar ‚ú™> 
17:14 < bridge> <Jupstar ‚ú™> üòè
17:15 < bridge> <learath2> I have a bizarre issue for years now. My computer only on linux will sometimes just randomly get huge iowait numbers on a device and stagger
17:15 < bridge> <learath2> I couldn't figure it out for the life of me. I have a feeling it's something about the io scheduler, but no idea what
17:16 < bridge> <Fussel> I had the need of many (hundrets to thousands) independent mutexes, but I had to save memory wherever I can in this class. `std::mutex` is 40 bytes iirc, that was way too much
17:16 < bridge> <learath2> Well ofc. Exactly why pthread mutexes will actually spin a couple times before yielding in most implementations
17:16 < bridge> <Jupstar ‚ú™> true, but rust std mutices/mutexes do that, apparently simply for a too short time (?)
17:16 < bridge> <Jupstar ‚ú™> bcs they are the worst of all 4 in the benchmark
17:17 < bridge> <learath2> Hm, I never looked into rust mutexes ngl
17:17 < bridge> <Jupstar ‚ú™> or they have other overhead üòÑ
17:17 < bridge> <ryozuki> what are iowait numbers? could this be due to ur old hdds?
17:18 < bridge> <learath2> It's an ssd that's having the huge iowait. But it is an old ssd so maybe. But under windows it never hangs like that
17:18 < bridge> <ryozuki> do u have noatime in ur fstab btw
17:19 < bridge> <ryozuki> https://wiki.gentoo.org/wiki/SSD
17:19 < bridge> <learath2> iowait is the amount of time the cpu is spending on waiting for io
17:19 < bridge> <Jupstar ‚ú™> what u done, if i may ask?
17:20 < bridge> <learath2> I should but I'll double check
17:20 < bridge> <Jupstar ‚ú™> i just want to know a use case of these amount of mutexes üòÑ
17:20 < bridge> <ryozuki> > For rootfs it is usually recommended to periodically use fstrim utility. Using the discard mount option results in continuous discard that could potentially cause degradation of older or poor-quality SSDs[5].
17:21 < bridge> <Fussel> @jupeyy_keks i had many, well, lets call it nodes of a graph (it's a possibility to view it), which got processed, while processing one usually lead to processing others. this all done multithreaded, so every node needed his own mutex
17:22 < bridge> <Fussel> @jupeyy_keks i had many, well, lets call it nodes of a graph (it's a possibility to view it), which got processed, while processing one usually lead to processing others. this all done multithreaded, so every node needed its own mutex
17:22 < bridge> <Jupstar ‚ú™> i c
17:22 < bridge> <ryozuki> @learath2 are compiler intrinsics smth in the standard in c and c++?
17:23 < bridge> <learath2> Ofc not
17:23 < bridge> <ryozuki> but can u expect smth portable across the same arch but different compilers
17:24 < bridge> <learath2> clang and gcc share some, but at the end of the day there is no guarantee for anything
17:24 < bridge> <learath2> If you want to support a compiler you'll need to add an ifdef for it
17:26 < bridge> <learath2> Compiler intrinsics are well extremely compiler specific üòÑ
17:28 < bridge> <learath2> Cool C++ feature of the day: `std::valarray`
17:28 < bridge> <Fussel> lol
17:28 < bridge> <learath2> It's very very unused, buuut both clang and llvm will vectorize it if it's a suitable size
17:29 < bridge> <learath2> both clang and gcc*
17:29 < bridge> <Fussel> Cool C++ misfeature of the day@ `std::vector<bool>`
17:29 < bridge> <ryozuki> is this different than a slice in || rust || ?
17:29 < bridge> <Fussel> Cool C++ misfeature of the day: `std::vector<bool>`
17:29 < bridge> <ryozuki> valarray
17:29 < bridge> <learath2> Yes, it has nothing to do with it
17:30 < bridge> <learath2> Slices in rust would maybe be like ranges in C++20
17:30 < bridge> <learath2> Valarrays are real vectors in the sense of vectors of linear algebra
17:30 < bridge> <learath2> You can add them, subtract them
17:30 < bridge> <ryozuki> ah i see
17:31 < bridge> <learath2> Who thought this was a good idea I wonder
17:32 < bridge> <ryozuki> "The problem is that the specialised version of std::vector<bool> provided by the Standard Library does not fulfil the requirements of a Standard Library container, and so is not guaranteed to work properly with the Standard Library algorithms."
17:32 < bridge> <ryozuki> quick google
17:33 < bridge> <ryozuki> is this whats this about
17:33 < bridge> <learath2> Yes, in C++98 someone decided it was a great idea to specialize vector so bools are stored in a bitset instead
17:34 < bridge> <teero777> ```cpp
17:34 < bridge> <teero777> struct Bool
17:34 < bridge> <teero777> {
17:34 < bridge> <teero777>     bool v;
17:34 < bridge> <teero777> } cool_bool;
17:34 < bridge> <teero777> ```
17:34 < bridge> <teero777> :troll:
17:34 < bridge> <learath2> But that breaks a lot of the promises containers make, so `std::vector<bool>` isn't eveb a standard container üòÑ
17:35 < bridge> <learath2> I wonder if this actually works. I doubt the compiler is allowed to see through your struct
17:35 < bridge> <Jupstar ‚ú™> better delete, before the overhead gang roasts you
17:35 < bridge> <learath2> This should be 0 overhead, worey not
17:35 < bridge> <learath2> Worry*
17:35 < bridge> <Jupstar ‚ú™> üò¨
17:35 < bridge> <Jupstar ‚ú™> lmao
17:35 < bridge> <Jupstar ‚ú™> he actually deleted
17:36 < bridge> <ryozuki> https://mlir.llvm.org/docs/Dialects/Vector/
17:36 < bridge> <ryozuki> something cool
17:36 < bridge> <ryozuki> i missed it
17:37 < bridge> <ryozuki> who posted? xd
17:37 < bridge> <Jupstar ‚ú™> secret
17:37 < bridge> <Jupstar ‚ú™> but he dared to add 3 bytes padding to a bool
17:38 < bridge> <learath2> It shouldn't get padded methinks
17:38 < bridge> <Jupstar ‚ú™> without packing?
17:39 < bridge> <learath2> A single member in a struct shouldn't get padded ever iirc
17:39 < bridge> <Fussel> they thought it would be smart to pack the bools into bits. on first glance it's an idea ‚Ä¶
17:39 < bridge> <Jupstar ‚ú™> not the member, but the whole struct, bcs of alignment requirements
17:40 < bridge> <learath2> The alignment requirement of a struct with one member is the members alignment requirement, no?
17:40 < bridge> <Jupstar ‚ú™> i dunno would be news to me
17:40 < bridge> <Jupstar ‚ú™> i'd have thought it's 4. bcs in c there is no bool and all other types have no size guarantee
17:40 < bridge> <Jupstar ‚ú™> or smth
17:41 < bridge> <Jupstar ‚ú™> on x86
17:41 < bridge> <Jupstar ‚ú™> but if not, then i learned smth new about cpp today
17:41 < bridge> <Jupstar ‚ú™> üò¨
17:42 < bridge> <ryozuki> it should
17:42 < bridge> <Jupstar ‚ú™> @learath2 do you check? else i do xd
17:42 < bridge> <Fussel> yes ^^
17:42 < bridge> <Jupstar ‚ú™> but my mouse partially broken
17:42 < bridge> <Jupstar ‚ú™> that's annoying
17:42 < bridge> <ryozuki> i have g502 hero
17:42 < bridge> <ryozuki> rustler mouse
17:43 < bridge> <Jupstar ‚ú™> i have that too tomorrow
17:43 < bridge> <ryozuki> nice
17:43 < bridge> <Jupstar ‚ú™> but i'll miss my old
17:43 < bridge> <teero777> razor viper v2 flex
17:43 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1184173657061335200/71g60fx8csL.png?ex=658b02a8&is=65788da8&hm=7571679175378c3a2c1fb3a6eee8e6c8a7405b4492fdb7701476dc98c0d3b886&
17:43 < bridge> <ryozuki> white looks cool
17:43 < bridge> <ryozuki> this is kda special
17:43 < bridge> <ryozuki> ew league
17:43 < bridge> <teero777> @jupeyy_keks will finally be good at gores :poggers:
17:43 < bridge> <Jupstar ‚ú™> i waited for this day for so long
17:44 < bridge> <ryozuki> closed source gores*
17:44 < bridge> <Jupstar ‚ú™> looks fancy
17:44 < bridge> <Jupstar ‚ú™> but doesnt fit my setup
17:44 < bridge> <Jupstar ‚ú™> yeah u right
17:44 < bridge> <Jupstar ‚ú™> interesting
17:44 < bridge> <Jupstar ‚ú™> and weird
17:44 < bridge> <teero777> razer viper v2 flex
17:44 < bridge> <ryozuki> why weird
17:44 < bridge> <ryozuki> @jupeyy_keks did u ever check the rust Layout struct
17:44 < bridge> <Jupstar ‚ú™> add 2 bools
17:44 < bridge> <Jupstar ‚ú™> to the struct
17:44 < bridge> <ryozuki> it has lot of fancy utilities
17:44 < bridge> <learath2> I checked too but I was on phone so too slow üòÑ
17:44 < bridge> <ryozuki> https://doc.rust-lang.org/std/alloc/struct.Layout.html
17:45 < bridge> <learath2> It still shouldn't tm get padded
17:45 < bridge> <Jupstar ‚ú™> add 1 bool and a short
17:45 < bridge> <teero777> https://www.razer.com/de-de/gaming-mice/razer-viper-v2-pro
17:45 < bridge> <learath2> Now that'll get padded
17:45 < bridge> <teero777> https://www.razer.com/en-en/gaming-mice/razer-viper-v2-pro
17:45 < bridge> <teero777> https://www.razer.com/gb-en/gaming-mice/razer-viper-v2-pro
17:46 < bridge> <teero777> https://www.razer.com/us-en/gaming-mice/razer-viper-v2-pro
17:46 < bridge> <teero777> https://www.razer.com/gb-en/gaming-mice/razer-viper-v2-pro
17:46 < bridge> <Jupstar ‚ú™> and that is nice?
17:46 < bridge> <teero777> very
17:47 < bridge> <teero777> have no trouble at all with this. i got it about 1y ago
17:47 < bridge> <teero777> very light very gud
17:47 < bridge> <teero777> even though 100‚Ç¨
17:48 < bridge> <teero777> now i need a >60hz display and ill be top10 in gores
17:48 < bridge> <ryozuki> mine has adjustable weight
17:48 < bridge> <ryozuki> i lost the weights tho
17:48 < bridge> <ryozuki> but i never used em
17:48 < bridge> <teero777> gj
17:48 < bridge> <learath2> I always use my mouse at max weight
17:48 < bridge> <teero777> bro is training
17:48 < bridge> <ryozuki> thats why u so bad at ddnet (jk)
17:49 < bridge> <learath2> I started playing games on an old wireless mouse that had two massive batteries in it that made it heavy asf
17:49 < bridge> <learath2> Now I need to mimic that same feeling to play üòÑ
17:49 < bridge> <Jupstar ‚ú™> quiz time
17:49 < bridge> <Jupstar ‚ú™> ```c++
17:49 < bridge> <Jupstar ‚ú™> struct s {
17:49 < bridge> <Jupstar ‚ú™>     bool a;
17:49 < bridge> <Jupstar ‚ú™>     short b;
17:49 < bridge> <Jupstar ‚ú™>     bool c;
17:49 < bridge> <Jupstar ‚ú™> };
17:49 < bridge> <Jupstar ‚ú™> 
17:49 < bridge> <Jupstar ‚ú™> struct t {
17:49 < bridge> <Jupstar ‚ú™>     s d;
17:49 < bridge> <Jupstar ‚ú™>     bool e;
17:49 < bridge> <Jupstar ‚ú™> };
17:49 < bridge> <Jupstar ‚ú™> ```
17:49 < bridge> <Jupstar ‚ú™> 
17:49 < bridge> <Jupstar ‚ú™> you have 10 seconds to answer
17:49 < bridge> <Jupstar ‚ú™> sizeof of struct
17:49 < bridge> <learath2> Which struct? S or t or both?
17:49 < bridge> <Jupstar ‚ú™> well t ofc
17:49 < bridge> <Jupstar ‚ú™> but u can also say both
17:50 < bridge> <learath2> I'd say sizeof t == ||6||
17:50 < bridge> <Fussel> 5 üôÇ
17:50 < bridge> <Fussel> 1 + 1(padding) + 2 +1
17:50 < bridge> <learath2> Wher spooler?
17:50 < bridge> <teero777> ||8||
17:50 < bridge> <Jupstar ‚ú™> answer is: 6
17:51 < bridge> <Fussel> for t? yes
17:51 < bridge> <ryozuki> ye 6 makes sense
17:51 < bridge> <learath2> I have a strong mental compiler
17:51 < bridge> <Fussel> i spoke about s ^^
17:51 < bridge> <teero777> hmmmm
17:51 < bridge> <teero777> https://cdn.discordapp.com/attachments/293493549758939136/1184175660906852392/image.png?ex=658b0486&is=65788f86&hm=981f66fe286985b10e27205e54158c4e97295207e705b4b561cdd2636a7f1b1a&
17:51 < bridge> <learath2> So you tried cheating :hmm:
17:51 < bridge> <Jupstar ‚ú™> ok now same question, but only for RUST, but in rust:
17:51 < bridge> <Jupstar ‚ú™> ```rs
17:51 < bridge> <Jupstar ‚ú™> struct s {
17:51 < bridge> <Jupstar ‚ú™>     a: bool,
17:51 < bridge> <Jupstar ‚ú™>     b: i16,
17:51 < bridge> <Jupstar ‚ú™>     c: bool,
17:51 < bridge> <Jupstar ‚ú™> }
17:51 < bridge> <Jupstar ‚ú™> ```
17:51 < bridge> <Jupstar ‚ú™> 
17:52 < bridge> <Jupstar ‚ú™> @learath2 @ryozuki
17:52 < bridge> <teero777> it was after!!
17:52 < bridge> <learath2> Only Allah knows how Rust lays out structs
17:52 < bridge> <Fussel> easy: just 1 MOV
17:52 < bridge> <Jupstar ‚ú™> s is also 6 btw
17:52 < bridge> <Jupstar ‚ú™> bcs of alignment
17:52 < bridge> <Jupstar ‚ú™> for x86 with current rust compiler
17:53 < bridge> <learath2> I still maintain my position üòÑ
17:53 < bridge> <Jupstar ‚ú™> 3
17:53 < bridge> <Jupstar ‚ú™> 2
17:53 < bridge> <Jupstar ‚ú™> 1
17:53 < bridge> <Jupstar ‚ú™> answer is: 4
17:53 < bridge> <ryozuki> sry i was in bath
17:53 < bridge> <Jupstar ‚ú™> rust is allowed to reorder
17:53 < bridge> <learath2> Yeah that would make sense. Rust doesnt mind reordering
17:53 < bridge> <ryozuki> room
17:53 < bridge> <ryozuki> rust ordering is not stable btw
17:54 < bridge> <ryozuki> it can change between compiler versions
17:54 < bridge> <Jupstar ‚ú™> it's ok, for our quiz it was stable
17:54 < bridge> <Jupstar ‚ú™> üòè
17:54 < bridge> <ryozuki> xd
17:54 < bridge> <learath2> Is there a way to force a certain order?
17:55 < bridge> <ryozuki> repr C
17:55 < bridge> <learath2> You sometimes want a specific order for it to be cache friendly
17:55 < bridge> <ryozuki> repr C
17:55 < bridge> <ryozuki> xd
17:55 < bridge> <ryozuki> https://doc.rust-lang.org/nomicon/other-reprs.html
17:55 < bridge> <Jupstar ‚ú™> you are the winner btw but psst
17:55 < bridge> <ryozuki> > This is the most important repr. It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C or C++. Any type you expect to pass through an FFI boundary should have repr(C), as C is the lingua-franca of the programming world. This is also necessary to soundly do more elaborate tricks with data layout such as reinterpreting values as a different type.
17:56 < bridge> <Jupstar ‚ú™> answer is: 6 for s, 8 for t
17:56 < bridge> <ryozuki> there is also repr(align(n))
17:57 < bridge> <learath2> Fwiw I don't really understand this one actually
17:57 < bridge> <Jupstar ‚ú™> @learath2 can you explain why t is not allowed to optimize it?
17:58 < bridge> <learath2> Oh actually I do understand it nvm üòÑ
17:58 < bridge> <learath2> My brain just miscompiled it
17:59 < bridge> <learath2> It can't optimize because s has already been padded and you can access t by using a pointer to s due to the common initial sequence rule
18:00 < bridge> <Jupstar ‚ú™> will rust optimize the size or not?
18:00 < bridge> <Jupstar ‚ú™> 
18:00 < bridge> <Jupstar ‚ú™> ```rs
18:00 < bridge> <Jupstar ‚ú™> struct s {
18:00 < bridge> <Jupstar ‚ú™>     a: bool,
18:00 < bridge> <Jupstar ‚ú™>     b: i16,
18:00 < bridge> <Jupstar ‚ú™> }
18:00 < bridge> <Jupstar ‚ú™> 
18:00 < bridge> <Jupstar ‚ú™> struct t {
18:01 < bridge> <Jupstar ‚ú™>     a: s,
18:01 < bridge> <Jupstar ‚ú™>     c: bool,
18:01 < bridge> <Jupstar ‚ú™> }
18:01 < bridge> <Jupstar ‚ú™> ```
18:01 < bridge> <Jupstar ‚ú™> s was previously 4, when c was in s
18:01 < bridge> <Jupstar ‚ú™> is t:
18:01 < bridge> <Jupstar ‚ú™> - still 4
18:01 < bridge> <Jupstar ‚ú™> - 6
18:03 < bridge> <learath2> @ryozuki you answer, ur the rust guy
18:03 < bridge> <ryozuki> it will reorder s probs
18:04 < bridge> <ryozuki> b -> a
18:04 < bridge> <ryozuki> idk
18:04 < bridge> <ryozuki> xd
18:04 < bridge> <Jupstar ‚ú™> my compiler says: 6
18:04 < bridge> <learath2> I would say 6 aswell
18:04 < bridge> <Jupstar ‚ú™> ok one last about cpp again
18:04 < bridge> <Jupstar ‚ú™> ```cpp
18:04 < bridge> <Jupstar ‚ú™> #pragma pack(1)
18:04 < bridge> <Jupstar ‚ú™> struct s {
18:04 < bridge> <Jupstar ‚ú™>     short a;
18:04 < bridge> <Jupstar ‚ú™>     bool b;
18:04 < bridge> <Jupstar ‚ú™> };
18:05 < bridge> <Jupstar ‚ú™> 
18:05 < bridge> <Jupstar ‚ú™> struct t {
18:05 < bridge> <Jupstar ‚ú™>     s mystruct;
18:05 < bridge> <Jupstar ‚ú™>     bool c;
18:05 < bridge> <Jupstar ‚ú™> };
18:05 < bridge> <Jupstar ‚ú™> ```
18:05 < bridge> <Jupstar ‚ú™> 
18:05 < bridge> <Jupstar ‚ú™> size of t AND s
18:05 < bridge> <learath2> 3 and 4
18:05 < bridge> <ryozuki> 3 and 4 too
18:05 < bridge> <ryozuki> xd
18:05 < bridge> <learath2> ||3 and 4||
18:05 < bridge> <Jupstar ‚ú™> ez, correct answer
18:05 < bridge> <learath2> Noooo I forgor spoolers
18:05 < bridge> <ryozuki> is pragma pack standard
18:05 < bridge> <learath2> Nope
18:06 < bridge> <ryozuki> @jupeyy_keks rust has packed too
18:06 < bridge> <ryozuki> where rust shines is in niche optimizations
18:06 < bridge> <ryozuki> specially in enums
18:06 < bridge> <learath2> So on a compiler that doesnt support it it's 4 and 8?
18:07 < bridge> <ryozuki> size of `Option<Box<T>>`
18:07 < bridge> <Jupstar ‚ú™> troll
18:07 < bridge> <learath2> 4 and 6 actually, 6 is enough
18:07 < bridge> <Jupstar ‚ú™> NonZeroU64?
18:07 < bridge> <ryozuki> its pointer sized
18:07 < bridge> <Jupstar ‚ú™> ah true
18:07 < bridge> <Jupstar ‚ú™> u wrote box
18:07 < bridge> <Jupstar ‚ú™> lmao
18:07 < bridge> <ryozuki> none uses the nullptr value
18:07 < bridge> <ryozuki> that box can never have
18:07 < bridge> <Jupstar ‚ú™> yeah
18:07 < bridge> <Jupstar ‚ú™> 32bit or 64bit
18:07 < bridge> <Jupstar ‚ú™> üòè
18:07 < bridge> <ryozuki> so it has no tag
18:08 < bridge> <ryozuki> the enum
18:08 < bridge> <learath2> Is this optimization available to users of the language?
18:08 < bridge> <ryozuki> @jupeyy_keks thats why i said pointer sized
18:08 < bridge> <patiga> in Rust, when specifying dependencies: should I always use the lowest possible SemVer-compatible version?
18:08 < bridge> <patiga> imo it would make sense, since you have all the features you need yourself and get maximum compatibilty with other libraries with the same dependency
18:08 < bridge> <patiga> yes, through NonZero types
18:08 < bridge> <learath2> Or is it something only compiler black magic can accomplish?
18:08 < bridge> <learath2> Ah cool
18:08 < bridge> <ryozuki> mno, its done by the compiler through builtin types
18:08 < bridge> <ryozuki> nonzore is builtin ye
18:08 < bridge> <ryozuki> zero
18:08 < bridge> <ryozuki> cant type
18:08 < bridge> <ryozuki> NonNull exists for pointers too
18:08 < bridge> <ryozuki> box would be props a NonNull
18:08 < bridge> <learath2> Oh, so can't you implement a NonZero type yourself?
18:09 < bridge> <ryozuki> https://doc.rust-lang.org/std/ptr/struct.NonNull.html
18:09 < bridge> <ryozuki> no sadly
18:09 < bridge> <ryozuki> soon u will
18:09 < bridge> <Jupstar ‚ú™> that would be insane
18:09 < bridge> <ryozuki> its a nightly feature
18:09 < bridge> <ryozuki> range types
18:09 < bridge> <learath2> 0 overhead Options for all
18:09 < bridge> <ryozuki> ada has this btw!
18:10 < bridge> <Fussel> curious but true, I was never interested in trailing paddings ^^
18:10 < bridge> <patiga> I don't understand, what kind of type would you want to implement?
18:10 < bridge> <Jupstar ‚ú™> i mean u could say that's why cargo.lock exists?
18:10 < bridge> <Jupstar ‚ú™> or do i get your question wrong
18:11 < bridge> <learath2> `MyCoolNonZeroBigInteger` e.g.
18:12 < bridge> <Jupstar ‚ú™> u always want to purposely use lower version, so cargo can decide to use a newer one if a dep has a newer one?
18:12 < bridge> <Jupstar ‚ú™> ok maybe i am too confused
18:14 < bridge> <learath2> Another cool thing could be to let me have the option bool inside my own struct, like an intrusive option
18:14 < bridge> <ryozuki> @learath2 if ur interested in the optimizations rust does check out https://research.checkpoint.com/2023/rust-binary-analysis-feature-by-feature/
18:14 < bridge> <learath2> E.g. I have a nonzero value at the start of my struct, you can use the zero of that and I save a byte or 4 depending on alignment
18:14 < bridge> <ryozuki> it shows a lot of them
18:15 < bridge> <ryozuki> its a rly interesting blog
18:15 < bridge> <ryozuki> > You attempt to analyze a binary file compiled in the Rust programming language. You open the file in your favorite disassembler. Twenty minutes later you wish you had never been born.
18:15 < bridge> <ryozuki> > 
18:15 < bridge> <ryozuki> > You‚Äôve trained yourself to think like g++ and msvc: Here‚Äôs a loop, there‚Äôs a vtable, that‚Äôs a global variable, a library function, an exception. Now you need to think like the Rust compiler. Maybe you‚Äôve heard about ‚Äúsum types‚Äù and ‚Äúgenerics‚Äù and ‚Äúiterators‚Äù, maybe you haven‚Äôt, and in both cases you are going to have an exceptionally bad time.
18:16 < bridge> <learath2> Or even 7/15 bytes in the worst case
18:17 < bridge> <Jupstar ‚ú™> u can do that in cpp right?
18:17 < bridge> <Jupstar ‚ú™> 
18:17 < bridge> <Jupstar ‚ú™> if you mean that
18:17 < bridge> <Jupstar ‚ú™> https://en.cppreference.com/w/cpp/language/bit_field
18:17 < bridge> <learath2> I meant as in zero storage cost wrapping my struct in an `Option`
18:18 < bridge> <Jupstar ‚ú™> ah yeah, but this sounded like it
18:18 < bridge> <Jupstar ‚ú™> u kinda would reserve the space
18:18 < bridge> <Jupstar ‚ú™> xd
18:18 < bridge> <learath2> An extra 17 bytes just to add a bool could actually be very meh for the cache depending on the size of the struct
18:18 < bridge> <Jupstar ‚ú™> i dunno how you would imagine that feature, but sounds interesting
18:18 < bridge> <learath2> 15*
18:18 < bridge> <patiga> (was distracted for a few mins) oooh, your own types which can be wrapped into bools with no size changes. I thought that this is something Rust already does, by giving you no specifications about your struct layout and taking freedoms such as this one.
18:18 < bridge> <patiga> e.g. if you have a non-zero member in your struct, I would've assumed Rust will optimize your Option of that struct by itself. (not just Option but any other enums)
18:19 < bridge> <learath2> Idk maybe the compiler can optimize to use any NonZero value inside the struct?
18:20 < bridge> <learath2> I'm not very familiar with the very low levels of Rust but it would be nice to have these sorts of things especially when layout is crucial
18:20 < bridge> <Jupstar ‚ú™> but when do u ever need the layout of option
18:21 < bridge> <patiga> I think `Cargo.lock` was just to record the very specific dependency list for the last successful build
18:21 < bridge> <patiga> (was distracted for a few mins) oooh, your own types which can be wrapped into Options with no size changes. I thought that this is something Rust already does, by giving you no specifications about your struct layout and taking freedoms such as this one.
18:21 < bridge> <patiga> e.g. if you have a non-zero member in your struct, I would've assumed Rust will optimize your Option of that struct by itself. (not just Option but any other enums)
18:21 < bridge> <patiga> edit: bool -> Option
18:21 < bridge> <Jupstar ‚ú™> but why can u then do cargo update
18:21 < bridge> <Jupstar ‚ú™> i think it's simply for shared deps version control
18:22 < bridge> <Jupstar ‚ú™> as in: everyone who uses your project will have the same deps
18:22 < bridge> <patiga> I'm not sure. My current understanding is, that it gives you less compatibility with other libs
18:22 < bridge> <Jupstar ‚ú™> some day you should show me an example for a struct that has more than 1 member
18:22 < bridge> <Jupstar ‚ú™> maybe i understand it then
18:22 < bridge> <Jupstar ‚ú™> generally sounds useful, but cannot really imagine what exactly you meant üòÑ
18:22 < bridge> <patiga> since when you specify `1.2.3`, you are no longer compatible with `1.2.2`
18:23 < bridge> <ryozuki> `Option<Option<Option<i64>>>` whats the size of this
18:23 < bridge> <patiga> 9
18:23 < bridge> <patiga> ||9||
18:23 < bridge> <Jupstar ‚ú™> well cannot answer it then. i thought patch versions dont matter?
18:23 < bridge> <Jupstar ‚ú™> 
18:23 < bridge> <Jupstar ‚ú™> at least cargo upgrade simply upgrades them without any flag
18:24 < bridge> <Jupstar ‚ú™> it doesnt define those as breaking changes
18:24 < bridge> <ryozuki> and `Option<Option<Option<Option<i64>>>>`
18:24 < bridge> <ryozuki> result: || both are 16 ||
18:24 < bridge> <patiga> you scare me ||I'd still say 9||
18:24 < bridge> <patiga> huh
18:24 < bridge> <patiga> a, fair
18:24 < bridge> <Jupstar ‚ú™> 16 or 12
18:24 < bridge> <Jupstar ‚ú™> xd
18:24 < bridge> <Jupstar ‚ú™> but 16
18:24 < bridge> <Jupstar ‚ú™> bcs algin
18:24 < bridge> <Jupstar ‚ú™> bcs align
18:24 < bridge> <patiga> yea, I forgot align
18:24 < bridge> <ryozuki> btw Option<i64> is 16 too
18:25 < bridge> <learath2> You know how `Option<Box<T>>` has the same  size as `Box<T>`? I was just curious if one could have a similar thing for any type `K`
18:25 < bridge> <Jupstar ‚ú™> @ryozuki try to do the same for NonZeroU64
18:25 < bridge> <Jupstar ‚ú™> 
18:25 < bridge> <Jupstar ‚ú™> and additionally add so many Option< until it breaks the compiler
18:25 < bridge> <Jupstar ‚ú™> into thinking it has overhead
18:26 < bridge> <patiga> in the `Cargo.toml` you specify the minimum depency like that
18:26 < bridge> <ryozuki> 16
18:26 < bridge> <ryozuki> 8 if 1 option
18:26 < bridge> <Jupstar ‚ú™> yeah, but i'd like to see the syntax for how to define it for K.
18:26 < bridge> <Jupstar ‚ú™> 
18:26 < bridge> <Jupstar ‚ú™> It sounds useful, but for a struct with many members, it kinda sounds non trivial
18:26 < bridge> <Jupstar ‚ú™> just curious
18:26 < bridge> <Jupstar ‚ú™> OH
18:26 < bridge> <Jupstar ‚ú™> that's indeed interesting
18:26 < bridge> <Jupstar ‚ú™> @learath2 also interesting for you üò¨
18:27 < bridge> <ryozuki> https://github.com/BenH11235/rust-re-tour/blob/main/other_sample_programs/truly_pathological_sum_types/src/main.rs
18:27 < bridge> <ryozuki> check this out
18:27 < bridge> <Jupstar ‚ú™> do all libs generally do that? üòÑ
18:27 < bridge> <learath2> Any NonZero member no matter how deeply nested could be a candidate for the presence flag
18:27 < bridge> <Jupstar ‚ú™> what is a lib requires the patch version of another @patiga üòÑ
18:27 < bridge> <ryozuki> xd
18:28 < bridge> <Jupstar ‚ú™> ah i see
18:28 < bridge> <Jupstar ‚ú™> intersting
18:28 < bridge> <Jupstar ‚ú™> kind of automatic
18:28 < bridge> <learath2> I've had cargo pull in multiple versions of a lib. That is rather annoying behaviour
18:29 < bridge> <Jupstar ‚ú™> do you even speak about a binary, or about a lib?
18:30 < bridge> <ryozuki> given
18:30 < bridge> <ryozuki> ```rust
18:30 < bridge> <ryozuki> pub struct String {
18:30 < bridge> <ryozuki>     vec: Vec<u8>,
18:30 < bridge> <ryozuki> }
18:30 < bridge> <ryozuki> ``` which has a size of 24
18:30 < bridge> <ryozuki> its option<string> is also 2
18:30 < bridge> <ryozuki> 24
18:30 < bridge> <learath2> OH, how does this one happen?
18:31 < bridge> <ryozuki> the string ptr
18:31 < bridge> <ryozuki> the vec ptr
18:31 < bridge> <ryozuki> *
18:31 < bridge> <ryozuki> ```rust
18:31 < bridge> <ryozuki> pub(crate) struct RawVec<T, A: Allocator = Global> {
18:31 < bridge> <ryozuki>     ptr: Unique<T>,
18:31 < bridge> <ryozuki>     cap: usize,
18:31 < bridge> <ryozuki>     alloc: A,
18:31 < bridge> <ryozuki> }
18:31 < bridge> <ryozuki> ```
18:31 < bridge> <Jupstar ‚ú™> i think for binaries i'd use latest semver
18:31 < bridge> <Jupstar ‚ú™> for libs maybe caret
18:31 < bridge> <ryozuki> ```rust
18:31 < bridge> <ryozuki> pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
18:31 < bridge> <ryozuki>     buf: RawVec<T, A>,
18:31 < bridge> <ryozuki>     len: usize,
18:31 < bridge> <ryozuki> }
18:31 < bridge> <ryozuki> ```
18:31 < bridge> <Jupstar ‚ú™> don't trust me tho
18:31 < bridge> <Jupstar ‚ú™> trust @ryozuki
18:31 < bridge> <Jupstar ‚ú™> he knows anything
18:32 < bridge> <learath2> So there is some magic in the compiler that can do the optimization I was curious about?
18:32 < bridge> <ryozuki> yes
18:32 < bridge> <patiga> lib
18:32 < bridge> <learath2> That's cute. I wonder what the requirements are
18:32 < bridge> <patiga> yes
18:33 < bridge> <Jupstar ‚ú™> mh ok
18:33 < bridge> <patiga> the build system tries to find a compatible version with semver versioning
18:34 < bridge> <Jupstar ‚ú™> yeah but like: what if you lib doesn't work with some unpatched version
18:34 < bridge> <ryozuki> ```rust
18:34 < bridge> <ryozuki> enum SumType2 {
18:34 < bridge> <ryozuki>     OneOption(i64),
18:34 < bridge> <ryozuki>     AnotherOption(String)
18:34 < bridge> <ryozuki> }
18:34 < bridge> <ryozuki> ```
18:34 < bridge> <ryozuki> size of this?
18:34 < bridge> <ryozuki> given string is 24
18:34 < bridge> <ryozuki> || > What‚Äôs happened here is that the compiler, in its quest for memory efficiency, has decided that it‚Äôs not going to do with 4 fields what it can do with 3. Instead of keeping a separate tag field, the compiler figured that it can piggyback off the String structure‚Äôs buf pointer. In case of AnotherOption, this pointer can‚Äôt be 0 (Rust doesn‚Äôt support that ‚Äúfeature‚Äù), so the possible value 0 is instead appropriated to signify‚Äùthis 
18:34 < bridge> <ryozuki> || its 24 ||
18:35 < bridge> <patiga> what is a unpatched version?
18:35 < bridge> <ryozuki> i would say no and heinrich agrees with this iirc
18:35 < bridge> <ryozuki> unless u want compat with old rust compilers
18:35 < bridge> <patiga> ah, so my mental image was correct after all ^^
18:35 < bridge> <Jupstar ‚ú™> well lets say you use library `a` and in version 1.0.0 the library crashes for you
18:35 < bridge> <Jupstar ‚ú™> 
18:35 < bridge> <Jupstar ‚ú™> but in 1.0.1 it's fixed
18:35 < bridge> <Jupstar ‚ú™> 
18:35 < bridge> <Jupstar ‚ú™> i'd write "^1.0.1"
18:35 < bridge> <Jupstar ‚ú™> and break compability
18:35 < bridge> <ryozuki> eh
18:37 < bridge> <Jupstar ‚ú™> really?
18:37 < bridge> <Jupstar ‚ú™> heinrich agrees with that?
18:37 < bridge> <Jupstar ‚ú™> wow
18:37 < bridge> <Jupstar ‚ú™> i'd really not expect that
18:37 < bridge> <patiga> for what reason?
18:37 < bridge> <Jupstar ‚ú™> that would be out of his character üòÇ
18:38 < bridge> <patiga> hm I'd hope that the dependency resolution choosea the highest version
18:38 < bridge> <Jupstar ‚ú™> why should it
18:39 < bridge> <Jupstar ‚ú™> or differently:
18:39 < bridge> <Jupstar ‚ú™> why should it without cargo update
18:39 < bridge> <patiga> coz it should be compatible and higher version = good ^^
18:39 < bridge> <Jupstar ‚ú™> and does it do that everytime u add a library, for all libraries?
18:40 < bridge> <Jupstar ‚ú™> what if two libs use a
18:40 < bridge> <Jupstar ‚ú™> so a is already in cargo.lock
18:40 < bridge> <patiga> cargo.lock has no say over the version afiak
18:40 < bridge> <Jupstar ‚ú™> it's a funny problem, i never thought about it lmao
18:40 < bridge> <Jupstar ‚ú™> no but if it's already in as version 1.0.0
18:40 < bridge> <Jupstar ‚ú™> 
18:40 < bridge> <Jupstar ‚ú™> what updates it?
18:41 < bridge> <Jupstar ‚ú™> cargo add yourlib?
18:41 < bridge> <ryozuki> it does
18:41 < bridge> <patiga> you specify stuff in cargo.toml, cargo.lock ist just kind of a log
18:41 < bridge> <ryozuki> actually no
18:41 < bridge> <ryozuki> if lock says X version it will use that
18:41 < bridge> <ryozuki> u need to cargo update
18:41 < bridge> <ryozuki> to update the lock
18:42 < bridge> <patiga> maybe cargo clean is enough? ^^
18:42 < bridge> <ryozuki> lock is only modified by cargo build if cargo toml version is totally incompatible
18:42 < bridge> <ryozuki> it isnt
18:42 < bridge> <ryozuki> cargo.lock stays between cleans
18:42 < bridge> <patiga> huh, interesting
18:42 < bridge> <ryozuki> a clean cargo build uses lockfile
18:42 < bridge> <ryozuki> use cargo update to truly update
18:42 < bridge> <Jupstar ‚ú™> cargo.lock generally is smth you also upload to repos, isnt it?
18:42 < bridge> <ryozuki> yes
18:42 < bridge> <ryozuki> if u want reproducible builds (idk if totally reproducible)
18:42 < bridge> <patiga> but at least other libs depending on you don't care about cargo.lock afaik
18:42 < bridge> <ryozuki> no for libs it isnt
18:43 < bridge> <ryozuki> is only for final bins
18:43 < bridge> <patiga> yea
18:43 < bridge> <Jupstar ‚ú™> and it can be annoying if two maintainers do cargo update üò¨
18:43 < bridge> <ryozuki> cargo new --lib gitignores the lock
18:43 < bridge> <Jupstar ‚ú™> but that's a different problem xDD
18:43 < bridge> <Jupstar ‚ú™> i had it once
18:43 < bridge> <ryozuki> tho u may want the lockfile in a lib
18:43 < bridge> <patiga> sry I don't understand your question
18:43 < bridge> <ryozuki> to have reliable ci
18:43 < bridge> <Jupstar ‚ú™> if `a` is in cargo.lock as version 1.0.0
18:43 < bridge> <Jupstar ‚ú™> 
18:43 < bridge> <Jupstar ‚ú™> and you add your lib
18:44 < bridge> <Jupstar ‚ú™> cargo add yourlib
18:44 < bridge> <patiga> thats why I don't get why you should cargo update
18:44 < bridge> <Jupstar ‚ú™> do you think `a` in cargo.lock gets updated in this moment
18:44 < bridge> <Jupstar ‚ú™> well everything is a trade
18:44 < bridge> <Jupstar ‚ú™> reproducable builds = same behavior
18:44 < bridge> <Jupstar ‚ú™> i guess most ppl prefer that
18:44 < bridge> <Jupstar ‚ú™> over a patched library
18:45 < bridge> <Jupstar ‚ú™> over a patched/up-to-date library
18:45 < bridge> <milkeeycat> @deen what rooms were you talking about ü§î
18:45 < bridge> <patiga> if I have a as 1.0.0 and someone depends on my crate, they might have a= 1.9.15 in their cargo.lock I think
18:46 < bridge> <Jupstar ‚ú™> yes but what if not
18:46 < bridge> <Jupstar ‚ú™> and your lib crashes on 1.0.0
18:46 < bridge> <patiga> then it crashes
18:46 < bridge> <Jupstar ‚ú™> lmao
18:47 < bridge> <patiga> thats why I hope that it chooses the highest available version
18:47 < bridge> <Jupstar ‚ú™> i personally would always use a version i tested with tbh
18:47 < bridge> <patiga> but I guess if ryo looked it up, it uses the lowest compatible ine
18:47 < bridge> <patiga> *one
18:48 < bridge> <Jupstar ‚ú™> i dunno what cargo's behavior is, but if your lib uses 1.0.2
18:48 < bridge> <Jupstar ‚ú™> and another 1.0.1
18:48 < bridge> <Jupstar ‚ú™> 
18:48 < bridge> <Jupstar ‚ú™> why should it not use 1.0.2 for the other too anyway following your argumentation?
18:48 < bridge> <Jupstar ‚ú™> in worse case you'd have updated the cargo.toml of someone else
18:49 < bridge> <patiga> that is exactly what the dependency resolution does
18:49 < bridge> <patiga> but true
18:49 < bridge> <patiga> I didn't see the symmetry
18:50 < bridge> <patiga> the highest version should be just as compatible as the lowest version
18:50 < bridge> <Jupstar ‚ú™> yeah üòÑ
18:50 < bridge> <Jupstar ‚ú™> 
18:50 < bridge> <Jupstar ‚ú™> but still interesting question
18:51 < bridge> <Jupstar ‚ú™> i never really thought about it
18:51 < bridge> <Jupstar ‚ú™> guess i'd be a bad lib maintainer xdd
18:52 < bridge> <patiga> xd
18:53 < bridge> <ryozuki> no, it uses highest compat one without a pre existing lockfile
18:53 < bridge> <ryozuki> then it writes lockfile with it
18:54 < bridge> <ryozuki> im in mobile  rn and frustrated typing here xd
18:54 < bridge> <patiga> üëç thats sensible behavior
18:54 < bridge> <patiga> same :p
18:54 < bridge> <Jupstar ‚ú™> i have no working mouse, does that count too?
18:54 < bridge> <ryozuki> with pre existing lockfile it will only update if carg toml has a version higher
18:55 < bridge> <ryozuki> and write to lockfile
18:55 < bridge> <patiga> no slacking allowed here, go grab your mobile
19:48 < bridge> <ryozuki> @_voxeldoesart https://future.mozilla.org/blog/introducing-memorycache/
19:48 < bridge> <ryozuki> > Augmenting Local AI with Browser Data: Introducing MemoryCache
19:49 < bridge> <ryozuki> https://www.phoronix.com/news/FFmpeg-CLI-MT-Merged
19:55 < bridge> <Jupstar ‚ú™> s is 6 btw
20:15 < bridge> <_voxeldoesart> wait so what even is the usecase??
20:16 < bridge> <_voxeldoesart> is firefox just making a "haha we know your browser history" extension
20:16 < bridge> <ryozuki> no it doesnt share history data
20:16 < bridge> <ryozuki> its a local ai
20:16 < bridge> <ryozuki> local on ur device
20:17 < bridge> <ryozuki> > MemoryCache is an early exploration project from the Mozilla Innovation Ecosystem team that augments an on-device, personal model with local files saved from the browser to reflect a more personalized and tailored experience through the lens of privacy and agency.
20:17 < bridge> <ryozuki> > oday, MemoryCache is a set of scripts and simple tools to augment a local copy of privateGPT. The project contains:
20:17 < bridge> <ryozuki> > 
20:17 < bridge> <ryozuki> >     A Firefox extension that acts as a simple "printer" to save pages to a subdirectory in your /Downloads/ folder, and includes the ability to quickly save notes and information from your browser to your local machine
20:17 < bridge> <ryozuki> >     A shell script that listens for changes in the /Downloads/MemoryCache directory and runs the privateGPT ingest.py script
20:17 < bridge> <ryozuki> >     Code to (optionally) update the Firefox SaveAsPDF API on a local build of Firefox to enable a flag that silently saves webpages as PDF for easier human readability (by default, pages need to be saved as HTML in Firefox)
20:17 < bridge> <_voxeldoesart> i dont need a personalized browser that doesnt even know me
20:18 < bridge> <ryozuki> i would like it
20:18 < bridge> <ryozuki> for example to ask
20:18 < bridge> <ryozuki> "that blog about rust in the past about niche optimizations"
20:18 < bridge> <ryozuki> and it finds it for me in my history
20:19 < bridge> <_voxeldoesart> i mean you can just
20:19 < bridge> <_voxeldoesart> use your brain
20:19 < bridge> <ryozuki> :pepeW:
20:20 < bridge> <_voxeldoesart> that has to be the most useless executive flytrap idea yet
20:20 < bridge> <_voxeldoesart> ai browser history
20:21 < bridge> <cyberfighter> lol
20:23 < bridge> <_voxeldoesart> if people actually need a machine to refind something for them then we're doomed as a society
20:32 < bridge> <robyt3> Like using bookmarks instead of remember the full URLs? Or using the search function instead of scrolling through the whole history manually to find something? What's so different about using "AI" to perform a fuzzy search of your history instead of doing a keyword based search?
20:33 < bridge> <Jupstar ‚ú™> you can sell the AI thing to the AI enjoyers
20:34 < bridge> <Jupstar ‚ú™> while the other is boring
20:34 < bridge> <Jupstar ‚ú™> you can sell the other to voxel, bcs it's no AI
20:34 < bridge> <robyt3> That's why I asked, he said needing a machine is bad, but I doubt he doesn't use bookmarks
20:35 < bridge> <Jupstar ‚ú™> i use no bookmarks xdd
20:35 < bridge> <_voxeldoesart> because at least with bookmarks you're actually in control of what you want to save. the ai is just going to think its helping but it could very well be a gateway to advertizing
20:36 < bridge> <robyt3> Do you have 1000 tabs open or search your history every time? :justatest:
20:36 < bridge> <_voxeldoesart> id rather be boring than not used by copper and wires
20:36 < bridge> <Jupstar ‚ú™> in fact i use anonym tab most of the time, bcs google gives worse results when i already searched something
20:36 < bridge> <Jupstar ‚ú™> so i dont even have a huge browser history
20:37 < bridge> <robyt3> How do you refind something that you looks at earlier?
20:37 < bridge> <robyt3> How do you refind something that you looked at earlier?
20:37 < bridge> <Jupstar ‚ú™> i look in my brain
20:37 < bridge> <Jupstar ‚ú™> üò¨
20:37 < bridge> <robyt3> :pepeW:
20:37 < bridge> <_voxeldoesart> at max i have 20 tabs open but i get overwhelmed by that amount and close the entire session and reopen to a blank slate
20:38 < bridge> <Jupstar ‚ú™> i also often do that xD
20:38 < bridge> <Jupstar ‚ú™> i hate many tabs
20:38 < bridge> <_voxeldoesart> same
20:38 < bridge> <_voxeldoesart> mostly by remembering
20:38 < bridge> <Jupstar ‚ú™> i also rarely reread stuff, or delay reading stuff
20:38 < bridge> <Jupstar ‚ú™> 
20:38 < bridge> <Jupstar ‚ú™> either i read it, or idc xD
20:40 < bridge> <robyt3> I often have bookmark folders for info about various games that I sometimes start playing again, I don't really remember all the links otherwise if I don't play regularly
20:40 < bridge> <Jupstar ‚ú™> i wish i could be that organized xD
20:40 < bridge> <Jupstar ‚ú™> i am way to lazy for that
20:41 < bridge> <robyt3> It's still a mess, but an organized one
20:41 < bridge> <learath2> The difference is Voxel hates AI
20:42 < bridge> <Jupstar ‚ú™> at least he makes us think so
20:42 < bridge> <learath2> I regularly abuse google as that browser history ai so I welcome the addition
20:43 < bridge> <louis> explain how a local ai that helps u search ur history leads to advertising
20:43 < bridge> <learath2> I usually remember only keywords about blogposts I've read. E.g. ETW, chromium, nt kernel, bug, asciirandom
20:44 < bridge> <learath2> I guess it could have secret bias towards companies that pay more, idk if that's possible given it's probably open source
20:45 < bridge> <_voxeldoesart> biased results towards mozilla afilliated links?? idk
20:46 < bridge> <_voxeldoesart> no, i Know so, because you guys are a slap in the face as to why i should be against it
20:47 < bridge> <Jupstar ‚ú™> it's ok honey, you already admited to me that you like AI
20:47 < bridge> <Jupstar ‚ú™> u even showed me some tool that uses AI
20:47 < bridge> <jxsl13> what's the url of the ddnet http master server for fetching the json data?
20:47 < bridge> <ryozuki> same
20:47 < bridge> <_voxeldoesart> which was that again
20:47 < bridge> <ryozuki> i also have a big bookmark folder with manga
20:47 < bridge> <_voxeldoesart> oh yea
20:47 < bridge> <Jupstar ‚ú™> the music thing
20:47 < bridge> <Jupstar ‚ú™> cant remember exactly
20:47 < bridge> <ryozuki> :NekoEvil:
20:48 < bridge> <_voxeldoesart> difference was i was in control
20:48 < bridge> <robyt3> https://master1.ddnet.org/ddnet/15/servers.json and https://info.ddnet.org/info
20:48 < bridge> <jxsl13> thanks
20:48 < bridge> <Jupstar ‚ú™> fine by me üòÑ
20:48 < bridge> <ryozuki> :danger: dont bookmark it :danger:
20:49 < bridge> <jxsl13> what's the difference?
20:49 < bridge> <jxsl13> one being official ddnet servers?
20:49 < bridge> <jxsl13> other the rest?
20:49 < bridge> <Jupstar ‚ú™> the funny thing is, i sometimes google them bcs i forget the URL xD
20:49 < bridge> <cyberfighter> ill bookmark them all
20:49 < bridge> <jxsl13> ok, one has player info
20:49 < bridge> <robyt3> Depends on what you need, one is the list of servers with all the server info, the other is the ddnet info json
20:50 < bridge> <Jupstar ‚ú™> like no one ever was
20:50 < bridge> <jxsl13> all servers with playercount is what I need
20:51 < bridge> <Jupstar ‚ú™> servers.json is server list
20:51 < bridge> <jxsl13> (Y)
20:51 < bridge> <ryozuki> https://publicdomainreview.org/features/entering-the-public-domain/2024/
20:52 < bridge> <Jupstar ‚ú™> ddnet
20:52 < bridge> <Jupstar ‚ú™> üòè
20:52 < bridge> <ryozuki> üòè
20:52 < bridge> <ryozuki> @learath2 @jupeyy_keks
20:52 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1184221347283488828/image.png?ex=658b2f12&is=6578ba12&hm=b9b79c555f7348f4ad7d4da57ee7ae7430111853047e89483c92837a01b0b1d0&
20:52 < bridge> <ryozuki> this will be
20:52 < bridge> <ryozuki> public domain
20:53 < bridge> <Jupstar ‚ú™> epic
20:54 < bridge> <louis> unfortunately only that single film
20:54 < bridge> <Jupstar ‚ú™> directly watch on youtube
20:56 < bridge> <learath2> NOOOOO won't somebody think of the shareholders???
20:57 < bridge> <learath2> This is communism
20:59 < bridge> <Jupstar ‚ú™> i wait for the day when dragonball goes public domain
20:59 < bridge> <Jupstar ‚ú™> then i quit my job
21:00 < bridge> <Jupstar ‚ú™> code a good db game, and show konami the middle finger
21:00 < bridge> <Jupstar ‚ú™> then i can die in peace
21:01 < bridge> <Jupstar ‚ú™> it's sad that they don't also have to release the project files
21:01 < bridge> <Jupstar ‚ú™> like in programming the source code
21:01 < bridge> <Jupstar ‚ú™> would be kinda cool
21:48 < bridge> <heinrich5991> https://www.youtube.com/watch?v=rHIkrotSwcc there's a talk about there being overhead. I guess you want me to unpack it, since you don't want to watch a video?
21:50 < bridge> <heinrich5991> just like C, trying to shove everyone into the concept of functions etc.
21:51 < bridge> <heinrich5991> not helpful. huge projects like chromium get segfaults despite competent programmers being involved
21:55 < bridge> <heinrich5991> `sizeof(struct s) == 6`, `sizeof(struct t) == 8`?
21:56 < bridge> <heinrich5991> 4
21:57 < bridge> <heinrich5991> t: 8
21:57 < bridge> <heinrich5991> eh, 6, I mean
21:57 < bridge> <heinrich5991> 3, 4
21:58 < bridge> <heinrich5991> depends on whether you want to track that down or not
21:58 < bridge> <heinrich5991> it's hard to ensure that it keeps working though, there's some work on -Z minimal-versions IIRC
21:58 < bridge> <heinrich5991> for cargo
21:58 < bridge> <heinrich5991> source?
21:59 < bridge> <Jupstar ‚ú™> rewind time everybody
21:59 < bridge> <heinrich5991> rust already does that
22:00 < bridge> <heinrich5991> correct
22:00 < bridge> <heinrich5991> yes
22:00 < bridge> <heinrich5991> only everyone using your project directly. if they have your project as a dependency, your Cargo.lock will be ignored
22:00 < bridge> <heinrich5991> 16
22:01 < bridge> <heinrich5991> 16
22:01 < bridge> <heinrich5991> it is
22:01 < bridge> <heinrich5991> it's called "niche" in rust, I think
22:02 < bridge> <heinrich5991> yep, that
22:02 < bridge> <heinrich5991> yes
22:02 < bridge> <heinrich5991> hmmmm. not really. it's used for people directly compiling your crate
22:04 < bridge> <heinrich5991> if people actually need a machine to help them look up definitions, we're doomed. oh wait, wikipedia
22:04 < bridge> <heinrich5991> that you can use different words. but a fuzzy search over the content would already be nice
22:05 < bridge> <heinrich5991> you could say that about any software. everything produced by mozilla could be biased towards mozilla. what's special about "AI" aka LLMs?
22:06 < bridge> <heinrich5991> hi o/
22:08 < bridge> <Jupstar ‚ú™> hai
22:09 < bridge> <learath2> I already demonstrated the exact example from this talk in a godbolt
22:10 < bridge> <heinrich5991> ah, here. @Fussel
22:14 < bridge> <louis> is it possible to compile ddnet for linux on windows?
22:15 < bridge> <Jupstar ‚ú™> native windows?
22:15 < bridge> <Jupstar ‚ú™> or is WSL allowed?
22:15 < bridge> <louis> native
22:15 < bridge> <Jupstar ‚ú™> i mean theoretically possible yes, but never heard of a toolchain tbh
22:15 < bridge> <heinrich5991> you probably mean "possible" as in "can you give me a manual"?
22:17 < bridge> <louis> yeah i mean like is there a way easier than just cloning source and recompiling on linux
22:17 < bridge> <Jupstar ‚ú™> run the windows version in wine? üòÑ
22:18 < bridge> <louis> :justatest:
22:18 < bridge> <Jupstar ‚ú™> else very probably not easier
22:18 < bridge> <Jupstar ‚ú™> bcs compiling on windows IMO is not ez
22:20 < bridge> <heinrich5991> no. compiling on the target system will be the easiest
22:20 < bridge> <heinrich5991> cross-compiling unfortunately seems to be always harder than getting the target OS directly (in a VM or directly on hardware) and compiling there
22:22 < bridge> <ryozuki> wasnt there a yt vid like that in old times
22:22 < bridge> <Jupstar ‚ú™> pewdiepie? xd
22:22 < bridge> <Jupstar ‚ú™> yeah my brain thinks in quotes
22:22 < bridge> <ryozuki> oficial
22:24 < bridge> <Jupstar ‚ú™> https://youtu.be/By_Cn5ixYLg?si=RkLBBRBaYOl0LKes&t=29
22:24 < bridge> <Jupstar ‚ú™> found it xdd
22:25 < bridge> <ryozuki> xd
23:58 < ChillerDragon> can someone explain me why ddnet compiles 
23:58 < ChillerDragon> https://github.com/ddnet/ddnet/blob/bcc92fa0fb0486dd598657cfa881d5e1ffcd08de/src/engine/shared/config_variables.h#L14
23:58 < ChillerDragon> this mf is using the enum ``CFGFLAG_CLIENT``
23:59 < ChillerDragon> https://github.com/ddnet/ddnet/blob/bcc92fa0fb0486dd598657cfa881d5e1ffcd08de/src/engine/shared/config.h#L45
23:59 < ChillerDragon> it is defined here
23:59 < ChillerDragon> which is below the include 
23:59 < ChillerDragon> https://github.com/ddnet/ddnet/blob/bcc92fa0fb0486dd598657cfa881d5e1ffcd08de/src/engine/shared/config.h#L34
23:59 < ChillerDragon> C++ hoisting momemnt
