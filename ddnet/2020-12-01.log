05:55 <+bridge> [ddnet] <heinrich5991> interesting
06:03 <+bridge> [ddnet] <heinrich5991> 504, now 503, eh? ‚Ä¶
06:07 <+bridge> [ddnet] <heinrich5991> now 502
06:07 <+bridge> [ddnet] <heinrich5991> at this rate, not long before 200, heh?
06:09 <+bridge> [ddnet] <heinrich5991> (ah, now it's done)
08:10 <+bridge> [ddnet] <Patiga> yo dont mind my times i always start 2 hours later to get some sleep
08:11 <+bridge> [ddnet] <heinrich5991> just admit it took you two hours to get the solution
08:12 <+bridge> [ddnet] <Patiga> lies!
08:22 <+bridge> [ddnet] <becc> No points for day 1 due too technical problems :>
08:42 <+bridge> [ddnet] <deen> > If you want to learn these techniques then start by carefully reading Jeff Preshing‚Äôs introduction to lock-free programming or This is Why They Call It a Weakly-Ordered CPU, and then consider joining a monastery or nunnery instead.
08:42 <+bridge> [ddnet] <deen> https://randomascii.wordpress.com/2020/11/29/arm-and-lock-free-programming/
08:54 <+bridge> [ddnet] <heinrich5991> @deen is that an answer to something?
08:59 <+bridge> [ddnet] <deen> No
09:12 <+bridge> [ddnet] <Ryozuki> just woke up :monkalaugh:
09:12 <+bridge> [ddnet] <Ryozuki> time to code it
09:13 <+bridge> [ddnet] <Ryozuki> @heinrich5991 yesterday i did my first code golf answer, maybe u can improve it (in rust) https://codegolf.stackexchange.com/a/215799/58802
09:13 <+bridge> [ddnet] <Ryozuki> `(2..).for_each(|x|(1..x).for_each(|y|print!("{} ",y)))`
09:13 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
09:14 <+bridge> [ddnet] <Ryozuki> i didnt know u could go to the infinite with (2..)
09:14 <+bridge> [ddnet] <Ryozuki> before that
09:41 <+bridge> [ddnet] <Patiga> how about
09:41 <+bridge> [ddnet] <Patiga> `rand="0"`
09:41 <+bridge> [ddnet] <Patiga> 9 bytes with newline
09:41 <+bridge> [ddnet] <Patiga> in the Cargo.toml and 
09:41 <+bridge> [ddnet] <Patiga> `loop{print!("{} ", rand::random::<i32>())}`
09:41 <+bridge> [ddnet] <Patiga> + 42 bytes = 51 bytes @Ryozuki
09:42 <+bridge> [ddnet] <Ryozuki> idk if u can use packages
09:44 <+bridge> [ddnet] <Ryozuki> also it just spits out random numbers
09:44 <+bridge> [ddnet] <Patiga> huh i mean else you wouldnt be able to solve any problems which play with random numbers in rust
09:44 <+bridge> [ddnet] <Ryozuki> it doesnt solve the problem
09:44 <+bridge> [ddnet] <Patiga> why not?
09:44 <+bridge> [ddnet] <Patiga> i would say it solves it just as well as your solution
09:44 <+bridge> [ddnet] <Ryozuki> did u read the codegolf challenge?
09:45 <+bridge> [ddnet] <Patiga> yea
09:45 <+bridge> [ddnet] <Patiga> oh fuck yea replace `i32` with `u32`
09:45 <+bridge> [ddnet] <Ryozuki> it needs to write them ordered btw
09:45 <+bridge> [ddnet] <Ryozuki> like
09:45 <+bridge> [ddnet] <Ryozuki> 1
09:45 <+bridge> [ddnet] <Ryozuki> 1 2
09:45 <+bridge> [ddnet] <Ryozuki> 1 2 3
09:45 <+bridge> [ddnet] <Patiga> not really
09:45 <+bridge> [ddnet] <Patiga> > Any way of writing such a sequence is acceptable.
09:45 <+bridge> [ddnet] <Ryozuki> Notice that we write all naturals from 1 to N for all N ‚àà ‚Ñï.
09:46 <+bridge> [ddnet] <Ryozuki> @Patiga it means the format
09:46 <+bridge> [ddnet] <heinrich5991> seems fine for me
09:46 <+bridge> [ddnet] <Ryozuki> https://codegolf.meta.stackexchange.com/questions/1061/loopholes-that-are-forbidden-by-default
09:46 <+bridge> [ddnet] <heinrich5991> the example output is just an example
09:46 <+bridge> [ddnet] <Ryozuki> all other answers arent random like this
09:46 <+bridge> [ddnet] <Ryozuki> its not ok imho
09:46 <+bridge> [ddnet] <heinrich5991> why not?
09:47 <+bridge> [ddnet] <Ryozuki> thats why the loophole rule exists
09:47 <+bridge> [ddnet] <heinrich5991> which loophole rule do you mean? can you link to a specific one?
09:51 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/783253987997515816/unknown.png
09:51 <+bridge> [ddnet] <Ryozuki> ok its valid
09:51 <+bridge> [ddnet] <Ryozuki> but i dont like it
09:51 <+bridge> [ddnet] <Patiga> :c
09:55 <+bridge> [ddnet] <Ryozuki> > Because of an outage during the day 1 puzzle unlock, day 1 is worth no points.
09:55 <+bridge> [ddnet] <Ryozuki> oh rip
10:00 <+bridge> [ddnet] <Ryozuki> ```rust
10:00 <+bridge> [ddnet] <Ryozuki> use std::fs;
10:00 <+bridge> [ddnet] <Ryozuki> 
10:00 <+bridge> [ddnet] <Ryozuki> fn main() {
10:00 <+bridge> [ddnet] <Ryozuki>     let r = fs::read_to_string("input").unwrap();
10:00 <+bridge> [ddnet] <Ryozuki>     let x: Vec<i64> = r.split("\n")
10:00 <+bridge> [ddnet] <Ryozuki>         .filter(|x| !x.is_empty())
10:00 <+bridge> [ddnet] <Ryozuki>         .map(|x| x.parse::<i64>().unwrap()).collect();
10:00 <+bridge> [ddnet] <Ryozuki> 
10:00 <+bridge> [ddnet] <Ryozuki>     for a in x.iter() {
10:00 <+bridge> [ddnet] <Ryozuki>         for b in x.iter() {
10:00 <+bridge> [ddnet] <Ryozuki>             for c in x.iter() {
10:00 <+bridge> [ddnet] <Ryozuki>                 if a + b + c == 2020 {
10:01 <+bridge> [ddnet] <Ryozuki>                     println!("{}", a * b * c);
10:01 <+bridge> [ddnet] <Ryozuki>                     return;
10:01 <+bridge> [ddnet] <Ryozuki>                 }
10:01 <+bridge> [ddnet] <Ryozuki>             }
10:01 <+bridge> [ddnet] <Ryozuki>         }
10:01 <+bridge> [ddnet] <Ryozuki>     }
10:01 <+bridge> [ddnet] <Ryozuki> }
10:01 <+bridge> [ddnet] <Ryozuki> ```
10:01 <+bridge> [ddnet] <Ryozuki> my rust solution <a:aPES4_Steering:751433824721961031>
10:01 <+bridge> [ddnet] <heinrich5991> `x.iter()` ‚Üí `&x`
10:02 <+bridge> [ddnet] <Ryozuki> ?
10:02 <+bridge> [ddnet] <heinrich5991> `for a in x.iter()` ‚Üí `for a in &x`
10:02 <+bridge> [ddnet] <heinrich5991> it's the same and shorter üòâ
10:02 <+bridge> [ddnet] <Ryozuki> ah ye
10:02 <+bridge> [ddnet] <Ryozuki> i was not golfin here xd
10:03 <+bridge> [ddnet] <Ryozuki> for some reason split returned some empty strings
10:03 <+bridge> [ddnet] <heinrich5991> probably after the last line?
10:03 <+bridge> [ddnet] <Ryozuki> i guess
10:03 <+bridge> [ddnet] <heinrich5991> because the last line is still terminated with a \n
10:03 <+bridge> [ddnet] <Ryozuki> is there some linux tool to view newlines ez
10:03 <+bridge> [ddnet] <heinrich5991> https://doc.rust-lang.org/std/primitive.str.html#method.lines
10:03 <+bridge> [ddnet] <heinrich5991> is what you want, probably
10:03 <+bridge> [ddnet] <heinrich5991> `hexdump -C`
10:04 <+bridge> [ddnet] <Ryozuki> oh it has a lines method
10:04 <+bridge> [ddnet] <heinrich5991> (and yes, on non-windows, there's a newline at end of file)
10:04 <+bridge> [ddnet] <heinrich5991> you need to do `.trim()` probably though
10:04 <+bridge> [ddnet] <heinrich5991> because `.parse::<i64>()` probably chokes on whitespace
10:05 <+bridge> [ddnet] <Ryozuki> lines() work without the filter
10:05 <+bridge> [ddnet] <Ryozuki> no need to trim
10:05 <+bridge> [ddnet] <heinrich5991> k
10:10 <+bridge> [ddnet] <Ryozuki> https://github.com/not-a-seagull/breadx
10:10 <+bridge> [ddnet] <Ryozuki> :poggers:
10:12 <+bridge> [ddnet] <Patiga> https://codegolf.stackexchange.com/a/215831/99502
10:51 <+bridge> [ddnet] <Fixit> wow rust seems to be actually kinda cool
11:13 <+bridge> [ddnet] <timakro> If I have a vector `v` in rust I can create a slice with `&v[x..y]` but `v[x..y]` also works. Does the second one copy the vector?
11:16 <+bridge> [ddnet] <timakro> ah maybe when `&v` is the same as `v.iter()` then `&v[x..y]` is the same as `v[x..y].iter()`?
11:16 <+bridge> [ddnet] <heinrich5991> no. v[x..y] cannot be used in a non-reference context
11:16 <+bridge> [ddnet] <heinrich5991> it's always the reference
11:17 <+bridge> [ddnet] <heinrich5991> `v[x..y].iter()` autoreferences `v[x..y]` to `&v[x..y]`
11:17 <+bridge> [ddnet] <heinrich5991> `.` can autoreference one level
11:18 <+bridge> [ddnet] <timakro> okay, I guess i need to read further in "The Book" if I really want to understand what I'm doing
11:30 <+bridge> [ddnet] <Ryozuki> @timakro did u know rust auto derefs
11:31 <+bridge> [ddnet] <timakro> nope
11:31 <+bridge> [ddnet] <Ryozuki> https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules
11:32 <+bridge> [ddnet] <Ryozuki> well its on chapter 15.2
11:32 <+bridge> [ddnet] <Ryozuki> <a:aPES4_Steering:751433824721961031>
12:10 <+bridge> [ddnet] <Learath2> I love this guy‚Äôs blog, always a great read
12:45 <+bridge> [ddnet] <deen> @Ryozuki Prolog is easier :D
12:45 <+bridge> [ddnet] <deen> ```
12:45 <+bridge> [ddnet] <deen> solve(L, Z) :- member(W, L), member(X, L), member(Y, L), 2020 is W + X + Y, write(X), Z is W * X * Y.
12:45 <+bridge> [ddnet] <deen> ```
12:46 <+bridge> [ddnet] <deen> @Ryozuki Prolog is easier :D
12:46 <+bridge> [ddnet] <deen> ```
12:46 <+bridge> [ddnet] <deen> solve(L, Z) :- member(W, L), member(X, L), member(Y, L), 2020 is W + X + Y, Z is W * X * Y.
12:46 <+bridge> [ddnet] <deen> ```
12:50 <+bridge> [ddnet] <Ryozuki> :justatest:
13:02 <+bridge> [ddnet] <Learath2> autoref and autoderef makes rust even harder to follow imo
13:04 <+bridge> [ddnet] <Learath2> Though I don't like anything auto so my opinion is not really relevant. Compilers and interpreters making assumptions is just a no no for me, unless I explicitly tell it to think for me.
13:07 <+bridge> [ddnet] <Ryozuki> make the holy learath2 bible on how a language should be made
13:07 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
13:08 <+bridge> [ddnet] <Learath2> One day when I have more time I will make my own language that compiles down to LLVM IR
13:09 <+bridge> [ddnet] <Learath2> It would probably end up very similar to D or zig though
13:09 <+bridge> [ddnet] <Learath2> Honestly, zig I think has everything I would want in a language
13:14 <+bridge> [ddnet] <Learath2> I've been wondering why every modern language moved the return type to the end. I mean it's easier to parse but it's just so silly to read and introduces an extra token that conveys no extra information
13:14 <+bridge> [ddnet] <Ryozuki> everyone did their homework today
13:14 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/783305033810837534/unknown.png
13:14 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
13:14 <+bridge> [ddnet] <Learath2> (usually more than 1 extra token, some languages even have a ->)
13:15 <+bridge> [ddnet] <jao> why is ryo only 4th
13:15 <+bridge> [ddnet] <Ryozuki> ranking is by alphabet
13:15 <+bridge> [ddnet] <Ryozuki> since day 1 doesnt give points
13:15 <+bridge> [ddnet] <Ryozuki> due to a outage
13:15 <+bridge> [ddnet] <Learath2> Not like any of us will get any points ever
13:15 <+bridge> [ddnet] <jao> ryo will
13:15 <+bridge> [ddnet] <Ryozuki> @Learath2 we will get points in the private leaderboard
13:16 <+bridge> [ddnet] <Learath2> ah, is it separate in private?
13:16 <+bridge> [ddnet] <Ryozuki> thats why private leaderboards exist
13:16 <+bridge> [ddnet] <Ryozuki> since not all ppl can wake up at utc-5
13:16 <+bridge> [ddnet] <Ryozuki> u can make friendly rules with ur friends i guess
13:16 <+bridge> [ddnet] <Learath2> I hate this kind of ranking. So america centric
13:16 <+bridge> [ddnet] <Ryozuki> ye
13:16 <+bridge> [ddnet] <Ryozuki> utc-5 is new york i think
13:17 <+bridge> [ddnet] <Learath2> I guess I also hate these kinds of challanges
13:17 <+bridge> [ddnet] <Learath2> I never enjoyed challanges that only reward obsessive people. Look at the people doing the google challanges on youtube
13:19 <+bridge> [ddnet] <Learath2> It's like the same 5 obsessive people every time hogging the top5 spots, golfing every day to know all the latest theoretical questions that have 0 applications in reality
13:20 <+bridge> [ddnet] <Learath2> They spot a word in the question, instead of solving the question they refer to a database of question types in their heads, and just pattern match the answer
13:22 <+bridge> [ddnet] <Ryozuki> xd
13:23 <+bridge> [ddnet] <Patiga> well i enjoy the challenge of the later days, which require you to think about how you want to approach the problem
13:23 <+bridge> [ddnet] <Patiga> the first few days are practically only about time
13:25 <+bridge> [ddnet] <Patiga> @Learath2 i think you forget that you can also enjoy those challenges without looking at the top ranks. enjoy the difficulty (that is introduced later, you can skip the first days if you like) and participate in the friendly competition of private leaderboards if you like that
13:27 <+bridge> [ddnet] <Learath2> The later problems are about time too. The reason these kinds of people are unbeatable is it's O(1) for them to come up with a solution no matter how complex the problem
13:28 <+bridge> [ddnet] <Learath2> @Patiga oh yeah, I enjoy friendly competition. I just think the global leaderboards are just not indicative of anything
13:28 <+bridge> [ddnet] <becc> They are probably reading books full of problems/solutions 24/7
13:28 <+bridge> [ddnet] <Ryozuki> well let em be
13:28 <+bridge> [ddnet] <Patiga> ah thats nice :)
13:29 <+bridge> [ddnet] <Ryozuki> @Learath2 ur more the type to know the ins and outs of compilers and stuff i guess
13:29 <+bridge> [ddnet] <Ryozuki> other ppl like to do challenges fast
13:29 <+bridge> [ddnet] <Learath2> @Ryozuki it's a pet peeve of mine, never liked these people in high school either. It just stuck with me, I guess the part I despise the most is their perceived success
13:29 <+bridge> [ddnet] <Learath2> A childish jealousy wired deep inside my brain üòÑ
13:29 <+bridge> [ddnet] <Ryozuki> :yoo:
16:15 <+bridge> [ddnet] <TsFreddie> https://cdn.discordapp.com/attachments/293493549758939136/783350660062117888/unknown.png
16:32 <+bridge> [ddnet] <Ryozuki> Is this some window joke im too gnu+linux to get?
16:33 <+bridge> [ddnet] <Ravie> it's a joke you're too windows to get
16:35 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
16:43 <+bridge> [ddnet] <hussainx3> looks i see them  the skin (Redboppenomred) but they still see me default
17:02 <+bridge> [ddnet] <Jupstar ‚ú™> what did u expect? that u hacked their game xD
17:07 <+bridge> [ddnet] <Jupstar ‚ú™> @hussainx3 if u want others to see ur skin, u gotta add it to the database
17:20 <+bridge> [ddnet] <Ravie> does someone here know how to use config_store.exe? I was able to extract a map's server settings .cfg and edit it but putting the new edited config inside the map doesn't seem to work
17:21 <+bridge> [ddnet] <heinrich5991> I think you drag-and-drop the map onto the `config_store.exe` to store the config with the same name into the map
17:22 <+bridge> [ddnet] <heinrich5991> @Ravie ^
17:24 <+bridge> [ddnet] <Ravie> that's what I'm doing but it simply doesn't change the server settings
17:24 <+bridge> [ddnet] <Ravie> I even tried replacing everything with just `sv_deepfly 0` to be sure I'm not seeing things wrong
17:26 <+bridge> [ddnet] <heinrich5991> could you open the executable from the console (cmd.exe) to see what it outputs?
17:26 <+bridge> [ddnet] <heinrich5991> you can drag-and-drop the executable and the map filename into the console, I think
17:26 <+bridge> [ddnet] <heinrich5991> to get the complete paths in there
17:27 <+bridge> [ddnet] <Ravie> and then drop the map file into it as well?
17:28 <+bridge> [ddnet] <heinrich5991> yes
17:28 <+bridge> [ddnet] <heinrich5991> with a space between the executable name and the map name
17:33 <+bridge> [ddnet] <Ravie> @heinrich5991
17:33 <+bridge> [ddnet] <Ravie> https://cdn.discordapp.com/attachments/293493549758939136/783370284337463306/Untitled.png
17:34 <+bridge> [ddnet] <heinrich5991> couldn't open ‚Ä¶ for writing
17:34 <+bridge> [ddnet] <heinrich5991> sounds like you lack permissions to write to that file(?)
17:38 <+bridge> [ddnet] <Ravie> I can try running as administrator and see if that works
17:39 <+bridge> [ddnet] <Patiga> do you run your client as administrator?
17:39 <+bridge> [ddnet] <heinrich5991> you could try it on another file, or right-click ‚Üí properties it and check if there are weird permissions
17:41 <+bridge> [ddnet] <Ravie> it looks like I have all permissions on map files
17:41 <+bridge> [ddnet] <heinrich5991> hmmm
17:42 <+bridge> [ddnet] <heinrich5991> do you have python installed?
17:42 <+bridge> [ddnet] <heinrich5991> (to debug this issue furtherly)
17:43 <+bridge> [ddnet] <Ravie> don't think so, I'm not that advanced but I can try if you give me instructions
17:43 <+bridge> [ddnet] <heinrich5991> https://www.python.org/
17:44 <+bridge> [ddnet] <heinrich5991> download python 3.9, install it
17:44 <+bridge> [ddnet] <Learath2> What will you even do with python?
17:44 <+bridge> [ddnet] <heinrich5991> check if I can open the file for writing
17:44 <+bridge> [ddnet] <heinrich5991> python is my syscall tool on windows&linux, because I know that it behaves kinda sane
17:44 <+bridge> [ddnet] <Ravie> while we're on the topic of server settings, a simple way to rearrange the commands like this would be very welcome
17:44 <+bridge> [ddnet] <Ravie> https://cdn.discordapp.com/attachments/293493549758939136/783373054365401168/unknown.png
17:44 <+bridge> [ddnet] <heinrich5991> and I can trigger syscalls and get errors
17:45 <+bridge> [ddnet] <heinrich5991> @Ravie if importing/exporting to text file worked, would it still be an issue?
17:46 <+bridge> [ddnet] <Ravie> well it's still rather clunky to deal with files like this and I don't think this would be too hard to implement
17:46 <+bridge> [ddnet] <Ravie> but for now this is the only way
17:46 <+bridge> [ddnet] <heinrich5991> well, I think the endgame is implementing a text editor there
17:46 <+bridge> [ddnet] <heinrich5991> and that sounds rather hard\
17:46 <+bridge> [ddnet] <Learath2> A small text editor there would be so nice
17:47 <+bridge> [ddnet] <Ravie> I think it's alright to use with the new Mod feature, I'm just missing the ability to rearragne everything neatly once all the commands are done
17:47 <+bridge> [ddnet] <Ravie> and you pretty much can't just write them in order from the start, never know what you'll end up needing
17:48 <+bridge> [ddnet] <Learath2> Well arrows should be trivial to add
17:48 <+bridge> [ddnet] <Learath2> Maybe I'll do it quickly tonight
17:49 <+bridge> [ddnet] <heinrich5991> üëç
17:49 <+bridge> [ddnet] <Ravie> well then I guess we don't need to debug config_store.exe, since I'm the only one with this problem
17:49 <+bridge> [ddnet] <heinrich5991> ü§∑‚Äç‚ôÄÔ∏è
17:49 <+bridge> [ddnet] <Patiga> > do/did you run your client as administrator? @Ravie
17:50 <+bridge> [ddnet] <Ravie> @Patiga this is an external .exe that does something to map files
17:50 <+bridge> [ddnet] <Patiga> yeah, question still stands tho
17:50 <+bridge> [ddnet] <Ravie> well no I don't
17:50 <+bridge> [ddnet] <Learath2> Well if you opened it with an administrator client. It would save it with wrong ownership
17:51 <+bridge> [ddnet] <Learath2> Anyway, odd issue :P
17:51 <+bridge> [ddnet] <heinrich5991> got a better idea on how to debug if the file can be opened for writing on windows btw?
17:52 <+bridge> [ddnet] <Learath2> Have you checked that we close the file after reading it?
17:52 <+bridge> [ddnet] <Learath2> Windows can be picky with it's exclusive opens
17:53 <+bridge> [ddnet] <heinrich5991> yes, we do
17:53 <+bridge> [ddnet] <heinrich5991> at least if CDatafileReader::Close closes the file
18:59 <+bridge> [ddnet] <Comrade> @Learath2 
18:59 <+bridge> [ddnet] <Comrade> ```c++
18:59 <+bridge> [ddnet] <Comrade> void SomeFunc()
18:59 <+bridge> [ddnet] <Comrade> {
18:59 <+bridge> [ddnet] <Comrade>     // throws an exception with all the error info if something goes wrong
18:59 <+bridge> [ddnet] <Comrade>     DoSomething();
18:59 <+bridge> [ddnet] <Comrade> }
18:59 <+bridge> [ddnet] <Comrade> 
18:59 <+bridge> [ddnet] <Comrade> void SomeFunc()
18:59 <+bridge> [ddnet] <Comrade> {
18:59 <+bridge> [ddnet] <Comrade>     if (!DoSomething())
18:59 <+bridge> [ddnet] <Comrade>     {
18:59 <+bridge> [ddnet] <Comrade>         // obtain the error info and report it to the caller somehow
18:59 <+bridge> [ddnet] <Comrade>     }
18:59 <+bridge> [ddnet] <Comrade> }
19:00 <+bridge> [ddnet] <Comrade> ```
19:00 <+bridge> [ddnet] <Comrade> 
19:00 <+bridge> [ddnet] <Comrade> properly used exceptions = clean code
19:00 <+bridge> [ddnet] <Comrade> or no?
19:06 <+bridge> [ddnet] <Learath2> Gist of it is in limited contexts I am sort of okay with the idea of exceptions. In those limited contexts `try{ SomeFunc(); } catch(whatever) { handleerror; }` is equivalent to `if(!SomeFunc()){ handleerror; }`. I think the second is cleaner, I also think limiting them to such contexts (e.g. exceptions that can only go back 1 stack frame) makes exceptions not the correct solution
19:07 <+bridge> [ddnet] <Learath2> Exceptions also lead to "unexpected" code-paths which is why I much prefer something like rusts result or optional/variant types.
19:08 <+bridge> [ddnet] <Learath2> A compiler checked error type that can't be implicitly propagated upwards is what I would investigate for a language I would make
19:10 <+bridge> [ddnet] <Comrade> you mean something like checked exceptions in Java?
19:11 <+bridge> [ddnet] <Comrade> that's not the right way probably, but i know what you mean
19:11 <+bridge> [ddnet] <Comrade> it's good idea
19:11 <+bridge> [ddnet] <Learath2> Well the same idea but not as overengineered a solution, leading to both prettier assembly and allowing actual error recovery
19:12 <+bridge> [ddnet] <Learath2> instead of putting try catches everywhere throwing upwards and pretending you do "error checking" well
19:12 <+bridge> [ddnet] <Comrade> sometimes it's really hard to do error handling with exceptions properly üòÑ
19:12 <+bridge> [ddnet] <Comrade> that's true
19:13 <+bridge> [ddnet] <Learath2> And a single code path, leading to easier analysis and reasoning about flow. If you want to see the mess exceptions make look no further than disassemblers trying to visualize the code flow
19:13 <+bridge> [ddnet] <Learath2> If a program given minutes can't reason about the flow, how am I supposed to
19:13 <+bridge> [ddnet] <Comrade> yes, exceptions in assembly looks terrible
19:14 <+bridge> [ddnet] <Comrade> all those "cold clone" functions etc
19:14 <+bridge> [ddnet] <Comrade> *look
19:14 <+bridge> [ddnet] <Learath2> returns are so nice, idk why people would want anything else
19:15 <+bridge> [ddnet] <Comrade> because it makes the code harder to understand
19:15 <+bridge> [ddnet] <Learath2> They are efficient, they are well defined ABI-wise, they look clean in code and in assembly, they give such clean entry and exit points
19:15 <+bridge> [ddnet] <heinrich5991> do you have a sane ABI for multiple return values?
19:16 <+bridge> [ddnet] <heinrich5991> also interesting: RVO is inhibited if you have a Result-like type
19:16 <+bridge> [ddnet] <heinrich5991> native support for exceptions fixes that issue, at least
19:16 <+bridge> [ddnet] <Learath2> I don't get how `try { whatever(); } catch (Exception e){ handle(); }` is easier to understand than `if(!whatever()) { handle(); }`. That's just silly
19:17 <+bridge> [ddnet] <Comrade> because there's usually much more ifs than try-catch blocks
19:17 <+bridge> [ddnet] <Learath2> @heinrich5991 there is a sane ABI for returning pointers, which is what you would return a pointer to your variant type return
19:18 <+bridge> [ddnet] <heinrich5991> huh no, that would imply an allocation
19:18 <+bridge> [ddnet] <heinrich5991> that is inefficient
19:18 <+bridge> [ddnet] <Learath2> Not any more space inefficient than an exception
19:19 <+bridge> [ddnet] <Learath2> A try block with multiple things that can fail is exactly what's wrong with exceptions
19:19 <+bridge> [ddnet] <Comrade> i think error handling code after each function call (the ifs) distracts when you read the code and trying to understand what it does
19:19 <+bridge> [ddnet] <Learath2> How are you supposed to handle something failing if you can't know what exactly failed?
19:19 <+bridge> [ddnet] <heinrich5991> more inefficient if you assume that the error case happens more rarely
19:20 <+bridge> [ddnet] <Learath2> Hm, I guess it does require more ABI support
19:23 <+bridge> [ddnet] <Comrade> some errors even cannot be handled properly without exceptions - Let's say you call some function from some library. That function opens some file internally and it fails. How do you report such error back to the calling code outside the library without exception? Note that you need the filename to create meaningful error message for the user.
19:23 <+bridge> [ddnet] <heinrich5991> you have an error type that contains the necessary information for the user to handle the error
19:24 <+bridge> [ddnet] <Ryozuki> ^
19:24 <+bridge> [ddnet] <heinrich5991> throwing a FileNotFoundError from deep inside the library isn't actually that helpful for the user of the library
19:24 <+bridge> [ddnet] <Learath2> @heinrich5991 I have a feeling RVO is only viable because of the current "crash and burn" approach to programming. If you actually figure out a way to recover from the exception it would cost way more than the optimization gained you
19:24 <+bridge> [ddnet] <Ryozuki> Result best ‚òï
19:25 <+bridge> [ddnet] <Comrade> but name of the file is highly helpful for the end user
19:25 <+bridge> [ddnet] <Learath2> @Comrade You return an error type. The internal function puts it in another error type and returns it to the user
19:25 <+bridge> [ddnet] <heinrich5991> `FileNotFoundError(/var/cache/firefox/acbjksbefjksf)` what do you do now?
19:25 <+bridge> [ddnet] <Comrade> you can always do one thing - google that üòÑ
19:26 <+bridge> [ddnet] <heinrich5991> fair
19:26 <+bridge> [ddnet] <Learath2> Anyway, error types don't prevent you from signaling that
19:26 <+bridge> [ddnet] <Learath2> I'll do you one even better. I think that FileNotFoundError should never make it to the user
19:26 <+bridge> [ddnet] <heinrich5991> but might still do, due to bugs
19:26 <+bridge> [ddnet] <Learath2> I think it should be `LibraryError(FileNotFound: /path/to/file)`
19:27 <+bridge> [ddnet] <Comrade> it's so annoying when app shows something like "File not found" and nothing else üòÑ
19:27 <+bridge> [ddnet] <Comrade> with exceptions you can easily avoid that
19:27 <+bridge> [ddnet] <Learath2> @heinrich5991 the compiler can check that none of these errors make it out of your library
19:28 <+bridge> [ddnet] <heinrich5991> ah yes
19:28 <+bridge> [ddnet] <heinrich5991> but they might still make it out as "AssertionError: FileNotFound"
19:28 <+bridge> [ddnet] <heinrich5991> or similar
19:28 <+bridge> [ddnet] <heinrich5991> "InvalidStateError: FileNotFound"
19:28 <+bridge> [ddnet] <Learath2> I don't mind them wrapping it again and returning it. As long as it's an explicit decision, that's fine
19:29 <+bridge> [ddnet] <Comrade> maybe logging is the best error handling üòÑ
19:30 <+bridge> [ddnet] <Learath2> Something like `if-error(e : fopen()) { return wrap_unrecoverable(e); }`
19:30 <+bridge> [ddnet] <Comrade> but you always have to return that thing even if no error occurs
19:30 <+bridge> [ddnet] <Comrade> that's bad
19:30 <+bridge> [ddnet] <Learath2> or if you don't mind annoying the new people I wouldn't even introduce a new token for that
19:31 <+bridge> [ddnet] <Learath2> @Comrade again, this is a hypothetical language, you don't "have to" do anything
19:31 <+bridge> [ddnet] <Learath2> The return type could be `Type?`¬†e.g. where either an object of type
19:31 <+bridge> [ddnet] <Learath2> is returned, or an error
19:33 <+bridge> [ddnet] <Comrade> interesting ideas
19:33 <+bridge> [ddnet] <Ryozuki> @Comrade hav u used rust?
19:33 <+bridge> [ddnet] <Comrade> not yet
19:33 <+bridge> [ddnet] <Ryozuki> !
19:34 <+bridge> [ddnet] <Learath2> One more example: `try { foo(); goo(); boo(); doo(); } catch (Exception e) { ... }` Each of foo, goo, boo and doo have recovery routines on error. You caught an e, how do you recover?
19:34 <+bridge> [ddnet] <Comrade> RAII
19:35 <+bridge> [ddnet] <Learath2> The usual answer is that you a) Introduce exception hierarchies b) Introduce new exceptions so you can handle different types c) You put each call in it's own try block
19:36 <+bridge> [ddnet] <Learath2> a and b give you a lot more exceptions you just might forget to handle at each point and for b in the case of checked exceptions huge throws clauses. c is no more intuitive or clear than the if block you didn't want in the first place
19:38 <+bridge> [ddnet] <Comrade> by the way, there's one more problem - throwing exception in destructor üòÑ
19:38 <+bridge> [ddnet] <Learath2> that never worked in C++ anyway üòõ
19:38 <+bridge> [ddnet] <Ryozuki> In java i use catch(Exception e) and call it a day :BASED:
19:38 <+bridge> [ddnet] <Learath2> Yeah, that's how 99% of the Java developer population does "error handling"
19:38 <+bridge> [ddnet] <Comrade> it does - you can mark destructor with `noexcept(false)`
19:39 <+bridge> [ddnet] <Ryozuki> Have u seen how absurdly long function signatures get when adding exceptions
19:39 <+bridge> [ddnet] <Ryozuki> Java is a circus
19:39 <+bridge> [ddnet] <Comrade> yes üòÑ
19:39 <+bridge> [ddnet] <Comrade> but Kotlin doesn't look that bad
19:39 <+bridge> [ddnet] <heinrich5991> but they're part of the signature
19:40 <+bridge> [ddnet] <Comrade> (except the underlying JVM crap)
19:40 <+bridge> [ddnet] <Learath2> @Comrade marking a destructor noexcept(false) is how you break a lot of things üòÑ
19:40 <+bridge> [ddnet] <Comrade> yes, that's true üòÑ
19:40 <+bridge> [ddnet] <Comrade> it's evil
19:40 <+bridge> [ddnet] <Comrade> but it works üòÑ
19:40 <+bridge> [ddnet] <Learath2> @Ryozuki the exceptions people will tell you that you should be using exception hierarchies 4head
19:41 <+bridge> [ddnet] <heinrich5991> btw, annoy linux about their errors in `close(2)`
19:41 <+bridge> [ddnet] <Learath2> That controls the exponential growth of exception numbers somewhat
19:41 <+bridge> [ddnet] <heinrich5991> doesn't fit RAII
19:41 <+bridge> [ddnet] <Ryozuki> ```java
19:41 <+bridge> [ddnet] <Ryozuki> public static int primeraPuntuacio(String ruta) throws ParserConfigurationException, IOException,
19:41 <+bridge> [ddnet] <Ryozuki>             SAXException, XPathExpressionException
19:41 <+bridge> [ddnet] <Ryozuki> ```
19:41 <+bridge> [ddnet] <Ryozuki> üòÜ
19:41 <+bridge> [ddnet] <Comrade> @heinrich5991 logging that is the only sane thing you can do i think
19:41 <+bridge> [ddnet] <Ryozuki> xml in java :justatest:
19:42 <+bridge> [ddnet] <heinrich5991> @Comrade but it's an error, you have to handle it
19:42 <+bridge> [ddnet] <heinrich5991> and it doesn't document anything like "fdatasync before close makes sure that close doesn't error"
19:42 <+bridge> [ddnet] <Comrade> yes, but you can't really handle it
19:42 <+bridge> [ddnet] <Comrade> only kernel can
19:42 <+bridge> [ddnet] <heinrich5991> huh? why not?
19:42 <+bridge> [ddnet] <heinrich5991> you can handle any file writing error, why not that one?
19:42 <+bridge> [ddnet] <Learath2> What is the problem with close()?
19:42 <+bridge> [ddnet] <Comrade> it fails in certain cases
19:43 <+bridge> [ddnet] <Learath2> Ah, it shouldn't be allowed to, true
19:43 <+bridge> [ddnet] <Learath2> They should provide a RAII compliant version of it too.
19:43 <+bridge> [ddnet] <heinrich5991> or, linux should provide a function that does the error bookkeeping so you can call that before close(2)
19:43 <+bridge> [ddnet] <heinrich5991> if you want your write to succeed
19:43 <+bridge> [ddnet] <Comrade> it's like `malloc` returning `NULL` - what can you do with that? üòÑ
19:43 <+bridge> [ddnet] <heinrich5991> @Comrade handle it like any file writing error? disk might be full e.g.
19:44 <+bridge> [ddnet] <heinrich5991> you also have to handle that
19:44 <+bridge> [ddnet] <Learath2> @Comrade depends, many of my programs handle it quite gracefully
19:44 <+bridge> [ddnet] <heinrich5991> (the error in close(2))
19:44 <+bridge> [ddnet] <Ryozuki> > In practice, close should never be retried on error, and the fd you passed to close is always invalid (closed) after close returns, regardless of whether an error occurred. In some cases, an error may indicate that data was lost (certain NFS setups) or unusual hardware conditions for devices (e.g. tape could not be rewound), so you may want to be cautious to avoid data loss, but you should never attempt to close the fd again.
19:44 <+bridge> [ddnet] <Ryozuki> https://stackoverflow.com/questions/33114152/what-to-do-if-a-posix-close-call-fails
19:44 <+bridge> [ddnet] <Ryozuki> :justatest:
19:44 <+bridge> [ddnet] <Learath2> Though the OOM Killer will more than likely nuke your program along with many others, and malloc will probably never even return null on most modern OSs
19:44 <+bridge> [ddnet] <heinrich5991> only linux I think
19:45 <+bridge> [ddnet] <Learath2> they prefer to hand out a pointer anyway and either swap things around to let you use that virtual memory or just nuke you on page fault if swap is not available
19:45 <+bridge> [ddnet] <Ryozuki> is swap needed in these modern times
19:45 <+bridge> [ddnet] <Learath2> @Ryozuki depends on your workload
19:45 <+bridge> [ddnet] <heinrich5991> is that so for windows and macos, @Learath2 ?
19:46 <+bridge> [ddnet] <Comrade> let's say `malloc` returns `NULL`, so you log that first, but then you realize that your logging function calls malloc internally - how to fix that? üòÑ
19:46 <+bridge> [ddnet] <Learath2> @heinrich5991 I think it's similar on macOS, not sure about windows at all
19:46 <+bridge> [ddnet] <Ryozuki> Android studio <a:aPES4_Steering:751433824721961031>
19:46 <+bridge> [ddnet] <Learath2> Simple, my logging functions don't allocate memory
19:46 <+bridge> [ddnet] <Comrade> that's not so easy
19:46 <+bridge> [ddnet] <Learath2> It's quite simple. Step 1 is to not allocate memory
19:46 <+bridge> [ddnet] <Learath2> There is no step 2 even üòõ
19:47 <+bridge> [ddnet] <Comrade> as far as i know even `printf` may call `malloc` in glibc implementation
19:47 <+bridge> [ddnet] <Learath2> That's printfs business how it handles malloc
19:47 <+bridge> [ddnet] <Comrade> so, your allocation fails, logging fails, what's next?
19:48 <+bridge> [ddnet] <ReD | alloca„ÉÑ> do you achieve this by going like `char[256] buffer` to avoid malloc? or what
19:48 <+bridge> [ddnet] <heinrich5991> roll back the current transaction, I guess?
19:48 <+bridge> [ddnet] <heinrich5991> return a 500 error as a http server?
19:49 <+bridge> [ddnet] <Comrade> well, if all the libs you use can do that without malloc, then yes
19:49 <+bridge> [ddnet] <Learath2> Depends, if there is a way to recover, then you recover, if not then you just die
19:49 <+bridge> [ddnet] <Ryozuki> @Learath2 hav u seen the try catch finally mess u get in java when opening and closing a streamwriter, u hav to add another try catch inside the finally block, luckily in new java versions u have a nicer try
19:49 <+bridge> [ddnet] <heinrich5991> it's not entirely clear that just because malloc failed for one allocation, it'll fail for all others, too, btw
19:50 <+bridge> [ddnet] <Ryozuki> ```java
19:50 <+bridge> [ddnet] <Ryozuki> ObjectOutputStream oos = null;
19:50 <+bridge> [ddnet] <Ryozuki> try {
19:50 <+bridge> [ddnet] <Ryozuki>    oos = new ObjectOutputStream(new FileOutputStream(file));
19:50 <+bridge> [ddnet] <Ryozuki>    oos.writeObject(shapes);
19:50 <+bridge> [ddnet] <Ryozuki>    oos.flush();
19:50 <+bridge> [ddnet] <Ryozuki> } catch (FileNotFoundException ex) {
19:50 <+bridge> [ddnet] <Ryozuki>     // complain to user
19:50 <+bridge> [ddnet] <Ryozuki> } catch (IOException ex) {
19:50 <+bridge> [ddnet] <Ryozuki>     // notify user
19:50 <+bridge> [ddnet] <Ryozuki> } finally {
19:50 <+bridge> [ddnet] <Ryozuki>     if (oos != null) {
19:50 <+bridge> [ddnet] <Ryozuki>         try {
19:50 <+bridge> [ddnet] <Ryozuki>             oos.close();
19:50 <+bridge> [ddnet] <Ryozuki>         } catch (IOException ex) {
19:50 <+bridge> [ddnet] <Ryozuki>             // ignore ... any significant errors should already have been
19:50 <+bridge> [ddnet] <Ryozuki>             // reported via an IOException from the final flush.
19:50 <+bridge> [ddnet] <Ryozuki>         }
19:50 <+bridge> [ddnet] <Ryozuki>     }
19:50 <+bridge> [ddnet] <Ryozuki> }
19:50 <+bridge> [ddnet] <Ryozuki> ```
19:50 <+bridge> [ddnet] <Learath2> @Ryozuki try-with-resources is the cute way to handle this
19:51 <+bridge> [ddnet] <Ryozuki> <a:aPES4_Steering:751433824721961031>
19:51 <+bridge> [ddnet] <Ryozuki> yeah
19:51 <+bridge> [ddnet] <Ryozuki> but imagine the live
19:51 <+bridge> [ddnet] <Ryozuki> before it existed
19:51 <+bridge> [ddnet] <Learath2> yeah, java world is often clown world
19:51 <+bridge> [ddnet] <heinrich5991> why did you put the oos.close() into the finally block?
19:51 <+bridge> [ddnet] <heinrich5991> I'd think you can put that after oos.flush()
19:51 <+bridge> [ddnet] <Ryozuki> no
19:51 <+bridge> [ddnet] <heinrich5991> why not?
19:51 <+bridge> [ddnet] <Ryozuki> you wouldnt close it if it throws
19:51 <+bridge> [ddnet] <Learath2> Yep ^^
19:51 <+bridge> [ddnet] <Comrade> Java doesn't have RAII
19:52 <+bridge> [ddnet] <heinrich5991> huh? it'll still close AFAIK
19:52 <+bridge> [ddnet] <heinrich5991> when the garbage collector runs
19:52 <+bridge> [ddnet] <Ryozuki> üòÜ
19:52 <+bridge> [ddnet] <Comrade> no, it doesn't actually
19:52 <+bridge> [ddnet] <heinrich5991> source?
19:52 <+bridge> [ddnet] <Ryozuki> i think this is how u leak memory
19:52 <+bridge> [ddnet] <Ryozuki> in java
19:52 <+bridge> [ddnet] <Ryozuki> but idk
19:52 <+bridge> [ddnet] <Learath2> Even if it did, that's one uuuuuuugly solution
19:52 <+bridge> [ddnet] <heinrich5991> no, don't think so @Ryozuki. if so, source please
19:53 <+bridge> [ddnet] <Learath2> Relying on the OS to clean up your allocations on exit I can accept. Relying on GC to close your file handles is ew
19:53 <+bridge> [ddnet] <Comrade> https://stackoverflow.com/questions/31237918/file-descriptor-leak-example
19:53 <+bridge> [ddnet] <Learath2> "But many classes such as FileInputStream and RandomAccessFile are written with a finalize() method which ensures that IF an instance in garbage collected, close() will be called first."
19:53 <+bridge> [ddnet] <heinrich5991> > Because Dalvik's FileInputStream will close itself when it is garbage collected (this is also true for OpenJDK/Oracle) it is less common than you'd think to actually leak file descriptors. Of course, the file descriptors will be "leaked" until the GC runs so depending on your program it could take a while before they are reclaimed.
19:53 <+bridge> [ddnet] <Comrade> yes, it seems some GC implementation can close it
19:53 <+bridge> [ddnet] <Comrade> yes, it seems some GC implementations can close it
19:54 <+bridge> [ddnet] <heinrich5991> give me one that cannot
19:54 <+bridge> [ddnet] <Learath2> Well I don't think the standard guarantees it
19:54 <+bridge> [ddnet] <Comrade> some testing is needed üòÑ
19:54 <+bridge> [ddnet] <heinrich5991> source? I really don't think this is true
19:54 <+bridge> [ddnet] <Learath2> nvm, the standard does guarantee it
19:55 <+bridge> [ddnet] <Comrade> nice
19:55 <+bridge> [ddnet] <Ryozuki> :frozen:
19:55 <+bridge> [ddnet] <Learath2> It still does linger around until the GC gets to it though, depending on the load and the GC it might stick around forever üòõ
19:55 <+bridge> [ddnet] <heinrich5991> I guess
19:55 <+bridge> [ddnet] <Comrade> GC in Java is so lazy anyway üòÑ
19:56 <+bridge> [ddnet] <Learath2> Well I'm sure there is some clause in the standard that requires gc be run atleast sometimes, to avoid exactly this issue
19:56 <+bridge> [ddnet] <heinrich5991> + OS resources might be quite limited. but I don't think it's really required for the error case of IOException while writing to the file
19:56 <+bridge> [ddnet] <Comrade> maybe System.gc() or how is it called?
19:56 <+bridge> [ddnet] <heinrich5991> that only fails if the actual writing fails
19:57 <+bridge> [ddnet] <Ryozuki> https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Copy-on-write
19:57 <+bridge> [ddnet] <Ryozuki> :o u can use Cow in c++, rust has this in the standard tho :bluekitty:
19:57 <+bridge> [ddnet] <Comrade> so, it's probably better to call "close" in "finally" block to get somewhat deterministic resource management
19:58 <+bridge> [ddnet] <Learath2> @Ryozuki this is one of the ugliest idioms I've ever encountered, don't use it if you value your life
19:58 <+bridge> [ddnet] <Ryozuki> Cow is used a lot in rust tho
19:58 <+bridge> [ddnet] <Ryozuki> but i guess in c++ is ugly
19:58 <+bridge> [ddnet] <Learath2> CoW is in general a great idea
19:58 <+bridge> [ddnet] <heinrich5991> doesn't look threadsafe
19:58 <+bridge> [ddnet] <Learath2> I wish there was a clean way to accomplish it in C++
19:58 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/std/borrow/enum.Cow.html
19:59 <+bridge> [ddnet] <heinrich5991> nvm my comment, class works differently than I expected
20:01 <+bridge> [ddnet] <Learath2> There really is no safe way to do this in C++ I would honestly just delete the copy constructor
20:02 <+bridge> [ddnet] <Learath2> Have a refcount, delete the copy constructor so as to only allow things to be explicitly copied and no modifications unless refcount == 1
20:02 <+bridge> [ddnet] <Learath2> (and even that probably has some safety issues I'm not thinking about right now)
20:11 <+bridge> [ddnet] <Ryozuki> https://www.nature.com/articles/d41586-020-03382-2
20:11 <+bridge> [ddnet] <Ryozuki> :toptri:
20:12 <+bridge> [ddnet] <Ryozuki> if anyone uses rust for AOC: https://github.com/gobanos/cargo-aoc
20:12 <+bridge> [ddnet] <Ryozuki> its quite tryhard tho
21:18 <+bridge> [ddnet] <Comrade> by the way, Rust is still being mainly developed by Mozilla, right?
21:19 <+bridge> [ddnet] <Ryozuki> Hm not quite sure, they want to found The Rust foundation
21:19 <+bridge> [ddnet] <Ryozuki> Microsoft facebook and others are interested in rust too
21:20 <+bridge> [ddnet] <Ryozuki> I hear m$$ uses it on some parts of windows
21:20 <+bridge> [ddnet] <Comrade> that would be epic üòÑ
21:20 <+bridge> [ddnet] <Ryozuki> https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html
21:20 <+bridge> [ddnet] <Ryozuki> Good read i guess
21:21 <+bridge> [ddnet] <Comrade> Mozilla is now heavily infiltrated by SFWs and they are doing really weird decisions, so let's hope Rust survives that
21:21 <+bridge> [ddnet] <Comrade> Mozilla is now heavily infiltrated by SJWs and they are doing really weird decisions, so let's hope Rust survives that
21:21 <+bridge> [ddnet] <Ryozuki> In 2015, with the launch of Rust 1.0, Rust established its project direction and governance independent of the Mozilla organization
21:22 <+bridge> [ddnet] <Comrade> smart move
21:22 <+bridge> [ddnet] <Ryozuki> @Comrade sjw will be everywhere
21:22 <+bridge> [ddnet] <Ryozuki> They are always dedicated enough
21:22 <+bridge> [ddnet] <Ryozuki> To get to a position
21:23 <+bridge> [ddnet] <Ryozuki> Whre they hold power
21:23 <+bridge> [ddnet] <Ryozuki> Shit smartphone
21:23 <+bridge> [ddnet] <Comrade> https://en.wikipedia.org/wiki/Servo_(software)
21:23 <+bridge> [ddnet] <Comrade> In August 2020 during the COVID-19 pandemic, due to lack of funds and organization restructuring, Mozilla laid off most of the Servo development team, along with its own threat management security team, to "adapt its finances to a post-COVID-19 world and re-focus the organization on new commercial services".
21:23 <+bridge> [ddnet] <Comrade> it's core component of Firefox, isn't it? üòÑ
21:23 <+bridge> [ddnet] <Ryozuki> Unless the BDFL holds them off
21:24 <+bridge> [ddnet] <Ryozuki> @Comrade nah
21:24 <+bridge> [ddnet] <Comrade> Servo is now under Linux Foundation
21:24 <+bridge> [ddnet] <Ryozuki> Its opt in
21:24 <+bridge> [ddnet] <Ryozuki> And is not stable
21:24 <+bridge> [ddnet] <Ryozuki> Thats good
21:24 <+bridge> [ddnet] <Ryozuki> Servo is a good project
22:09 <+bridge> [ddnet] <heinrich5991> @Comrade mozilla doesn't employ rust developers anymore, I think
22:09 <+bridge> [ddnet] <Comrade> good
23:02 <+bridge> [ddnet] <Spyry> What is sv_rcon_token_check
23:02 <+bridge> [ddnet] <Spyry> And How to use?
23:39 <+bridge> [ddnet] <fokkonaut> Never heard of
23:39 <+bridge> [ddnet] <fokkonaut> it
