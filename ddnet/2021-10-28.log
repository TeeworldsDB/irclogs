05:45 <+bridge> [ddnet] <Tsæ‡’æ•£> hmm
05:46 <+bridge> [ddnet] <Tsæ‡’æ•£> china is planning on requiring platforms to show ip geolocation alongside with usernames.
05:46 <+bridge> [ddnet] <Tsæ‡’æ•£> :monkaS:
06:14 <+bridge> [ddnet] <fokkonaut> I noticed a weird crash too in prediction code, i made a design changer and when the new map gets loaded there seems to be a crash sometimes, some index too high for the m_pTiley array from collision, idk why
06:15 <+bridge> [ddnet] <fokkonaut> yes
06:33 <+bridge> [ddnet] <DeÃ«ivid!> is it bad to revert a pull request?
06:35 <+bridge> [ddnet] <DeÃ«ivid!> is it bad to revert a pull request that has already been merged?
06:40 <+bridge> [ddnet] <aodq> I think the best option is to make a PR that reverts that PR.
06:43 <+bridge> [ddnet] <aodq> If you do that then the github PR might catch that it's been reverted, but I haven't ever tried
06:43 <+bridge> [ddnet] <aodq> If you do that then the github PR might catch that it's been reverted & re-open, but I haven't ever tried
06:44 <+bridge> [ddnet] <DeÃ«ivid!> yes, I mean this button creates the new PR but I don't know if it'll fuck up something xd
06:45 <+bridge> [ddnet] <DeÃ«ivid!> https://cdn.discordapp.com/attachments/293493549758939136/903142278695096330/unknown.png
06:46 <+bridge> [ddnet] <aodq> it won't fuck anything up, it creates a PR with the git revert commit. DDNet maintainers can deny your PR. But you probably want to make an issue if you haven't yet explaining why you are reverting the commit
06:46 <+bridge> [ddnet] <aodq> it won't fuck anything up, it creates a PR with the git revert commit. DDNet maintainers can deny your PR. But you probably want to make an issue if you haven't yet explaining why you are reverting the pr
06:48 <+bridge> [ddnet] <aodq> The git history will still be in-tact, so you don't have to worry about fucking up someone else's history like you would with rebase. The revert would be put at HEAD and anyone rebasing/merging would have to deal with that revert
06:48 <+bridge> [ddnet] <DeÃ«ivid!> it's just a .txt tho
06:49 <+bridge> [ddnet] <aodq> doesn't really matter what kind of file it is, even binary, all git does is maintain a history of diffs.
06:49 <+bridge> [ddnet] <aodq> if you created a .txt file then the revert would just remove it
06:51 <+bridge> [ddnet] <DeÃ«ivid!> so if I edited the .txt and then revert it, it'll go back to how it was before?
06:51 <+bridge> [ddnet] <aodq> yeah hold on i can just demonstrate this
06:54 <+bridge> [ddnet] <aodq> ```
06:54 <+bridge> [ddnet] <aodq> [I] /home/toad/repo/test > git log
06:54 <+bridge> [ddnet] <aodq> commit 5722bd316a408006fe39042c14b131d0e42da4f3 (HEAD -> master)
06:54 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:54 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:53:08 2021 -0700
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     Revert "changes bob to joe"
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     This reverts commit d78d20190b2edfa25909a8f91f7a0a83ab7ed047.
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq> commit d78d20190b2edfa25909a8f91f7a0a83ab7ed047
06:54 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:54 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:52:56 2021 -0700
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     changes bob to joe
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq> commit e0397f9787a068274c03b629c4d2ca461cf54e81
06:55 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:55 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:52:37 2021 -0700
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq>     adds initial test
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq> [I] /home/toad/repo/test > git diff HEAD~
06:55 <+bridge> [ddnet] <aodq> diff --git a/test.txt b/test.txt
06:55 <+bridge> [ddnet] <aodq> index 0870381..724b0fd 100644
06:55 <+bridge> [ddnet] <aodq> --- a/test.txt
06:55 <+bridge> [ddnet] <aodq> +++ b/test.txt
06:55 <+bridge> [ddnet] <aodq> @@ -1 +1 @@
06:55 <+bridge> [ddnet] <aodq> -hello there, my name is Joe.
06:55 <+bridge> [ddnet] <aodq> +hello there, my name is Bob.
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq> the last `git diff HEAD~2` doesn't print anything because there is no difference from the initial and last commit, bc the second commit was reverted
07:00 <+bridge> [ddnet] <DeÃ«ivid!> ah, ok
07:01 <+bridge> [ddnet] <DeÃ«ivid!> so it's better to make a new pr of the merged one
07:01 <+bridge> [ddnet] <DeÃ«ivid!> for what i want to do
07:01 <+bridge> [ddnet] <aodq> Yeah I think that revert button will do what you want
07:02 <+bridge> [ddnet] <aodq> if not, like if you wanted to extra work on top, you could just revert it from git commandline then make whatever other commits you need before you do a PR
07:03 <+bridge> [ddnet] <aodq> `git revert <commit-id>`
07:09 <+bridge> [ddnet] <DeÃ«ivid!> ty very much
11:28 <+bridge> [ddnet] <chillerdragon> If ubsan throws a error it is the line the error was first catched right? So not neccessarly the line the issue was caused in hm? I currently get "runtime error\: -nan is outside the range of representable values of type 'int'"
14:29 <+bridge> [ddnet] <chillerdragon> Any ideas on how to avoid conflicting defintions of keys.h and ncurses without editing keys.h? I try to include ncurses in ddnet and it yells at me that for example KEY\_BACKSPACE is defined already. Any chance we can rename all key constants in ddnet?
14:45 <+bridge> [ddnet] <deen> don't include both from the same cpp file?
14:46 <+bridge> [ddnet] <chillerdragon> hmm i mean sooner or later both are included
14:46 <+bridge> [ddnet] <deen> make the KEY_* enum an enum class KEY
14:46 <+bridge> [ddnet] <deen> then they are different
14:46 <+bridge> [ddnet] <chillerdragon> ?
14:46 <+bridge> [ddnet] <deen> enum class is better anyway
14:46 <+bridge> [ddnet] <chillerdragon> whats that
14:46 <+bridge> [ddnet] <chillerdragon> so you mean editing the keys.h?
14:46 <+bridge> [ddnet] <deen> https://en.cppreference.com/w/cpp/language/enum
14:47 <+bridge> [ddnet] <deen> well, editing the datasrc file that generates keys.h
14:47 <+bridge> [ddnet] <chillerdragon> ye ofc
14:47 <+bridge> [ddnet] <deen> and then in the source code use KEY::FIRST instead of KEY_FIRST
14:47 <+bridge> [ddnet] <chillerdragon> but then i diff with upstream
14:47 <+bridge> [ddnet] <chillerdragon> can we get that in ddnet?
14:47 <+bridge> [ddnet] <deen> I'd be ok with it, maybe wait for some other opinions
14:47 <+bridge> [ddnet] <deen> another alternative would be namespaces
14:48 <+bridge> [ddnet] <chillerdragon> would also fix the windows conflict
14:48 <+bridge> [ddnet] <chillerdragon> i did rename all keys from KEY\_BACKSPACE to TW\_KEY\_BACKSPACE once
14:48 <+bridge> [ddnet] <chillerdragon> thats maybe less typing
14:49 <+bridge> [ddnet] <chillerdragon> namespaces might be the coolest so in binds.cpp and so on we can do using namespace
14:59 <+bridge> [ddnet] <chillerdragon> image.png
14:59 <+bridge> [ddnet] <chillerdragon> https://cdn.discordapp.com/attachments/293493549758939136/903266643994619944/image.png
14:59 <+bridge> [ddnet] <chillerdragon> meh thats a bit ugly i can not do 1 = 30
15:00 <+bridge> [ddnet] <Ryozuki> ðŸ¥´
15:03 <+bridge> [ddnet] <Jupstar âœª> 1 = 30 ðŸ¤ª
15:03 <+bridge> [ddnet] <chillerdragon> \:D
15:21 <+bridge> [ddnet] <chillerdragon> image.png
15:21 <+bridge> [ddnet] <chillerdragon> https://cdn.discordapp.com/attachments/293493549758939136/903272144044183612/image.png
15:21 <+bridge> [ddnet] <chillerdragon> front end is hard
15:25 <+bridge> [ddnet] <Jupstar âœª> image.png
15:25 <+bridge> [ddnet] <Jupstar âœª> https://cdn.discordapp.com/attachments/293493549758939136/903273371133943838/image.png
15:26 <+bridge> [ddnet] <Jupstar âœª> guess u didnt rebase or smth?
15:30 <+bridge> [ddnet] <Ryozuki> chilledragon maybe try KB_1 KB_2 instead
15:30 <+bridge> [ddnet] <chillerdragon> yaya i saw and fixed it
15:31 <+bridge> [ddnet] <chillerdragon> KB as in KEYBOARD?
15:31 <+bridge> [ddnet] <Ryozuki> ye
15:31 <+bridge> [ddnet] <Ryozuki> i think it makes sense
15:31 <+bridge> [ddnet] <chillerdragon> would also be inconsistent then
15:31 <+bridge> [ddnet] <Ryozuki> there is already KP as in keypad
15:31 <+bridge> [ddnet] <Ryozuki> its consistent
15:31 <+bridge> [ddnet] <chillerdragon> KEY\:\:A does not have a KB prefix
15:31 <+bridge> [ddnet] <Ryozuki> _1 looks horrendous
15:31 <+bridge> [ddnet] <chillerdragon> it does
15:32 <+bridge> [ddnet] <Jupstar âœª> ONE\_1, then you can find it by name and by number \:D
15:32 <+bridge> [ddnet] <Ryozuki> lol
15:32 <+bridge> [ddnet] <chillerdragon> or just ONE ?
15:32 <+bridge> [ddnet] <Ryozuki> TWO_2
15:32 <+bridge> [ddnet] <Ryozuki> THREE_3
15:32 <+bridge> [ddnet] <Ryozuki> lmao
15:32 <+bridge> [ddnet] <chillerdragon> KEY\:\:ONE
15:32 <+bridge> [ddnet] <chillerdragon> KAY ONE
15:32 <+bridge> [ddnet] <chillerdragon> aaxaxaxaxax
15:32 <+bridge> [ddnet] <Ryozuki> ur german not russian
15:32 <+bridge> [ddnet] <Jupstar âœª> TEEWORLDS\_KEYBOARD\_KEY\_WITH\_NUMBER\_ONE\_OR\_NUMERICAL\_1
15:32 <+bridge> [ddnet] <Ryozuki> stop culture apropiation
15:32 <+bridge> [ddnet] <Ryozuki> laugh like a deutsch
15:33 <+bridge> [ddnet] <chillerdragon> \:D
15:33 <+bridge> [ddnet] <chillerdragon> i am rus
15:33 <+bridge> [ddnet] <Ryozuki> HÃ¶hÃ¶HÃ¶hÃ¶HÃ¶hÃ¶HÃ¶hÃ¶HÃ¶hÃ¶
15:33 <+bridge> [ddnet] <Ryozuki> this
15:33 <+bridge> [ddnet] <chillerdragon> lol
15:33 <+bridge> [ddnet] <chillerdragon> I honestly like KEY\:\:ONE
15:33 <+bridge> [ddnet] <chillerdragon> any opinions?
15:33 <+bridge> [ddnet] <Jupstar âœª> just use SDL keycodes xD
15:34 <+bridge> [ddnet] <Ryozuki> looking at those tsan prs
15:34 <+bridge> [ddnet] <Ryozuki> reminds me of rust
15:34 <+bridge> [ddnet] <chillerdragon> so remove keys.h u mean?
15:34 <+bridge> [ddnet] <Ryozuki> and the fact it wouldnt have ever happened
15:34 <+bridge> [ddnet] <Ryozuki> :greenthing:
15:34 <+bridge> [ddnet] <Jupstar âœª> i guess that wouldnt hurt
15:34 <+bridge> [ddnet] <chillerdragon> adventerous
15:34 <+bridge> [ddnet] <Jupstar âœª> its always a trade @Ryozuki
15:34 <+bridge> [ddnet] <Jupstar âœª> therefore less control over it
15:34 <+bridge> [ddnet] <Ryozuki> what
15:35 <+bridge> [ddnet] <Jupstar âœª> atleast if you want to stay in safe rust ofc
15:35 <+bridge> [ddnet] <Ryozuki> there is no trade here
15:35 <+bridge> [ddnet] <Ryozuki> rust is safe outright
15:35 <+bridge> [ddnet] <Jupstar âœª> but what happens under the hood? locking, memory barrier?
15:36 <+bridge> [ddnet] <Ryozuki> in rust u still use mutex condvars arcs etc
15:36 <+bridge> [ddnet] <Ryozuki> its just that u cant miss them
15:36 <+bridge> [ddnet] <Ryozuki> due to how Send + Sync trait works
15:36 <+bridge> [ddnet] <Ryozuki> u should learn rust to know what i mean
15:39 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/book/ch16-00-concurrency.html
15:39 <+bridge> [ddnet] <Learath2> I suggest you don't get into this with ryozuki, he will shoot you
15:39 <+bridge> [ddnet] <Ryozuki> :monkaS:
15:39 <+bridge> [ddnet] <Ryozuki> did we find out why that crash happens?
15:40 <+bridge> [ddnet] <Learath2> I'm still looking at the coredump blankly
15:40 <+bridge> [ddnet] <Learath2> the state the gameserver ended up in makes absolutely no sense to me
15:40 <+bridge> [ddnet] <Ryozuki> sucks its delaying the release
15:40 <+bridge> [ddnet] <Ryozuki> :feelsbadman:
15:40 <+bridge> [ddnet] <Jupstar âœª> i see, but then it probs catches too much in some cases?
15:40 <+bridge> [ddnet] <Jupstar âœª> 
15:40 <+bridge> [ddnet] <Jupstar âœª> what would happen if one thread reads a var, but writes to it later inside a mutex, and reads from a different thread with the mutex
15:40 <+bridge> [ddnet] <Learath2> We somehow end up with a zero'd out CCharacter inside the entity linked list
15:40 <+bridge> [ddnet] <chillerdragon> @Ryozuki\: when start rewtring parts of ddnet code base in rust?
15:41 <+bridge> [ddnet] <Ryozuki> probs never
15:41 <+bridge> [ddnet] <chillerdragon> why not
15:42 <+bridge> [ddnet] <Ryozuki> rewriting is too much effort
15:42 <+bridge> [ddnet] <chillerdragon> even only parts?
15:42 <+bridge> [ddnet] <Ryozuki> that would lose the point of using rust
15:42 <+bridge> [ddnet] <Ryozuki> since u will have c code
15:42 <+bridge> [ddnet] <Jupstar âœª> if rust gets new syntax xD
15:42 <+bridge> [ddnet] <Jupstar âœª> bcs that still sucks
15:42 <+bridge> [ddnet] <Ryozuki> lol
15:42 <+bridge> [ddnet] <Ryozuki> i like rust syntax
15:42 <+bridge> [ddnet] <chillerdragon> no syntax is worse than modern c++
15:43 <+bridge> [ddnet] <Ryozuki> ye i dislike modern c++
15:43 <+bridge> [ddnet] <Jupstar âœª> modern c++ is fine to me
15:43 <+bridge> [ddnet] <Ryozuki> its cuz they cant make it first class features
15:43 <+bridge> [ddnet] <Ryozuki> so they make some weird stuff
15:43 <+bridge> [ddnet] <Jupstar âœª> u just have to understand templates
15:43 <+bridge> [ddnet] <Learath2> Jupstar: A regular variable wouldn't be Send or Sync, so can't really happen iirc
15:43 <+bridge> [ddnet] <Ryozuki> magick
15:43 <+bridge> [ddnet] <Jupstar âœª> but how is it protected then?
15:43 <+bridge> [ddnet] <Jupstar âœª> (@Learath2)
15:43 <+bridge> [ddnet] <Jupstar âœª> over the borrow system?
15:44 <+bridge> [ddnet] <chillerdragon> ```C
15:44 <+bridge> [ddnet] <chillerdragon>             std::thread([after, task]() {
15:44 <+bridge> [ddnet] <chillerdragon>                 std::this_thread::sleep_for(std::chrono::milliseconds(after));
15:44 <+bridge> [ddnet] <chillerdragon>                 task();
15:44 <+bridge> [ddnet] <chillerdragon>             }).detach();
15:44 <+bridge> [ddnet] <chillerdragon> ```
15:44 <+bridge> [ddnet] <Ryozuki> the compiler automatically marks variables with Send and Sync
15:44 <+bridge> [ddnet] <Jupstar âœª> so is it protected or not xd
15:44 <+bridge> [ddnet] <Ryozuki> u cant have data races in rust
15:44 <+bridge> [ddnet] <Ryozuki> i think its even mathematically proved
15:45 <+bridge> [ddnet] <Jupstar âœª> see
15:45 <+bridge> [ddnet] <Jupstar âœª> and thats why i ask
15:45 <+bridge> [ddnet] <Ryozuki> you can still have
15:45 <+bridge> [ddnet] <Ryozuki> deadlocks tho
15:45 <+bridge> [ddnet] <Jupstar âœª> so you dont know what happens
15:45 <+bridge> [ddnet] <Jupstar âœª> the compiler does it automatically
15:45 <+bridge> [ddnet] <Learath2> If the compiler thinks it's safe it'll mark things with Send and Sync. You also have wrapping types which themselves are send/sync
15:45 <+bridge> [ddnet] <Ryozuki> ??
15:46 <+bridge> [ddnet] <Ryozuki> atomic variables for exampel are marked Send
15:46 <+bridge> [ddnet] <Jupstar âœª> i understand, but lets not use atomics
15:46 <+bridge> [ddnet] <Jupstar âœª> i want a variables used in 2 threads like in my example
15:47 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903278707609858088/unknown.png
15:47 <+bridge> [ddnet] <Jupstar âœª> the write is always protected, and the read from the other thread too
15:48 <+bridge> [ddnet] <Jupstar âœª> ok i write the c++ example, you do the same in rust ok? \:D
15:48 <+bridge> [ddnet] <Ryozuki> ok i try
15:48 <+bridge> [ddnet] <Ryozuki> xd
15:49 <+bridge> [ddnet] <Learath2> I have a feeling your example is going to be UB though since what you seem to be describing is a data race
15:49 <+bridge> [ddnet] <Ryozuki> hehe
15:50 <+bridge> [ddnet] <Ryozuki> you have to know, a Mutex alone doesnt allow you to share variables over threads in rust
15:50 <+bridge> [ddnet] <Ryozuki> you need a Arc too
15:50 <+bridge> [ddnet] <Learath2> (or I misunderstood, that is also possible)
15:53 <+bridge> [ddnet] <Ryozuki> :monkaS:
15:53 <+bridge> [ddnet] <Ryozuki> he is crafting c++ wizardry
15:53 <+bridge> [ddnet] <Jupstar âœª> ```c
15:53 <+bridge> [ddnet] <Jupstar âœª> #include <mutex>
15:53 <+bridge> [ddnet] <Jupstar âœª> #include <thread>
15:53 <+bridge> [ddnet] <Jupstar âœª> #include <stdio.h>
15:53 <+bridge> [ddnet] <Jupstar âœª> 
15:53 <+bridge> [ddnet] <Jupstar âœª> int ProtectMe = 0;
15:54 <+bridge> [ddnet] <Jupstar âœª> std::mutex m;
15:54 <+bridge> [ddnet] <Jupstar âœª> 
15:54 <+bridge> [ddnet] <Jupstar âœª> static void f() {
15:54 <+bridge> [ddnet] <Jupstar âœª>     bool breakloop = false;
15:54 <+bridge> [ddnet] <Jupstar âœª>     while(breakloop) {
15:54 <+bridge> [ddnet] <Jupstar âœª>         m.lock();
15:54 <+bridge> [ddnet] <Jupstar âœª>         printf("test %d", ProtectMe);
15:54 <+bridge> [ddnet] <Jupstar âœª>         if(ProtectMe >= 1000) {
15:54 <+bridge> [ddnet] <Jupstar âœª>             breakloop = true;
15:54 <+bridge> [ddnet] <Jupstar âœª>         }
15:54 <+bridge> [ddnet] <Jupstar âœª>         m.unlock();
15:54 <+bridge> [ddnet] <Jupstar âœª>     }
15:54 <+bridge> [ddnet] <Jupstar âœª> }
15:54 <+bridge> [ddnet] <Jupstar âœª> 
15:54 <+bridge> [ddnet] <Jupstar âœª> 
15:54 <+bridge> [ddnet] <Jupstar âœª> int main() {
15:54 <+bridge> [ddnet] <Jupstar âœª>     std::thread t(f);
15:54 <+bridge> [ddnet] <Jupstar âœª>     while(ProtectMe < 1000) {
15:54 <+bridge> [ddnet] <Jupstar âœª>         m.lock();
15:54 <+bridge> [ddnet] <Jupstar âœª>         ProtectMe++;
15:54 <+bridge> [ddnet] <Jupstar âœª>         m.unlock();
15:54 <+bridge> [ddnet] <Jupstar âœª>     } 
15:54 <+bridge> [ddnet] <Jupstar âœª>     t.join();
15:54 <+bridge> [ddnet] <Jupstar âœª> }
15:54 <+bridge> [ddnet] <Jupstar âœª> 
15:55 <+bridge> [ddnet] <Jupstar âœª> ojh
15:55 <+bridge> [ddnet] <Jupstar âœª> while (!breakloop)
15:55 <+bridge> [ddnet] <Jupstar âœª> [Edit](https://discord.com/channels/252358080522747904/293493549758939136/903280411843641415): ```c
15:55 <+bridge> [ddnet] <Jupstar âœª> #include <mutex>
15:55 <+bridge> [ddnet] <Jupstar âœª> #include <thread>
15:55 <+bridge> [ddnet] <Jupstar âœª> #include <stdio.h>
15:55 <+bridge> [ddnet] <Jupstar âœª> 
15:55 <+bridge> [ddnet] <Jupstar âœª> int ProtectMe = 0;
15:55 <+bridge> [ddnet] <Jupstar âœª> std::mutex m;
15:55 <+bridge> [ddnet] <Jupstar âœª> 
15:55 <+bridge> [ddnet] <Jupstar âœª> static void f() {
15:55 <+bridge> [ddnet] <Jupstar âœª>     bool breakloop = false;
15:55 <+bridge> [ddnet] <Jupstar âœª>     while(!breakloop) {
15:55 <+bridge> [ddnet] <Jupstar âœª>         m.lock();
15:55 <+bridge> [ddnet] <Jupstar âœª>         printf("test %d", ProtectMe);
15:55 <+bridge> [ddnet] <Jupstar âœª>         if(ProtectMe >= 1000) {
15:56 <+bridge> [ddnet] <Jupstar âœª>             breakloop = true;
15:56 <+bridge> [ddnet] <Jupstar âœª>         }
15:56 <+bridge> [ddnet] <Jupstar âœª>         m.unlock();
15:56 <+bridge> [ddnet] <Jupstar âœª>     }
15:56 <+bridge> [ddnet] <Jupstar âœª> }
15:56 <+bridge> [ddnet] <Jupstar âœª> 
15:56 <+bridge> [ddnet] <Jupstar âœª> 
15:56 <+bridge> [ddnet] <Jupstar âœª> int main() {
15:56 <+bridge> [ddnet] <Jupstar âœª>     std::thread t(f);
15:56 <+bridge> [ddnet] <Jupstar âœª>     while(ProtectMe < 1000) {
15:56 <+bridge> [ddnet] <Jupstar âœª>         m.lock();
15:56 <+bridge> [ddnet] <Jupstar âœª>         ProtectMe++;
15:56 <+bridge> [ddnet] <Jupstar âœª>         m.unlock();
15:56 <+bridge> [ddnet] <Jupstar âœª>     } 
15:56 <+bridge> [ddnet] <Jupstar âœª>     t.join();
15:56 <+bridge> [ddnet] <Jupstar âœª> }
15:56 <+bridge> [ddnet] <Jupstar âœª> 
15:56 <+bridge> [ddnet] <Ryozuki> dood
15:56 <+bridge> [ddnet] <Ryozuki> just come to discord
15:56 <+bridge> [ddnet] <Ryozuki> this bot sucks xd
15:56 <+bridge> [ddnet] <Jupstar âœª> soon
15:56 <+bridge> [ddnet] <Jupstar âœª> soon\:tm\:
15:56 <+bridge> [ddnet] <Jupstar âœª> https://godbolt.org/z/f3G98b38c
15:57 <+bridge> [ddnet] <Learath2> ok, this doesn't look like a data-race
15:58 <+bridge> [ddnet] <Learath2> Oh actually I think it is
15:58 <+bridge> [ddnet] <Jupstar âœª> thread2 never writes to it, so should be fine
15:58 <+bridge> [ddnet] <Jupstar âœª> all changes are visible to all threads
15:59 <+bridge> [ddnet] <Ryozuki> i can do this with a RwLock
16:00 <+bridge> [ddnet] <Jupstar âœª> if its possible then fine, but ofc no unsafe code \:D
16:01 <+bridge> [ddnet] <Jupstar âœª> its certainly not impossible for the compiler to see read only stuff, i just wonder if rust does it
16:01 <+bridge> [ddnet] <Jupstar âœª> or better\: if you know if it does it
16:01 <+bridge> [ddnet] <Jupstar âœª> or if it happens under the hood
16:02 <+bridge> [ddnet] <Ryozuki> ```rust
16:02 <+bridge> [ddnet] <Ryozuki> use std::sync::{Arc, RwLock};
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki> fn main() {
16:02 <+bridge> [ddnet] <Ryozuki>     let protect_me = Arc::new(RwLock::new(0));
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki>     let protect_me_thread = Arc::clone(&protect_me);
16:02 <+bridge> [ddnet] <Ryozuki>     let handle = std:ðŸ§µ:spawn(move || loop {
16:02 <+bridge> [ddnet] <Ryozuki>         let protect_me_thread = protect_me_thread.read().unwrap();
16:02 <+bridge> [ddnet] <Ryozuki>         if *protect_me_thread >= 1000 {
16:02 <+bridge> [ddnet] <Ryozuki>             println!("reached target");
16:02 <+bridge> [ddnet] <Ryozuki>             break;
16:02 <+bridge> [ddnet] <Ryozuki>         }
16:02 <+bridge> [ddnet] <Ryozuki>     });
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki>     while *protect_me.read().unwrap() < 1000 {
16:02 <+bridge> [ddnet] <Ryozuki>         println!("adding one");
16:02 <+bridge> [ddnet] <Ryozuki>         *protect_me.write().unwrap() += 1;
16:02 <+bridge> [ddnet] <Ryozuki>     }
16:02 <+bridge> [ddnet] <Ryozuki>     handle.join().ok();
16:02 <+bridge> [ddnet] <Ryozuki> }
16:02 <+bridge> [ddnet] <Ryozuki> ```
16:02 <+bridge> [ddnet] <Ryozuki> ez
16:02 <+bridge> [ddnet] <Learath2> > Okay, this is indeed safe and I don't think you can easily get the same assembly in rust
16:02 <+bridge> [ddnet] <Jupstar âœª> i dunno what exactly a RWLock is, is it read write lock, like a guard?
16:03 <+bridge> [ddnet] <Learath2> You needed an Arc, that's extra overhead, and you are reading the value under the lock unlike in jupstars example
16:03 <+bridge> [ddnet] <Learath2> RWLock is sort of like a mutex but it allows multiple readers and a single writer
16:05 <+bridge> [ddnet] <Learath2> Your example is only safe because the only write happens on the thread where the "unsafe" read happens btw
16:05 <+bridge> [ddnet] <Jupstar âœª> i mean to be fair i really like the concept of rust for other reasons @Ryozuki , bcs it basically prooves memory safety, which could be abused to build "less safe" processor designs in regard to the kernel/os, e.g. remove the ringsbut nobody can tell me that the above syntax is soo much better than c++ XDD
16:06 <+bridge> [ddnet] <Jupstar âœª> if there wouldnt be some trade, it wouldnt be considered high level ofc
16:07 <+bridge> [ddnet] <Jupstar âœª> yeah \:D
16:07 <+bridge> [ddnet] <Jupstar âœª> (@Learath2)
16:07 <+bridge> [ddnet] <Learath2> To be fair though, I think you'd just use an atomic here, should give you roughly the same performance on x86
16:07 <+bridge> [ddnet] <Ryozuki> i like more rust syntax tho
16:07 <+bridge> [ddnet] <Jupstar âœª> probably yes \:D
16:08 <+bridge> [ddnet] <Ryozuki> but u will never convince me
16:08 <+bridge> [ddnet] <Ryozuki> its subjective
16:08 <+bridge> [ddnet] <Jupstar âœª> yeah its ok
16:08 <+bridge> [ddnet] <Jupstar âœª> there are also ppl liking pythons syntax
16:08 <+bridge> [ddnet] <Ryozuki> have you found urself in a situation of the code u sent in a real project?
16:08 <+bridge> [ddnet] <Jupstar âœª> so i have to acept thats its subjective anyway xD
16:09 <+bridge> [ddnet] <Jupstar âœª> it happens in ddnet for example \:D
16:09 <+bridge> [ddnet] <Ryozuki> and ddnet segfaults a lot
16:09 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
16:09 <+bridge> [ddnet] <Learath2> I actually don't see how to get it to work in rust. @heinrich5991 could know, he is more of a rust wizard
16:09 <+bridge> [ddnet] <Ryozuki> ye he knows more
16:09 <+bridge> [ddnet] <Ryozuki> idk
16:09 <+bridge> [ddnet] <Ryozuki> maybe what jupstar is doing is ub?
16:09 <+bridge> [ddnet] <Jupstar âœª> but ddnet segfaults bcs of memory overflow or deletes
16:10 <+bridge> [ddnet] <Jupstar âœª> i doubt its UB
16:10 <+bridge> [ddnet] <Jupstar âœª> its just living at the limits
16:10 <+bridge> [ddnet] <Ryozuki> i doubt u get much more realistic perf with that than a Read write lock
16:11 <+bridge> [ddnet] <Jupstar âœª> non relaxed atomics for example, are pretty powerful, they are almost like a mutex just without threads waiting on it, but the constraits allow you to garantuee visisbility across threads even for non atomics
16:11 <+bridge> [ddnet] <Learath2> I don't think so, I took a look at the standard, seems fine since the only possible write that could conflict with the "unsafe" read is sequenced after the said read. No conflicting action = no data race atleast
16:11 <+bridge> [ddnet] <Jupstar âœª> thats also the reason lock free queues etc exists
16:11 <+bridge> [ddnet] <Jupstar âœª> probably not, not with modern hardware atleast
16:11 <+bridge> [ddnet] <Jupstar âœª> (@Ryozuki)
16:12 <+bridge> [ddnet] <Jupstar âœª> i litterally added a mutex to alot of sound calls, and made no real difference
16:12 <+bridge> [ddnet] <Jupstar âœª> (that werent there before)
16:13 <+bridge> [ddnet] <Jupstar âœª> i mean most stuff programmed today isnt designed for ultimate performance anyway \:D
16:13 <+bridge> [ddnet] <Learath2> Sometimes I wish there was a way to do extremely unsafe stuff without invoking UB. Like sometimes I really don't care about a data-race
16:13 <+bridge> [ddnet] <Jupstar âœª> i am still for a rethink of all software, the whole concept of theads suck, we need a design like GPUs do it, eheheheh
16:13 <+bridge> [ddnet] <Learath2> I'm okay with the reader getting incomplete/broken data
16:13 <+bridge> [ddnet] <Ryozuki> https://docs.rs/crossbeam/0.8.1/crossbeam/sync/struct.ShardedLock.html
16:13 <+bridge> [ddnet] <Ryozuki> ðŸ‘€
16:13 <+bridge> [ddnet] <Jupstar âœª> no write /read in one pipeline call
16:14 <+bridge> [ddnet] <Learath2> Like massively parralelized stuff? Not all tasks parallelize that well tho :/
16:14 <+bridge> [ddnet] <Jupstar âœª> i know
16:14 <+bridge> [ddnet] <Jupstar âœª> i just like the idea alot
16:14 <+bridge> [ddnet] <Jupstar âœª> thinking about it is very hard
16:14 <+bridge> [ddnet] <Jupstar âœª> even trying todo it
16:15 <+bridge> [ddnet] <Jupstar âœª> most ppl probs just write singlethreaded stuff, or "semi" threaded stuff
16:15 <+bridge> [ddnet] <Ryozuki> https://blog.pimaker.at/texts/rvc1/
16:17 <+bridge> [ddnet] <Learath2> I was wondering the feasibility of doing npc AI on a gpu. It's like the perfect task to parallelize
16:17 <+bridge> [ddnet] <Learath2> Could do like thousands of ai agents in a city like that
16:17 <+bridge> [ddnet] <Ryozuki> :monkaS:
16:18 <+bridge> [ddnet] <Learath2> I couldn't justify looking further into it since I worry just ferrying the data between the gpu and the cpu would be too slow for it to be worth until I get many thousands of ai agents
16:19 <+bridge> [ddnet] <Learath2> But with architectures like the M1 where you get compute cores very closely linked to the cpu it might just become feasible to do
16:20 <+bridge> [ddnet] <Jupstar âœª> yeah, very interesting indeed
16:20 <+bridge> [ddnet] <Ryozuki> i dislike m1
16:20 <+bridge> [ddnet] <Ryozuki> cuz
16:20 <+bridge> [ddnet] <Ryozuki> its made by apple
16:20 <+bridge> [ddnet] <Learath2> apple
16:20 <+bridge> [ddnet] <Ryozuki> imho it would be real progress is they made it open for everyone
16:20 <+bridge> [ddnet] <Jupstar âœª> a real strength of m1, i wonder if they can scale it to a desktop component, or if the heat is too much there
16:21 <+bridge> [ddnet] <Ryozuki> but i will never consider looking into a m1 or things to do with it
16:21 <+bridge> [ddnet] <Ryozuki> cuz its locked into apple
16:21 <+bridge> [ddnet] <Jupstar âœª> yeah ofc, i wouldnt buy it with macos xD, thats like a big downgrade
16:21 <+bridge> [ddnet] <Learath2> Did you see alder lake? Seems atleast we are getting big-core little-core
16:21 <+bridge> [ddnet] <Ryozuki> i didnt
16:22 <+bridge> [ddnet] <Learath2> I doubt we'll get compute cores this closely linked to the cpu outside of M1 anytime soon though and going thru pci there is always a real latency concern
16:22 <+bridge> [ddnet] <Jupstar âœª> its mostly the memory in m1 that makes it so fast i guess
16:22 <+bridge> [ddnet] <Ryozuki> and i wonder what kinds of hidden instructions or stuff apple processors have
16:22 <+bridge> [ddnet] <Ryozuki> this reminded me of a rly good vid i saw
16:23 <+bridge> [ddnet] <Ryozuki> about the mastermind that made a compiler with only movs
16:23 <+bridge> [ddnet] <Ryozuki> cant remember now
16:23 <+bridge> [ddnet] <Jupstar âœª> amd's 3rd gen is basically only increase cache size and get 20% more perf
16:23 <+bridge> [ddnet] <Ryozuki> https://www.youtube.com/watch?v=KrksBdWcZgQ
16:23 <+bridge> [ddnet] <Ryozuki> > A processor is not a trusted black box for running code; on the contrary, modern x86 chips are packed full of secret instructions and hardware bugs. In this talk, we'll demonstrate how page fault analysis and some creative processor fuzzing can be used to exhaustively search the x86 instruction set and uncover the secrets buried in your chipset.
16:23 <+bridge> [ddnet] <Ryozuki> this video is insane
16:23 <+bridge> [ddnet] <Ryozuki> i have to rewatch it
16:24 <+bridge> [ddnet] <ReiTW> apple uses arm arch now
16:24 <+bridge> [ddnet] <Jupstar âœª> x86 is also sooooo old, i really wish a modern CISC would exists, designed with instructions that make sense in 2021
16:24 <+bridge> [ddnet] <Learath2> Well it's the fact that m1 has unified memory that makes it so efficient. Consoles also use this to get amazing performance.
16:24 <+bridge> [ddnet] <Ryozuki> i also would like that
16:24 <+bridge> [ddnet] <Ryozuki> im sure shitload of stuff changed
16:24 <+bridge> [ddnet] <Learath2> Why would you want a modern CISC? RISC >>>> CISC ðŸ˜›
16:25 <+bridge> [ddnet] <Jupstar âœª> arm is also not really RISC
16:25 <+bridge> [ddnet] <Jupstar âœª> anymore
16:25 <+bridge> [ddnet] <Ryozuki> isnt making a modern instruction set  would also remove the need to conditionally enable simd stuff and so on
16:25 <+bridge> [ddnet] <Learath2> I wish RISC-V would get some more attention
16:25 <+bridge> [ddnet] <Ryozuki> wow my english sucks at that sentence
16:26 <+bridge> [ddnet] <Ryozuki> the good thing about RISC is that you can program in asm realistically right?
16:26 <+bridge> [ddnet] <Ryozuki> xd
16:26 <+bridge> [ddnet] <Jupstar âœª> but i feel that
16:26 <+bridge> [ddnet] <Jupstar âœª> i think NEON didnt exist before v7
16:28 <+bridge> [ddnet] <Learath2> With a RISC fixed-length ISA you could feasibly read bytecode even. It'd make disassemblers so much easier to implement. It'd also simplify the decode step immensely
16:29 <+bridge> [ddnet] <Jupstar âœª> yeah thats true
16:29 <+bridge> [ddnet] <Jupstar âœª> i wonder how much diff the 5nm makes, i really wonder how close apple is to x86 desktop chips
16:29 <+bridge> [ddnet] <Jupstar âœª> but they need all the same circumstances to compare, and more software, not only video editors
16:30 <+bridge> [ddnet] <Learath2> Apparently the nm thing is a bit deceptive. I wonder if we should start talking in terms of transistor density instead or sth
16:30 <+bridge> [ddnet] <Jupstar âœª> and ofc, i wonder how they arch would scale to a desktop chip, so 100-200 watt TDP
16:30 <+bridge> [ddnet] <Ryozuki> is alder lake 10nm?
16:30 <+bridge> [ddnet] <Ryozuki> ye
16:30 <+bridge> [ddnet] <Jupstar âœª> yeah thats true, but i mean like if they all makes their chips at the same company
16:30 <+bridge> [ddnet] <Jupstar âœª> (@Learath2)
16:30 <+bridge> [ddnet] <Ryozuki> im still a amd fan tho
16:31 <+bridge> [ddnet] <Ryozuki> im happy with my 5600x
16:31 <+bridge> [ddnet] <Learath2> Seems intels 10nm process lead to a similar transistor size to tsmcs 7nm process
16:32 <+bridge> [ddnet] <Jupstar âœª> intel seems to be good in also making other stuff smaller, e.g. the memory controler
16:32 <+bridge> [ddnet] <Jupstar âœª> i read somewhere a year ago or smth, that these are still often in 30nm+
16:32 <+bridge> [ddnet] <Learath2> I'm a huge fan of big-core little-core btw. It's something I wished existed for years
16:32 <+bridge> [ddnet] <Learath2> Hope AMD comes out with a hybrid offering soon too
16:33 <+bridge> [ddnet] <Jupstar âœª> but only for laptops?
16:33 <+bridge> [ddnet] <Ryozuki> https://wccftech.com/amd-big-little-processor-cores-show-up-in-latest-patent-coming-to-next-gen-ryzen-cpus-apus/
16:33 <+bridge> [ddnet] <Learath2> Alder Lake is a desktop cpu, so not anymore ðŸ˜›
16:33 <+bridge> [ddnet] <Jupstar âœª> for desktop it seems like the motherboard is more powerhungry in idle
16:35 <+bridge> [ddnet] <Learath2> Power savings are not the only concern. With the OS Scheduler cooperating with the cpu, and the fact that you can fit multiple small cores instead of one big core, we might finally get a more responsive system
16:36 <+bridge> [ddnet] <Jupstar âœª> oh ok, possible yeah, i am not that much into what causes most latency bottlenecks \:D
17:04 <+bridge> [ddnet] <Jupstar âœª> @Learath2\: have you tried to build the server in a clean environment? maybe even with LTO to make sure its not data curroption, i also had data curroption after the bug in detect.h
17:04 <+bridge> [ddnet] <Jupstar âœª> for the server bug
17:05 <+bridge> [ddnet] <Jupstar âœª> (data curroption in the build process bcs of ODR)
17:06 <+bridge> [ddnet] <Jupstar âœª> i really cant find anything broken else \:/
17:11 <+bridge> [ddnet] <Learath2> The fact that it happens randomly makes it so hard to check
17:12 <+bridge> [ddnet] <Ryozuki> ye sucks
17:12 <+bridge> [ddnet] <Ryozuki> did u try it with jupstar new patch
17:12 <+bridge> [ddnet] <Ryozuki> that fixes the data race?
17:12 <+bridge> [ddnet] <Ryozuki> maybe it changed when i removed those volatiles
17:12 <+bridge> [ddnet] <Ryozuki> i doubt tho
17:12 <+bridge> [ddnet] <Ryozuki> xd
17:13 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903300390378962964/unknown.png
17:13 <+bridge> [ddnet] <Ryozuki> :monkaS:
17:13 <+bridge> [ddnet] <Jupstar âœª> its only client \:D
17:13 <+bridge> [ddnet] <Jupstar âœª> (@Ryozuki)
17:13 <+bridge> [ddnet] <Ryozuki> ah xd
17:14 <+bridge> [ddnet] <Jupstar âœª> yeah but i'd really suggest trying it, as said i also had ODR errors when i rebased without clearing the build dir
17:14 <+bridge> [ddnet] <Jupstar âœª> (@Learath2)
17:14 <+bridge> [ddnet] <Ryozuki> https://github.com/ddnet/ddnet/pull/4217/files
17:14 <+bridge> [ddnet] <Ryozuki> maybe
17:14 <+bridge> [ddnet] <Jupstar âœª> after the detect.h defect
17:14 <+bridge> [ddnet] <Ryozuki> the reentry guard
17:14 <+bridge> [ddnet] <Ryozuki> guards*
17:14 <+bridge> [ddnet] <Ryozuki> need to be atomic?
17:14 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903300806676197476/unknown.png
17:14 <+bridge> [ddnet] <Ryozuki> heinrich told me they didnt
17:14 <+bridge> [ddnet] <Jupstar âœª> i dont think so as i dont see another thread using it
17:15 <+bridge> [ddnet] <Jupstar âœª> https://github.com/ddnet/ddnet/commit/66947b70b773ef3e8184425e5a55ccf5de72e48b
17:15 <+bridge> [ddnet] <Jupstar âœª> 12 days ago
17:15 <+bridge> [ddnet] <Jupstar âœª> when did the crashes first happen?
17:15 <+bridge> [ddnet] <Ryozuki> atleast 5 days ago
17:16 <+bridge> [ddnet] <Jupstar âœª> https://github.com/ddnet/ddnet/commit/3b1c0748423a4a493ae6eb7536d16507499de9bc#diff-86d59021cb4561b3911602552aed980edc3ddf8b4846d5e59f09b3e863fff8e5
17:16 <+bridge> [ddnet] <Jupstar âœª> the bug was added 13. september
17:18 <+bridge> [ddnet] <Jupstar âœª> i'd just add smth like -DCMAKE\_CXX\_FLAGS="-flto" -DCMAKE\_C\_FLAGS="-flto" -DCMAKE\_EXE\_LINKER\_FLAGS="-flto" and see what the build says
17:18 <+bridge> [ddnet] <Jupstar âœª> and then remove it again if nothing is shown
17:18 <+bridge> [ddnet] <Jupstar âœª> (on the old build dir=
17:18 <+bridge> [ddnet] <Jupstar âœª> (on the old build dir)
17:19 <+bridge> [ddnet] <Ryozuki> are servers built with o3 or o2
17:19 <+bridge> [ddnet] <Ryozuki> maybe its a miscompilation xd
17:20 <+bridge> [ddnet] <Jupstar âœª> i guess normal release flags so o2
17:20 <+bridge> [ddnet] <Jupstar âœª> server isnt really hungry
17:21 <+bridge> [ddnet] <Jupstar âœª> or revert some changes and see when it happened, it seems like they happen every day
17:25 <+bridge> [ddnet] <Jupstar âœª> @Learath2\: are the servers always cleanly built? or are the old build dirs reused?
17:31 <+bridge> [ddnet] <deen> Jupstar: clean build
17:31 <+bridge> [ddnet] <Jupstar âœª> mhh too bad
17:31 <+bridge> [ddnet] <deen> ```
17:31 <+bridge> [ddnet] <deen> rm -rf ../master-build
17:31 <+bridge> [ddnet] <deen> mkdir ../master-build
17:31 <+bridge> [ddnet] <deen> cd ../master-build
17:31 <+bridge> [ddnet] <deen> cmake ../master -DANTIBOT=ON -DWEBSOCKETS=OFF -DMYSQL=ON -DCLIENT=OFF -DCMAKE_BUILD_TYPE=RelWithDebInfo
17:31 <+bridge> [ddnet] <deen> make DDNet-Server map_convert_07 map_optimize
17:31 <+bridge> [ddnet] <deen> ```
17:32 <+bridge> [ddnet] <Jupstar âœª> alright, from the latest UBSan report it looks like it gets mem\_zero'd somehow
17:32 <+bridge> [ddnet] <Jupstar âœª> vptr is 0
17:32 <+bridge> [ddnet] <Jupstar âœª> thats not really common
17:34 <+bridge> [ddnet] <Jupstar âœª> @deen\: so whats the plan, revert some commits and see what happens?, i guess it must be somwhere from the anti startline skips until master
17:34 <+bridge> [ddnet] <deen> I have no plan
17:35 <+bridge> [ddnet] <deen> I could check dmesg on the servers to see when regular crashes started, but I wouldn't 100% be sure that it's those
17:36 <+bridge> [ddnet] <Learath2> I'm so lost, the entity we seem to be ticking on has no reference in the entire memory space of the process
17:36 <+bridge> [ddnet] <Learath2> where are we getting this weird entity even?
17:37 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903306611920076800/unknown.png
17:38 <+bridge> [ddnet] <Learath2> Actually this address isn't even mapped??
17:40 <+bridge> [ddnet] <Jupstar âœª> the fact that all sanitizers cant catch it really speaks for either uninitialized, data race or logic error
17:41 <+bridge> [ddnet] <Jupstar âœª> but that should be ez to find in the commits
17:41 <+bridge> [ddnet] <Jupstar âœª> since its no overflow
17:42 <+bridge> [ddnet] <Learath2> AHA I think I have an idea
17:42 <+bridge> [ddnet] <Jupstar âœª> ok tw also uses memory pools, so i dunno how the sanitizers react to it \:D
17:44 <+bridge> [ddnet] <Learath2> Hm this member variable `m_pNextTraverseEntity`Â is so sus
17:44 <+bridge> [ddnet] <Learath2> Why is it a member variable?
17:46 <+bridge> [ddnet] <Jupstar âœª> yeah looks like it makes no sense
17:46 <+bridge> [ddnet] <Jupstar âœª> but also doesnt see any problem with it
17:47 <+bridge> [ddnet] <Jupstar âœª> but maybe its used recursivly somewhere
17:47 <+bridge> [ddnet] <Jupstar âœª> RemoveEntity for example, so i guess it can make sense
17:53 <+bridge> [ddnet] <Learath2> The problem is this insane value out of nowhere, I don't see this memory address referenced on any of the linked lists
17:54 <+bridge> [ddnet] <Learath2> There seems to be no alive characters, and `m_apFirstEntityTypes[ENTTYPE_CHARACTER]` is indeed 0x0
17:59 <+bridge> [ddnet] <Learath2> I think you are on to something there
17:59 <+bridge> [ddnet] <Learath2> that code looks very very sus
18:07 <+bridge> [ddnet] <Ryozuki> sus
18:07 <+bridge> [ddnet] <Ryozuki> christmas is soon
18:07 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903314099155386398/icyafwgzm5w71.png
18:07 <+bridge> [ddnet] <Learath2> Hm, the member thing seems to be to ensure that if within Tick an entity gets removed the traversal doesn't break
18:08 <+bridge> [ddnet] <Learath2> Neither draggers nor pickups kill you, right?
18:09 <+bridge> [ddnet] <Jupstar âœª> i mean deen is right, that its sus that it always happens if a player leaves
18:10 <+bridge> [ddnet] <Jupstar âœª> it somehow has to happen before the tick starts, but besides the antibot i dont see anything
18:10 <+bridge> [ddnet] <Learath2> It seems to always happen when a player leaves than another kills
18:10 <+bridge> [ddnet] <Jupstar âœª> yeah true
18:10 <+bridge> [ddnet] <Ryozuki> wouldnt that be awesome to create tests with the headless server we can now have
18:10 <+bridge> [ddnet] <Ryozuki> maybe we could reproduce tick perfect bugs
18:11 <+bridge> [ddnet] <Ryozuki> headless client
18:11 <+bridge> [ddnet] <Ryozuki> idk what im talking
18:13 <+bridge> [ddnet] <Jupstar âœª> ```
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][server]: client dropped. cid=9 addr=<{X}> reason=''
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][game]: kill killer='9:Maybe.' victim='9:Maybe.' weapon=-3 special=0
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][chat]: *** 'Maybe.' has left the game
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][game]: leave player='9:Maybe.'
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][game]: kill killer='10:[D] Maybe.' victim='10:[D] Maybe.' weapon=-1 special=0
18:13 <+bridge> [ddnet] <Jupstar âœª> [2021-10-27 10:21:06][game]: kill killer='10:[D] Maybe.' victim='10:[D] Maybe.' weapon=-2 special=0
18:13 <+bridge> [ddnet] <Jupstar âœª> ```He leaves and his dummy dies in spikes and self kills afterwards ? XD
18:13 <+bridge> [ddnet] <Jupstar âœª> that alone is sus
18:14 <+bridge> [ddnet] <Jupstar âœª> maybe u just have to kill while the world kills you or smth, but why the player leave? maybe a bug in the dummy code that does it for some reason?
18:15 <+bridge> [ddnet] <Learath2> Hm maybe the dummy also left but it crashed before that leave went through?
18:15 <+bridge> [ddnet] <Jupstar âœª> possible yeah
18:16 <+bridge> [ddnet] <Jupstar âœª> i wonder if that was on dummy maps
18:16 <+bridge> [ddnet] <Jupstar âœª> where e.g. startline kills you
18:38 <+bridge> [ddnet] <Jupstar âœª> mhh the startline skip kills you when someone leaves the team after you hit the start line, and thats the only commit that changed kill behavior lately
18:38 <+bridge> [ddnet] <Learath2> I found some stack addresses where the insane entity pointer is found, not sure how best to figure out what was stored in these stack variables
18:42 <+bridge> [ddnet] <Jupstar âœª> from the flow it would fit
18:42 <+bridge> [ddnet] <Jupstar âœª> it kills the char in the world tick, then self kills in team start line skip tick
18:43 <+bridge> [ddnet] <Jupstar âœª> (it uses WEAPON\_SELF)
18:50 <+bridge> [ddnet] <Jupstar âœª> too bad that we dont log the server tick
18:51 <+bridge> [ddnet] <Jupstar âœª> only self kill that happens after the tick is this i think, the rest are console commands
19:01 <+bridge> [ddnet] <DeÃ«ivid!> What's the difference between these?
19:01 <+bridge> [ddnet] <DeÃ«ivid!> https://cdn.discordapp.com/attachments/293493549758939136/903327562497917019/unknown.png
19:06 <+bridge> [ddnet] <Jupstar âœª> fullscreen minimizes the other doesnt
19:06 <+bridge> [ddnet] <Jupstar âœª> fullscreen might disable stuff like the windows compositor so its exclusive
19:06 <+bridge> [ddnet] <Jupstar âœª> also you can only change fullscreen resolution with fullscreen
19:08 <+bridge> [ddnet] <DeÃ«ivid!> so Desktop fullscreen uses like the native resolution?
19:08 <+bridge> [ddnet] <DeÃ«ivid!> so Desktop fullscreen uses like the native resolution only?
19:08 <+bridge> [ddnet] <Jupstar âœª> it uses your desktops resolution
19:08 <+bridge> [ddnet] <DeÃ«ivid!> ah ok
19:08 <+bridge> [ddnet] <DeÃ«ivid!> ty
19:29 <+bridge> [ddnet] <uwu> Woah uh oh hmm
19:29 <+bridge> [ddnet] <uwu> https://cdn.discordapp.com/attachments/293493549758939136/903334770547769404/Screenshot_2021-10-28-20-29-31-154_com.valvesoftware.android.steam.community.jpg
19:30 <+bridge> [ddnet] <Ryozuki> :thonk:
19:35 <+bridge> [ddnet] <gerdoe> https://media.discordapp.net/attachments/737521938045599745/884617389726113802/Fa5C2k8GB1c.gif
19:36 <+bridge> [ddnet] <Jupstar âœª> @Learath2\: just remove all these pool hacks and let asan detect the issue then we know xd, cant be that hard
20:53 <+bridge> [ddnet] <nuborn> The last two kills in a row seems like what you get when the team is locked and someone dies from kill tiles
21:31 <+bridge> [ddnet] <Jupstar âœª> i guess the starting date of the crashes could already help
