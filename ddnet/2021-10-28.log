05:45 <+bridge> [ddnet] <TsÊáíÊï£> hmm
05:46 <+bridge> [ddnet] <TsÊáíÊï£> china is planning on requiring platforms to show ip geolocation alongside with usernames.
05:46 <+bridge> [ddnet] <TsÊáíÊï£> :monkaS:
06:14 <+bridge> [ddnet] <fokkonaut> I noticed a weird crash too in prediction code, i made a design changer and when the new map gets loaded there seems to be a crash sometimes, some index too high for the m_pTiley array from collision, idk why
06:15 <+bridge> [ddnet] <fokkonaut> yes
06:33 <+bridge> [ddnet] <De√´ivid!> is it bad to revert a pull request?
06:35 <+bridge> [ddnet] <De√´ivid!> is it bad to revert a pull request that has already been merged?
06:40 <+bridge> [ddnet] <aodq> I think the best option is to make a PR that reverts that PR.
06:43 <+bridge> [ddnet] <aodq> If you do that then the github PR might catch that it's been reverted, but I haven't ever tried
06:43 <+bridge> [ddnet] <aodq> If you do that then the github PR might catch that it's been reverted & re-open, but I haven't ever tried
06:44 <+bridge> [ddnet] <De√´ivid!> yes, I mean this button creates the new PR but I don't know if it'll fuck up something xd
06:45 <+bridge> [ddnet] <De√´ivid!> https://cdn.discordapp.com/attachments/293493549758939136/903142278695096330/unknown.png
06:46 <+bridge> [ddnet] <aodq> it won't fuck anything up, it creates a PR with the git revert commit. DDNet maintainers can deny your PR. But you probably want to make an issue if you haven't yet explaining why you are reverting the commit
06:46 <+bridge> [ddnet] <aodq> it won't fuck anything up, it creates a PR with the git revert commit. DDNet maintainers can deny your PR. But you probably want to make an issue if you haven't yet explaining why you are reverting the pr
06:48 <+bridge> [ddnet] <aodq> The git history will still be in-tact, so you don't have to worry about fucking up someone else's history like you would with rebase. The revert would be put at HEAD and anyone rebasing/merging would have to deal with that revert
06:48 <+bridge> [ddnet] <De√´ivid!> it's just a .txt tho
06:49 <+bridge> [ddnet] <aodq> doesn't really matter what kind of file it is, even binary, all git does is maintain a history of diffs.
06:49 <+bridge> [ddnet] <aodq> if you created a .txt file then the revert would just remove it
06:51 <+bridge> [ddnet] <De√´ivid!> so if I edited the .txt and then revert it, it'll go back to how it was before?
06:51 <+bridge> [ddnet] <aodq> yeah hold on i can just demonstrate this
06:54 <+bridge> [ddnet] <aodq> ```
06:54 <+bridge> [ddnet] <aodq> [I] /home/toad/repo/test > git log
06:54 <+bridge> [ddnet] <aodq> commit 5722bd316a408006fe39042c14b131d0e42da4f3 (HEAD -> master)
06:54 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:54 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:53:08 2021 -0700
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     Revert "changes bob to joe"
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     This reverts commit d78d20190b2edfa25909a8f91f7a0a83ab7ed047.
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq> commit d78d20190b2edfa25909a8f91f7a0a83ab7ed047
06:54 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:54 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:52:56 2021 -0700
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq>     changes bob to joe
06:54 <+bridge> [ddnet] <aodq> 
06:54 <+bridge> [ddnet] <aodq> commit e0397f9787a068274c03b629c4d2ca461cf54e81
06:55 <+bridge> [ddnet] <aodq> Author: aodq <0@aodq.net>
06:55 <+bridge> [ddnet] <aodq> Date:   Wed Oct 27 17:52:37 2021 -0700
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq>     adds initial test
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq> [I] /home/toad/repo/test > git diff HEAD~
06:55 <+bridge> [ddnet] <aodq> diff --git a/test.txt b/test.txt
06:55 <+bridge> [ddnet] <aodq> index 0870381..724b0fd 100644
06:55 <+bridge> [ddnet] <aodq> --- a/test.txt
06:55 <+bridge> [ddnet] <aodq> +++ b/test.txt
06:55 <+bridge> [ddnet] <aodq> @@ -1 +1 @@
06:55 <+bridge> [ddnet] <aodq> -hello there, my name is Joe.
06:55 <+bridge> [ddnet] <aodq> +hello there, my name is Bob.
06:55 <+bridge> [ddnet] <aodq> 
06:55 <+bridge> [ddnet] <aodq> the last `git diff HEAD~2` doesn't print anything because there is no difference from the initial and last commit, bc the second commit was reverted
07:00 <+bridge> [ddnet] <De√´ivid!> ah, ok
07:01 <+bridge> [ddnet] <De√´ivid!> so it's better to make a new pr of the merged one
07:01 <+bridge> [ddnet] <De√´ivid!> for what i want to do
07:01 <+bridge> [ddnet] <aodq> Yeah I think that revert button will do what you want
07:02 <+bridge> [ddnet] <aodq> if not, like if you wanted to extra work on top, you could just revert it from git commandline then make whatever other commits you need before you do a PR
07:03 <+bridge> [ddnet] <aodq> `git revert <commit-id>`
07:09 <+bridge> [ddnet] <De√´ivid!> ty very much
11:28 <+bridge> [ddnet] <chillerdragon> If ubsan throws a error it is the line the error was first catched right? So not neccessarly the line the issue was caused in hm? I currently get "runtime error\: -nan is outside the range of representable values of type 'int'"
14:29 <+bridge> [ddnet] <chillerdragon> Any ideas on how to avoid conflicting defintions of keys.h and ncurses without editing keys.h? I try to include ncurses in ddnet and it yells at me that for example KEY\_BACKSPACE is defined already. Any chance we can rename all key constants in ddnet?
14:45 <+bridge> [ddnet] <deen> don't include both from the same cpp file?
14:46 <+bridge> [ddnet] <chillerdragon> hmm i mean sooner or later both are included
14:46 <+bridge> [ddnet] <deen> make the KEY_* enum an enum class KEY
14:46 <+bridge> [ddnet] <deen> then they are different
14:46 <+bridge> [ddnet] <chillerdragon> ?
14:46 <+bridge> [ddnet] <deen> enum class is better anyway
14:46 <+bridge> [ddnet] <chillerdragon> whats that
14:46 <+bridge> [ddnet] <chillerdragon> so you mean editing the keys.h?
14:46 <+bridge> [ddnet] <deen> https://en.cppreference.com/w/cpp/language/enum
14:47 <+bridge> [ddnet] <deen> well, editing the datasrc file that generates keys.h
14:47 <+bridge> [ddnet] <chillerdragon> ye ofc
14:47 <+bridge> [ddnet] <deen> and then in the source code use KEY::FIRST instead of KEY_FIRST
14:47 <+bridge> [ddnet] <chillerdragon> but then i diff with upstream
14:47 <+bridge> [ddnet] <chillerdragon> can we get that in ddnet?
14:47 <+bridge> [ddnet] <deen> I'd be ok with it, maybe wait for some other opinions
14:47 <+bridge> [ddnet] <deen> another alternative would be namespaces
14:48 <+bridge> [ddnet] <chillerdragon> would also fix the windows conflict
14:48 <+bridge> [ddnet] <chillerdragon> i did rename all keys from KEY\_BACKSPACE to TW\_KEY\_BACKSPACE once
14:48 <+bridge> [ddnet] <chillerdragon> thats maybe less typing
14:49 <+bridge> [ddnet] <chillerdragon> namespaces might be the coolest so in binds.cpp and so on we can do using namespace
14:59 <+bridge> [ddnet] <chillerdragon> image.png
14:59 <+bridge> [ddnet] <chillerdragon> https://cdn.discordapp.com/attachments/293493549758939136/903266643994619944/image.png
14:59 <+bridge> [ddnet] <chillerdragon> meh thats a bit ugly i can not do 1 = 30
15:00 <+bridge> [ddnet] <Ryozuki> ü•¥
15:03 <+bridge> [ddnet] <Jupstar ‚ú™> 1 = 30 ü§™
15:03 <+bridge> [ddnet] <chillerdragon> \:D
15:21 <+bridge> [ddnet] <chillerdragon> image.png
15:21 <+bridge> [ddnet] <chillerdragon> https://cdn.discordapp.com/attachments/293493549758939136/903272144044183612/image.png
15:21 <+bridge> [ddnet] <chillerdragon> front end is hard
15:25 <+bridge> [ddnet] <Jupstar ‚ú™> image.png
15:25 <+bridge> [ddnet] <Jupstar ‚ú™> https://cdn.discordapp.com/attachments/293493549758939136/903273371133943838/image.png
15:26 <+bridge> [ddnet] <Jupstar ‚ú™> guess u didnt rebase or smth?
15:30 <+bridge> [ddnet] <Ryozuki> chilledragon maybe try KB_1 KB_2 instead
15:30 <+bridge> [ddnet] <chillerdragon> yaya i saw and fixed it
15:31 <+bridge> [ddnet] <chillerdragon> KB as in KEYBOARD?
15:31 <+bridge> [ddnet] <Ryozuki> ye
15:31 <+bridge> [ddnet] <Ryozuki> i think it makes sense
15:31 <+bridge> [ddnet] <chillerdragon> would also be inconsistent then
15:31 <+bridge> [ddnet] <Ryozuki> there is already KP as in keypad
15:31 <+bridge> [ddnet] <Ryozuki> its consistent
15:31 <+bridge> [ddnet] <chillerdragon> KEY\:\:A does not have a KB prefix
15:31 <+bridge> [ddnet] <Ryozuki> _1 looks horrendous
15:31 <+bridge> [ddnet] <chillerdragon> it does
15:32 <+bridge> [ddnet] <Jupstar ‚ú™> ONE\_1, then you can find it by name and by number \:D
15:32 <+bridge> [ddnet] <Ryozuki> lol
15:32 <+bridge> [ddnet] <chillerdragon> or just ONE ?
15:32 <+bridge> [ddnet] <Ryozuki> TWO_2
15:32 <+bridge> [ddnet] <Ryozuki> THREE_3
15:32 <+bridge> [ddnet] <Ryozuki> lmao
15:32 <+bridge> [ddnet] <chillerdragon> KEY\:\:ONE
15:32 <+bridge> [ddnet] <chillerdragon> KAY ONE
15:32 <+bridge> [ddnet] <chillerdragon> aaxaxaxaxax
15:32 <+bridge> [ddnet] <Ryozuki> ur german not russian
15:32 <+bridge> [ddnet] <Jupstar ‚ú™> TEEWORLDS\_KEYBOARD\_KEY\_WITH\_NUMBER\_ONE\_OR\_NUMERICAL\_1
15:32 <+bridge> [ddnet] <Ryozuki> stop culture apropiation
15:32 <+bridge> [ddnet] <Ryozuki> laugh like a deutsch
15:33 <+bridge> [ddnet] <chillerdragon> \:D
15:33 <+bridge> [ddnet] <chillerdragon> i am rus
15:33 <+bridge> [ddnet] <Ryozuki> H√∂h√∂H√∂h√∂H√∂h√∂H√∂h√∂H√∂h√∂
15:33 <+bridge> [ddnet] <Ryozuki> this
15:33 <+bridge> [ddnet] <chillerdragon> lol
15:33 <+bridge> [ddnet] <chillerdragon> I honestly like KEY\:\:ONE
15:33 <+bridge> [ddnet] <chillerdragon> any opinions?
15:33 <+bridge> [ddnet] <Jupstar ‚ú™> just use SDL keycodes xD
15:34 <+bridge> [ddnet] <Ryozuki> looking at those tsan prs
15:34 <+bridge> [ddnet] <Ryozuki> reminds me of rust
15:34 <+bridge> [ddnet] <chillerdragon> so remove keys.h u mean?
15:34 <+bridge> [ddnet] <Ryozuki> and the fact it wouldnt have ever happened
15:34 <+bridge> [ddnet] <Ryozuki> :greenthing:
15:34 <+bridge> [ddnet] <Jupstar ‚ú™> i guess that wouldnt hurt
15:34 <+bridge> [ddnet] <chillerdragon> adventerous
15:34 <+bridge> [ddnet] <Jupstar ‚ú™> its always a trade @Ryozuki
15:34 <+bridge> [ddnet] <Jupstar ‚ú™> therefore less control over it
15:34 <+bridge> [ddnet] <Ryozuki> what
15:35 <+bridge> [ddnet] <Jupstar ‚ú™> atleast if you want to stay in safe rust ofc
15:35 <+bridge> [ddnet] <Ryozuki> there is no trade here
15:35 <+bridge> [ddnet] <Ryozuki> rust is safe outright
15:35 <+bridge> [ddnet] <Jupstar ‚ú™> but what happens under the hood? locking, memory barrier?
15:36 <+bridge> [ddnet] <Ryozuki> in rust u still use mutex condvars arcs etc
15:36 <+bridge> [ddnet] <Ryozuki> its just that u cant miss them
15:36 <+bridge> [ddnet] <Ryozuki> due to how Send + Sync trait works
15:36 <+bridge> [ddnet] <Ryozuki> u should learn rust to know what i mean
15:39 <+bridge> [ddnet] <Ryozuki> https://doc.rust-lang.org/book/ch16-00-concurrency.html
15:39 <+bridge> [ddnet] <Learath2> I suggest you don't get into this with ryozuki, he will shoot you
15:39 <+bridge> [ddnet] <Ryozuki> :monkaS:
15:39 <+bridge> [ddnet] <Ryozuki> did we find out why that crash happens?
15:40 <+bridge> [ddnet] <Learath2> I'm still looking at the coredump blankly
15:40 <+bridge> [ddnet] <Learath2> the state the gameserver ended up in makes absolutely no sense to me
15:40 <+bridge> [ddnet] <Ryozuki> sucks its delaying the release
15:40 <+bridge> [ddnet] <Ryozuki> :feelsbadman:
15:40 <+bridge> [ddnet] <Jupstar ‚ú™> i see, but then it probs catches too much in some cases?
15:40 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:40 <+bridge> [ddnet] <Jupstar ‚ú™> what would happen if one thread reads a var, but writes to it later inside a mutex, and reads from a different thread with the mutex
15:40 <+bridge> [ddnet] <Learath2> We somehow end up with a zero'd out CCharacter inside the entity linked list
15:40 <+bridge> [ddnet] <chillerdragon> @Ryozuki\: when start rewtring parts of ddnet code base in rust?
15:41 <+bridge> [ddnet] <Ryozuki> probs never
15:41 <+bridge> [ddnet] <chillerdragon> why not
15:42 <+bridge> [ddnet] <Ryozuki> rewriting is too much effort
15:42 <+bridge> [ddnet] <chillerdragon> even only parts?
15:42 <+bridge> [ddnet] <Ryozuki> that would lose the point of using rust
15:42 <+bridge> [ddnet] <Ryozuki> since u will have c code
15:42 <+bridge> [ddnet] <Jupstar ‚ú™> if rust gets new syntax xD
15:42 <+bridge> [ddnet] <Jupstar ‚ú™> bcs that still sucks
15:42 <+bridge> [ddnet] <Ryozuki> lol
15:42 <+bridge> [ddnet] <Ryozuki> i like rust syntax
15:42 <+bridge> [ddnet] <chillerdragon> no syntax is worse than modern c++
15:43 <+bridge> [ddnet] <Ryozuki> ye i dislike modern c++
15:43 <+bridge> [ddnet] <Jupstar ‚ú™> modern c++ is fine to me
15:43 <+bridge> [ddnet] <Ryozuki> its cuz they cant make it first class features
15:43 <+bridge> [ddnet] <Ryozuki> so they make some weird stuff
15:43 <+bridge> [ddnet] <Jupstar ‚ú™> u just have to understand templates
15:43 <+bridge> [ddnet] <Learath2> Jupstar: A regular variable wouldn't be Send or Sync, so can't really happen iirc
15:43 <+bridge> [ddnet] <Ryozuki> magick
15:43 <+bridge> [ddnet] <Jupstar ‚ú™> but how is it protected then?
15:43 <+bridge> [ddnet] <Jupstar ‚ú™> (@Learath2)
15:43 <+bridge> [ddnet] <Jupstar ‚ú™> over the borrow system?
15:44 <+bridge> [ddnet] <chillerdragon> ```C
15:44 <+bridge> [ddnet] <chillerdragon>             std::thread([after, task]() {
15:44 <+bridge> [ddnet] <chillerdragon>                 std::this_thread::sleep_for(std::chrono::milliseconds(after));
15:44 <+bridge> [ddnet] <chillerdragon>                 task();
15:44 <+bridge> [ddnet] <chillerdragon>             }).detach();
15:44 <+bridge> [ddnet] <chillerdragon> ```
15:44 <+bridge> [ddnet] <Ryozuki> the compiler automatically marks variables with Send and Sync
15:44 <+bridge> [ddnet] <Jupstar ‚ú™> so is it protected or not xd
15:44 <+bridge> [ddnet] <Ryozuki> u cant have data races in rust
15:44 <+bridge> [ddnet] <Ryozuki> i think its even mathematically proved
15:45 <+bridge> [ddnet] <Jupstar ‚ú™> see
15:45 <+bridge> [ddnet] <Jupstar ‚ú™> and thats why i ask
15:45 <+bridge> [ddnet] <Ryozuki> you can still have
15:45 <+bridge> [ddnet] <Ryozuki> deadlocks tho
15:45 <+bridge> [ddnet] <Jupstar ‚ú™> so you dont know what happens
15:45 <+bridge> [ddnet] <Jupstar ‚ú™> the compiler does it automatically
15:45 <+bridge> [ddnet] <Learath2> If the compiler thinks it's safe it'll mark things with Send and Sync. You also have wrapping types which themselves are send/sync
15:45 <+bridge> [ddnet] <Ryozuki> ??
15:46 <+bridge> [ddnet] <Ryozuki> atomic variables for exampel are marked Send
15:46 <+bridge> [ddnet] <Jupstar ‚ú™> i understand, but lets not use atomics
15:46 <+bridge> [ddnet] <Jupstar ‚ú™> i want a variables used in 2 threads like in my example
15:47 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903278707609858088/unknown.png
15:47 <+bridge> [ddnet] <Jupstar ‚ú™> the write is always protected, and the read from the other thread too
15:48 <+bridge> [ddnet] <Jupstar ‚ú™> ok i write the c++ example, you do the same in rust ok? \:D
15:48 <+bridge> [ddnet] <Ryozuki> ok i try
15:48 <+bridge> [ddnet] <Ryozuki> xd
15:49 <+bridge> [ddnet] <Learath2> I have a feeling your example is going to be UB though since what you seem to be describing is a data race
15:49 <+bridge> [ddnet] <Ryozuki> hehe
15:50 <+bridge> [ddnet] <Ryozuki> you have to know, a Mutex alone doesnt allow you to share variables over threads in rust
15:50 <+bridge> [ddnet] <Ryozuki> you need a Arc too
15:50 <+bridge> [ddnet] <Learath2> (or I misunderstood, that is also possible)
15:53 <+bridge> [ddnet] <Ryozuki> :monkaS:
15:53 <+bridge> [ddnet] <Ryozuki> he is crafting c++ wizardry
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> ```c
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> #include <mutex>
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> #include <thread>
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> #include <stdio.h>
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:53 <+bridge> [ddnet] <Jupstar ‚ú™> int ProtectMe = 0;
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> std::mutex m;
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> static void f() {
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     bool breakloop = false;
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     while(breakloop) {
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         m.lock();
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         printf("test %d", ProtectMe);
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         if(ProtectMe >= 1000) {
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>             breakloop = true;
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         }
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         m.unlock();
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     }
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> }
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> int main() {
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     std::thread t(f);
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     while(ProtectMe < 1000) {
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         m.lock();
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         ProtectMe++;
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>         m.unlock();
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     } 
15:54 <+bridge> [ddnet] <Jupstar ‚ú™>     t.join();
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> }
15:54 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> ojh
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> while (!breakloop)
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> [Edit](https://discord.com/channels/252358080522747904/293493549758939136/903280411843641415): ```c
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> #include <mutex>
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> #include <thread>
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> #include <stdio.h>
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> int ProtectMe = 0;
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> std::mutex m;
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:55 <+bridge> [ddnet] <Jupstar ‚ú™> static void f() {
15:55 <+bridge> [ddnet] <Jupstar ‚ú™>     bool breakloop = false;
15:55 <+bridge> [ddnet] <Jupstar ‚ú™>     while(!breakloop) {
15:55 <+bridge> [ddnet] <Jupstar ‚ú™>         m.lock();
15:55 <+bridge> [ddnet] <Jupstar ‚ú™>         printf("test %d", ProtectMe);
15:55 <+bridge> [ddnet] <Jupstar ‚ú™>         if(ProtectMe >= 1000) {
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>             breakloop = true;
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>         }
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>         m.unlock();
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>     }
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> }
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> int main() {
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>     std::thread t(f);
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>     while(ProtectMe < 1000) {
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>         m.lock();
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>         ProtectMe++;
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>         m.unlock();
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>     } 
15:56 <+bridge> [ddnet] <Jupstar ‚ú™>     t.join();
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> }
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> 
15:56 <+bridge> [ddnet] <Ryozuki> dood
15:56 <+bridge> [ddnet] <Ryozuki> just come to discord
15:56 <+bridge> [ddnet] <Ryozuki> this bot sucks xd
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> soon
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> soon\:tm\:
15:56 <+bridge> [ddnet] <Jupstar ‚ú™> https://godbolt.org/z/f3G98b38c
15:57 <+bridge> [ddnet] <Learath2> ok, this doesn't look like a data-race
15:58 <+bridge> [ddnet] <Learath2> Oh actually I think it is
15:58 <+bridge> [ddnet] <Jupstar ‚ú™> thread2 never writes to it, so should be fine
15:58 <+bridge> [ddnet] <Jupstar ‚ú™> all changes are visible to all threads
15:59 <+bridge> [ddnet] <Ryozuki> i can do this with a RwLock
16:00 <+bridge> [ddnet] <Jupstar ‚ú™> if its possible then fine, but ofc no unsafe code \:D
16:01 <+bridge> [ddnet] <Jupstar ‚ú™> its certainly not impossible for the compiler to see read only stuff, i just wonder if rust does it
16:01 <+bridge> [ddnet] <Jupstar ‚ú™> or better\: if you know if it does it
16:01 <+bridge> [ddnet] <Jupstar ‚ú™> or if it happens under the hood
16:02 <+bridge> [ddnet] <Ryozuki> ```rust
16:02 <+bridge> [ddnet] <Ryozuki> use std::sync::{Arc, RwLock};
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki> fn main() {
16:02 <+bridge> [ddnet] <Ryozuki>     let protect_me = Arc::new(RwLock::new(0));
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki>     let protect_me_thread = Arc::clone(&protect_me);
16:02 <+bridge> [ddnet] <Ryozuki>     let handle = std:üßµ:spawn(move || loop {
16:02 <+bridge> [ddnet] <Ryozuki>         let protect_me_thread = protect_me_thread.read().unwrap();
16:02 <+bridge> [ddnet] <Ryozuki>         if *protect_me_thread >= 1000 {
16:02 <+bridge> [ddnet] <Ryozuki>             println!("reached target");
16:02 <+bridge> [ddnet] <Ryozuki>             break;
16:02 <+bridge> [ddnet] <Ryozuki>         }
16:02 <+bridge> [ddnet] <Ryozuki>     });
16:02 <+bridge> [ddnet] <Ryozuki> 
16:02 <+bridge> [ddnet] <Ryozuki>     while *protect_me.read().unwrap() < 1000 {
16:02 <+bridge> [ddnet] <Ryozuki>         println!("adding one");
16:02 <+bridge> [ddnet] <Ryozuki>         *protect_me.write().unwrap() += 1;
16:02 <+bridge> [ddnet] <Ryozuki>     }
16:02 <+bridge> [ddnet] <Ryozuki>     handle.join().ok();
16:02 <+bridge> [ddnet] <Ryozuki> }
16:02 <+bridge> [ddnet] <Ryozuki> ```
16:02 <+bridge> [ddnet] <Ryozuki> ez
16:02 <+bridge> [ddnet] <Learath2> > Okay, this is indeed safe and I don't think you can easily get the same assembly in rust
16:02 <+bridge> [ddnet] <Jupstar ‚ú™> i dunno what exactly a RWLock is, is it read write lock, like a guard?
16:03 <+bridge> [ddnet] <Learath2> You needed an Arc, that's extra overhead, and you are reading the value under the lock unlike in jupstars example
16:03 <+bridge> [ddnet] <Learath2> RWLock is sort of like a mutex but it allows multiple readers and a single writer
16:05 <+bridge> [ddnet] <Learath2> Your example is only safe because the only write happens on the thread where the "unsafe" read happens btw
16:05 <+bridge> [ddnet] <Jupstar ‚ú™> i mean to be fair i really like the concept of rust for other reasons @Ryozuki , bcs it basically prooves memory safety, which could be abused to build "less safe" processor designs in regard to the kernel/os, e.g. remove the ringsbut nobody can tell me that the above syntax is soo much better than c++ XDD
16:06 <+bridge> [ddnet] <Jupstar ‚ú™> if there wouldnt be some trade, it wouldnt be considered high level ofc
16:07 <+bridge> [ddnet] <Jupstar ‚ú™> yeah \:D
16:07 <+bridge> [ddnet] <Jupstar ‚ú™> (@Learath2)
16:07 <+bridge> [ddnet] <Learath2> To be fair though, I think you'd just use an atomic here, should give you roughly the same performance on x86
16:07 <+bridge> [ddnet] <Ryozuki> i like more rust syntax tho
16:07 <+bridge> [ddnet] <Jupstar ‚ú™> probably yes \:D
16:08 <+bridge> [ddnet] <Ryozuki> but u will never convince me
16:08 <+bridge> [ddnet] <Ryozuki> its subjective
16:08 <+bridge> [ddnet] <Jupstar ‚ú™> yeah its ok
16:08 <+bridge> [ddnet] <Jupstar ‚ú™> there are also ppl liking pythons syntax
16:08 <+bridge> [ddnet] <Ryozuki> have you found urself in a situation of the code u sent in a real project?
16:08 <+bridge> [ddnet] <Jupstar ‚ú™> so i have to acept thats its subjective anyway xD
16:09 <+bridge> [ddnet] <Jupstar ‚ú™> it happens in ddnet for example \:D
16:09 <+bridge> [ddnet] <Ryozuki> and ddnet segfaults a lot
16:09 <+bridge> [ddnet] <Ryozuki> :monkalaugh:
16:09 <+bridge> [ddnet] <Learath2> I actually don't see how to get it to work in rust. @heinrich5991 could know, he is more of a rust wizard
16:09 <+bridge> [ddnet] <Ryozuki> ye he knows more
16:09 <+bridge> [ddnet] <Ryozuki> idk
16:09 <+bridge> [ddnet] <Ryozuki> maybe what jupstar is doing is ub?
16:09 <+bridge> [ddnet] <Jupstar ‚ú™> but ddnet segfaults bcs of memory overflow or deletes
16:10 <+bridge> [ddnet] <Jupstar ‚ú™> i doubt its UB
16:10 <+bridge> [ddnet] <Jupstar ‚ú™> its just living at the limits
16:10 <+bridge> [ddnet] <Ryozuki> i doubt u get much more realistic perf with that than a Read write lock
16:11 <+bridge> [ddnet] <Jupstar ‚ú™> non relaxed atomics for example, are pretty powerful, they are almost like a mutex just without threads waiting on it, but the constraits allow you to garantuee visisbility across threads even for non atomics
16:11 <+bridge> [ddnet] <Learath2> I don't think so, I took a look at the standard, seems fine since the only possible write that could conflict with the "unsafe" read is sequenced after the said read. No conflicting action = no data race atleast
16:11 <+bridge> [ddnet] <Jupstar ‚ú™> thats also the reason lock free queues etc exists
16:11 <+bridge> [ddnet] <Jupstar ‚ú™> probably not, not with modern hardware atleast
16:11 <+bridge> [ddnet] <Jupstar ‚ú™> (@Ryozuki)
16:12 <+bridge> [ddnet] <Jupstar ‚ú™> i litterally added a mutex to alot of sound calls, and made no real difference
16:12 <+bridge> [ddnet] <Jupstar ‚ú™> (that werent there before)
16:13 <+bridge> [ddnet] <Jupstar ‚ú™> i mean most stuff programmed today isnt designed for ultimate performance anyway \:D
16:13 <+bridge> [ddnet] <Learath2> Sometimes I wish there was a way to do extremely unsafe stuff without invoking UB. Like sometimes I really don't care about a data-race
16:13 <+bridge> [ddnet] <Jupstar ‚ú™> i am still for a rethink of all software, the whole concept of theads suck, we need a design like GPUs do it, eheheheh
16:13 <+bridge> [ddnet] <Learath2> I'm okay with the reader getting incomplete/broken data
16:13 <+bridge> [ddnet] <Ryozuki> https://docs.rs/crossbeam/0.8.1/crossbeam/sync/struct.ShardedLock.html
16:13 <+bridge> [ddnet] <Ryozuki> üëÄ
16:13 <+bridge> [ddnet] <Jupstar ‚ú™> no write /read in one pipeline call
16:14 <+bridge> [ddnet] <Learath2> Like massively parralelized stuff? Not all tasks parallelize that well tho :/
16:14 <+bridge> [ddnet] <Jupstar ‚ú™> i know
16:14 <+bridge> [ddnet] <Jupstar ‚ú™> i just like the idea alot
16:14 <+bridge> [ddnet] <Jupstar ‚ú™> thinking about it is very hard
16:14 <+bridge> [ddnet] <Jupstar ‚ú™> even trying todo it
16:15 <+bridge> [ddnet] <Jupstar ‚ú™> most ppl probs just write singlethreaded stuff, or "semi" threaded stuff
16:15 <+bridge> [ddnet] <Ryozuki> https://blog.pimaker.at/texts/rvc1/
16:17 <+bridge> [ddnet] <Learath2> I was wondering the feasibility of doing npc AI on a gpu. It's like the perfect task to parallelize
16:17 <+bridge> [ddnet] <Learath2> Could do like thousands of ai agents in a city like that
16:17 <+bridge> [ddnet] <Ryozuki> :monkaS:
16:18 <+bridge> [ddnet] <Learath2> I couldn't justify looking further into it since I worry just ferrying the data between the gpu and the cpu would be too slow for it to be worth until I get many thousands of ai agents
16:19 <+bridge> [ddnet] <Learath2> But with architectures like the M1 where you get compute cores very closely linked to the cpu it might just become feasible to do
16:20 <+bridge> [ddnet] <Jupstar ‚ú™> yeah, very interesting indeed
16:20 <+bridge> [ddnet] <Ryozuki> i dislike m1
16:20 <+bridge> [ddnet] <Ryozuki> cuz
16:20 <+bridge> [ddnet] <Ryozuki> its made by apple
16:20 <+bridge> [ddnet] <Learath2> apple
16:20 <+bridge> [ddnet] <Ryozuki> imho it would be real progress is they made it open for everyone
16:20 <+bridge> [ddnet] <Jupstar ‚ú™> a real strength of m1, i wonder if they can scale it to a desktop component, or if the heat is too much there
16:21 <+bridge> [ddnet] <Ryozuki> but i will never consider looking into a m1 or things to do with it
16:21 <+bridge> [ddnet] <Ryozuki> cuz its locked into apple
16:21 <+bridge> [ddnet] <Jupstar ‚ú™> yeah ofc, i wouldnt buy it with macos xD, thats like a big downgrade
16:21 <+bridge> [ddnet] <Learath2> Did you see alder lake? Seems atleast we are getting big-core little-core
16:21 <+bridge> [ddnet] <Ryozuki> i didnt
16:22 <+bridge> [ddnet] <Learath2> I doubt we'll get compute cores this closely linked to the cpu outside of M1 anytime soon though and going thru pci there is always a real latency concern
16:22 <+bridge> [ddnet] <Jupstar ‚ú™> its mostly the memory in m1 that makes it so fast i guess
16:22 <+bridge> [ddnet] <Ryozuki> and i wonder what kinds of hidden instructions or stuff apple processors have
16:22 <+bridge> [ddnet] <Ryozuki> this reminded me of a rly good vid i saw
16:23 <+bridge> [ddnet] <Ryozuki> about the mastermind that made a compiler with only movs
16:23 <+bridge> [ddnet] <Ryozuki> cant remember now
16:23 <+bridge> [ddnet] <Jupstar ‚ú™> amd's 3rd gen is basically only increase cache size and get 20% more perf
16:23 <+bridge> [ddnet] <Ryozuki> https://www.youtube.com/watch?v=KrksBdWcZgQ
16:23 <+bridge> [ddnet] <Ryozuki> > A processor is not a trusted black box for running code; on the contrary, modern x86 chips are packed full of secret instructions and hardware bugs. In this talk, we'll demonstrate how page fault analysis and some creative processor fuzzing can be used to exhaustively search the x86 instruction set and uncover the secrets buried in your chipset.
16:23 <+bridge> [ddnet] <Ryozuki> this video is insane
16:23 <+bridge> [ddnet] <Ryozuki> i have to rewatch it
16:24 <+bridge> [ddnet] <ReiTW> apple uses arm arch now
16:24 <+bridge> [ddnet] <Jupstar ‚ú™> x86 is also sooooo old, i really wish a modern CISC would exists, designed with instructions that make sense in 2021
16:24 <+bridge> [ddnet] <Learath2> Well it's the fact that m1 has unified memory that makes it so efficient. Consoles also use this to get amazing performance.
16:24 <+bridge> [ddnet] <Ryozuki> i also would like that
16:24 <+bridge> [ddnet] <Ryozuki> im sure shitload of stuff changed
16:24 <+bridge> [ddnet] <Learath2> Why would you want a modern CISC? RISC >>>> CISC üòõ
16:25 <+bridge> [ddnet] <Jupstar ‚ú™> arm is also not really RISC
16:25 <+bridge> [ddnet] <Jupstar ‚ú™> anymore
16:25 <+bridge> [ddnet] <Ryozuki> isnt making a modern instruction set  would also remove the need to conditionally enable simd stuff and so on
16:25 <+bridge> [ddnet] <Learath2> I wish RISC-V would get some more attention
16:25 <+bridge> [ddnet] <Ryozuki> wow my english sucks at that sentence
16:26 <+bridge> [ddnet] <Ryozuki> the good thing about RISC is that you can program in asm realistically right?
16:26 <+bridge> [ddnet] <Ryozuki> xd
16:26 <+bridge> [ddnet] <Jupstar ‚ú™> but i feel that
16:26 <+bridge> [ddnet] <Jupstar ‚ú™> i think NEON didnt exist before v7
16:28 <+bridge> [ddnet] <Learath2> With a RISC fixed-length ISA you could feasibly read bytecode even. It'd make disassemblers so much easier to implement. It'd also simplify the decode step immensely
16:29 <+bridge> [ddnet] <Jupstar ‚ú™> yeah thats true
16:29 <+bridge> [ddnet] <Jupstar ‚ú™> i wonder how much diff the 5nm makes, i really wonder how close apple is to x86 desktop chips
16:29 <+bridge> [ddnet] <Jupstar ‚ú™> but they need all the same circumstances to compare, and more software, not only video editors
16:30 <+bridge> [ddnet] <Learath2> Apparently the nm thing is a bit deceptive. I wonder if we should start talking in terms of transistor density instead or sth
16:30 <+bridge> [ddnet] <Jupstar ‚ú™> and ofc, i wonder how they arch would scale to a desktop chip, so 100-200 watt TDP
16:30 <+bridge> [ddnet] <Ryozuki> is alder lake 10nm?
16:30 <+bridge> [ddnet] <Ryozuki> ye
16:30 <+bridge> [ddnet] <Jupstar ‚ú™> yeah thats true, but i mean like if they all makes their chips at the same company
16:30 <+bridge> [ddnet] <Jupstar ‚ú™> (@Learath2)
16:30 <+bridge> [ddnet] <Ryozuki> im still a amd fan tho
16:31 <+bridge> [ddnet] <Ryozuki> im happy with my 5600x
16:31 <+bridge> [ddnet] <Learath2> Seems intels 10nm process lead to a similar transistor size to tsmcs 7nm process
16:32 <+bridge> [ddnet] <Jupstar ‚ú™> intel seems to be good in also making other stuff smaller, e.g. the memory controler
16:32 <+bridge> [ddnet] <Jupstar ‚ú™> i read somewhere a year ago or smth, that these are still often in 30nm+
16:32 <+bridge> [ddnet] <Learath2> I'm a huge fan of big-core little-core btw. It's something I wished existed for years
16:32 <+bridge> [ddnet] <Learath2> Hope AMD comes out with a hybrid offering soon too
16:33 <+bridge> [ddnet] <Jupstar ‚ú™> but only for laptops?
16:33 <+bridge> [ddnet] <Ryozuki> https://wccftech.com/amd-big-little-processor-cores-show-up-in-latest-patent-coming-to-next-gen-ryzen-cpus-apus/
16:33 <+bridge> [ddnet] <Learath2> Alder Lake is a desktop cpu, so not anymore üòõ
16:33 <+bridge> [ddnet] <Jupstar ‚ú™> for desktop it seems like the motherboard is more powerhungry in idle
16:35 <+bridge> [ddnet] <Learath2> Power savings are not the only concern. With the OS Scheduler cooperating with the cpu, and the fact that you can fit multiple small cores instead of one big core, we might finally get a more responsive system
16:36 <+bridge> [ddnet] <Jupstar ‚ú™> oh ok, possible yeah, i am not that much into what causes most latency bottlenecks \:D
17:04 <+bridge> [ddnet] <Jupstar ‚ú™> @Learath2\: have you tried to build the server in a clean environment? maybe even with LTO to make sure its not data curroption, i also had data curroption after the bug in detect.h
17:04 <+bridge> [ddnet] <Jupstar ‚ú™> for the server bug
17:05 <+bridge> [ddnet] <Jupstar ‚ú™> (data curroption in the build process bcs of ODR)
17:06 <+bridge> [ddnet] <Jupstar ‚ú™> i really cant find anything broken else \:/
17:11 <+bridge> [ddnet] <Learath2> The fact that it happens randomly makes it so hard to check
17:12 <+bridge> [ddnet] <Ryozuki> ye sucks
17:12 <+bridge> [ddnet] <Ryozuki> did u try it with jupstar new patch
17:12 <+bridge> [ddnet] <Ryozuki> that fixes the data race?
17:12 <+bridge> [ddnet] <Ryozuki> maybe it changed when i removed those volatiles
17:12 <+bridge> [ddnet] <Ryozuki> i doubt tho
17:12 <+bridge> [ddnet] <Ryozuki> xd
17:13 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903300390378962964/unknown.png
17:13 <+bridge> [ddnet] <Ryozuki> :monkaS:
17:13 <+bridge> [ddnet] <Jupstar ‚ú™> its only client \:D
17:13 <+bridge> [ddnet] <Jupstar ‚ú™> (@Ryozuki)
17:13 <+bridge> [ddnet] <Ryozuki> ah xd
17:14 <+bridge> [ddnet] <Jupstar ‚ú™> yeah but i'd really suggest trying it, as said i also had ODR errors when i rebased without clearing the build dir
17:14 <+bridge> [ddnet] <Jupstar ‚ú™> (@Learath2)
17:14 <+bridge> [ddnet] <Ryozuki> https://github.com/ddnet/ddnet/pull/4217/files
17:14 <+bridge> [ddnet] <Ryozuki> maybe
17:14 <+bridge> [ddnet] <Jupstar ‚ú™> after the detect.h defect
17:14 <+bridge> [ddnet] <Ryozuki> the reentry guard
17:14 <+bridge> [ddnet] <Ryozuki> guards*
17:14 <+bridge> [ddnet] <Ryozuki> need to be atomic?
17:14 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903300806676197476/unknown.png
17:14 <+bridge> [ddnet] <Ryozuki> heinrich told me they didnt
17:14 <+bridge> [ddnet] <Jupstar ‚ú™> i dont think so as i dont see another thread using it
17:15 <+bridge> [ddnet] <Jupstar ‚ú™> https://github.com/ddnet/ddnet/commit/66947b70b773ef3e8184425e5a55ccf5de72e48b
17:15 <+bridge> [ddnet] <Jupstar ‚ú™> 12 days ago
17:15 <+bridge> [ddnet] <Jupstar ‚ú™> when did the crashes first happen?
17:15 <+bridge> [ddnet] <Ryozuki> atleast 5 days ago
17:16 <+bridge> [ddnet] <Jupstar ‚ú™> https://github.com/ddnet/ddnet/commit/3b1c0748423a4a493ae6eb7536d16507499de9bc#diff-86d59021cb4561b3911602552aed980edc3ddf8b4846d5e59f09b3e863fff8e5
17:16 <+bridge> [ddnet] <Jupstar ‚ú™> the bug was added 13. september
17:18 <+bridge> [ddnet] <Jupstar ‚ú™> i'd just add smth like -DCMAKE\_CXX\_FLAGS="-flto" -DCMAKE\_C\_FLAGS="-flto" -DCMAKE\_EXE\_LINKER\_FLAGS="-flto" and see what the build says
17:18 <+bridge> [ddnet] <Jupstar ‚ú™> and then remove it again if nothing is shown
17:18 <+bridge> [ddnet] <Jupstar ‚ú™> (on the old build dir=
17:18 <+bridge> [ddnet] <Jupstar ‚ú™> (on the old build dir)
17:19 <+bridge> [ddnet] <Ryozuki> are servers built with o3 or o2
17:19 <+bridge> [ddnet] <Ryozuki> maybe its a miscompilation xd
17:20 <+bridge> [ddnet] <Jupstar ‚ú™> i guess normal release flags so o2
17:20 <+bridge> [ddnet] <Jupstar ‚ú™> server isnt really hungry
17:21 <+bridge> [ddnet] <Jupstar ‚ú™> or revert some changes and see when it happened, it seems like they happen every day
17:25 <+bridge> [ddnet] <Jupstar ‚ú™> @Learath2\: are the servers always cleanly built? or are the old build dirs reused?
17:31 <+bridge> [ddnet] <deen> Jupstar: clean build
17:31 <+bridge> [ddnet] <Jupstar ‚ú™> mhh too bad
17:31 <+bridge> [ddnet] <deen> ```
17:31 <+bridge> [ddnet] <deen> rm -rf ../master-build
17:31 <+bridge> [ddnet] <deen> mkdir ../master-build
17:31 <+bridge> [ddnet] <deen> cd ../master-build
17:31 <+bridge> [ddnet] <deen> cmake ../master -DANTIBOT=ON -DWEBSOCKETS=OFF -DMYSQL=ON -DCLIENT=OFF -DCMAKE_BUILD_TYPE=RelWithDebInfo
17:31 <+bridge> [ddnet] <deen> make DDNet-Server map_convert_07 map_optimize
17:31 <+bridge> [ddnet] <deen> ```
17:32 <+bridge> [ddnet] <Jupstar ‚ú™> alright, from the latest UBSan report it looks like it gets mem\_zero'd somehow
17:32 <+bridge> [ddnet] <Jupstar ‚ú™> vptr is 0
17:32 <+bridge> [ddnet] <Jupstar ‚ú™> thats not really common
17:34 <+bridge> [ddnet] <Jupstar ‚ú™> @deen\: so whats the plan, revert some commits and see what happens?, i guess it must be somwhere from the anti startline skips until master
17:34 <+bridge> [ddnet] <deen> I have no plan
17:35 <+bridge> [ddnet] <deen> I could check dmesg on the servers to see when regular crashes started, but I wouldn't 100% be sure that it's those
17:36 <+bridge> [ddnet] <Learath2> I'm so lost, the entity we seem to be ticking on has no reference in the entire memory space of the process
17:36 <+bridge> [ddnet] <Learath2> where are we getting this weird entity even?
17:37 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903306611920076800/unknown.png
17:38 <+bridge> [ddnet] <Learath2> Actually this address isn't even mapped??
17:40 <+bridge> [ddnet] <Jupstar ‚ú™> the fact that all sanitizers cant catch it really speaks for either uninitialized, data race or logic error
17:41 <+bridge> [ddnet] <Jupstar ‚ú™> but that should be ez to find in the commits
17:41 <+bridge> [ddnet] <Jupstar ‚ú™> since its no overflow
17:42 <+bridge> [ddnet] <Learath2> AHA I think I have an idea
17:42 <+bridge> [ddnet] <Jupstar ‚ú™> ok tw also uses memory pools, so i dunno how the sanitizers react to it \:D
17:44 <+bridge> [ddnet] <Learath2> Hm this member variable `m_pNextTraverseEntity`¬†is so sus
17:44 <+bridge> [ddnet] <Learath2> Why is it a member variable?
17:46 <+bridge> [ddnet] <Jupstar ‚ú™> yeah looks like it makes no sense
17:46 <+bridge> [ddnet] <Jupstar ‚ú™> but also doesnt see any problem with it
17:47 <+bridge> [ddnet] <Jupstar ‚ú™> but maybe its used recursivly somewhere
17:47 <+bridge> [ddnet] <Jupstar ‚ú™> RemoveEntity for example, so i guess it can make sense
17:53 <+bridge> [ddnet] <Learath2> The problem is this insane value out of nowhere, I don't see this memory address referenced on any of the linked lists
17:54 <+bridge> [ddnet] <Learath2> There seems to be no alive characters, and `m_apFirstEntityTypes[ENTTYPE_CHARACTER]` is indeed 0x0
17:59 <+bridge> [ddnet] <Learath2> I think you are on to something there
17:59 <+bridge> [ddnet] <Learath2> that code looks very very sus
18:07 <+bridge> [ddnet] <Ryozuki> sus
18:07 <+bridge> [ddnet] <Ryozuki> christmas is soon
18:07 <+bridge> [ddnet] <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/903314099155386398/icyafwgzm5w71.png
18:07 <+bridge> [ddnet] <Learath2> Hm, the member thing seems to be to ensure that if within Tick an entity gets removed the traversal doesn't break
18:08 <+bridge> [ddnet] <Learath2> Neither draggers nor pickups kill you, right?
18:09 <+bridge> [ddnet] <Jupstar ‚ú™> i mean deen is right, that its sus that it always happens if a player leaves
18:10 <+bridge> [ddnet] <Jupstar ‚ú™> it somehow has to happen before the tick starts, but besides the antibot i dont see anything
18:10 <+bridge> [ddnet] <Learath2> It seems to always happen when a player leaves than another kills
18:10 <+bridge> [ddnet] <Jupstar ‚ú™> yeah true
18:10 <+bridge> [ddnet] <Ryozuki> wouldnt that be awesome to create tests with the headless server we can now have
18:10 <+bridge> [ddnet] <Ryozuki> maybe we could reproduce tick perfect bugs
18:11 <+bridge> [ddnet] <Ryozuki> headless client
18:11 <+bridge> [ddnet] <Ryozuki> idk what im talking
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> ```
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][server]: client dropped. cid=9 addr=<{X}> reason=''
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][game]: kill killer='9:Maybe.' victim='9:Maybe.' weapon=-3 special=0
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][chat]: *** 'Maybe.' has left the game
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][game]: leave player='9:Maybe.'
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][game]: kill killer='10:[D] Maybe.' victim='10:[D] Maybe.' weapon=-1 special=0
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> [2021-10-27 10:21:06][game]: kill killer='10:[D] Maybe.' victim='10:[D] Maybe.' weapon=-2 special=0
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> ```He leaves and his dummy dies in spikes and self kills afterwards ? XD
18:13 <+bridge> [ddnet] <Jupstar ‚ú™> that alone is sus
18:14 <+bridge> [ddnet] <Jupstar ‚ú™> maybe u just have to kill while the world kills you or smth, but why the player leave? maybe a bug in the dummy code that does it for some reason?
18:15 <+bridge> [ddnet] <Learath2> Hm maybe the dummy also left but it crashed before that leave went through?
18:15 <+bridge> [ddnet] <Jupstar ‚ú™> possible yeah
18:16 <+bridge> [ddnet] <Jupstar ‚ú™> i wonder if that was on dummy maps
18:16 <+bridge> [ddnet] <Jupstar ‚ú™> where e.g. startline kills you
18:38 <+bridge> [ddnet] <Jupstar ‚ú™> mhh the startline skip kills you when someone leaves the team after you hit the start line, and thats the only commit that changed kill behavior lately
18:38 <+bridge> [ddnet] <Learath2> I found some stack addresses where the insane entity pointer is found, not sure how best to figure out what was stored in these stack variables
18:42 <+bridge> [ddnet] <Jupstar ‚ú™> from the flow it would fit
18:42 <+bridge> [ddnet] <Jupstar ‚ú™> it kills the char in the world tick, then self kills in team start line skip tick
18:43 <+bridge> [ddnet] <Jupstar ‚ú™> (it uses WEAPON\_SELF)
18:50 <+bridge> [ddnet] <Jupstar ‚ú™> too bad that we dont log the server tick
18:51 <+bridge> [ddnet] <Jupstar ‚ú™> only self kill that happens after the tick is this i think, the rest are console commands
19:01 <+bridge> [ddnet] <De√´ivid!> What's the difference between these?
19:01 <+bridge> [ddnet] <De√´ivid!> https://cdn.discordapp.com/attachments/293493549758939136/903327562497917019/unknown.png
19:06 <+bridge> [ddnet] <Jupstar ‚ú™> fullscreen minimizes the other doesnt
19:06 <+bridge> [ddnet] <Jupstar ‚ú™> fullscreen might disable stuff like the windows compositor so its exclusive
19:06 <+bridge> [ddnet] <Jupstar ‚ú™> also you can only change fullscreen resolution with fullscreen
19:08 <+bridge> [ddnet] <De√´ivid!> so Desktop fullscreen uses like the native resolution?
19:08 <+bridge> [ddnet] <De√´ivid!> so Desktop fullscreen uses like the native resolution only?
19:08 <+bridge> [ddnet] <Jupstar ‚ú™> it uses your desktops resolution
19:08 <+bridge> [ddnet] <De√´ivid!> ah ok
19:08 <+bridge> [ddnet] <De√´ivid!> ty
19:29 <+bridge> [ddnet] <uwu> Woah uh oh hmm
19:29 <+bridge> [ddnet] <uwu> https://cdn.discordapp.com/attachments/293493549758939136/903334770547769404/Screenshot_2021-10-28-20-29-31-154_com.valvesoftware.android.steam.community.jpg
19:30 <+bridge> [ddnet] <Ryozuki> :thonk:
19:35 <+bridge> [ddnet] <gerdoe> https://media.discordapp.net/attachments/737521938045599745/884617389726113802/Fa5C2k8GB1c.gif
19:36 <+bridge> [ddnet] <Jupstar ‚ú™> @Learath2\: just remove all these pool hacks and let asan detect the issue then we know xd, cant be that hard
20:53 <+bridge> [ddnet] <nuborn> The last two kills in a row seems like what you get when the team is locked and someone dies from kill tiles
21:31 <+bridge> [ddnet] <Jupstar ‚ú™> i guess the starting date of the crashes could already help
