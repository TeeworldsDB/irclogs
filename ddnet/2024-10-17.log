00:12 < bridge> <heinrich5991> xoshiro/pcg seem so much better
00:13 < bridge> <heinrich5991> ah, and mersenne twister also generates bad random numbers, apparently
00:16 < bridge> <heinrich5991> > One likely reason for adopting such a system is that ISPs in China often implement DNS hijacking to insert ads and redirect web traffic to perform ad fraud. The problem was so serious that six Chinese internet giants issued a joint statement in 2015 urging ISPs to improve. According to the news article, about 1–2% of traffic to Meituan (an online shopping site) suffers from DNS hijacking. Ad fraud by Chinese ISPs seems to remain a widespre
00:16 < bridge> <heinrich5991> https://citizenlab.ca/2024/10/should-we-chat-too-security-analysis-of-wechats-mmtls-encryption-protocol/
00:21 < bridge> <Jupstar ✪> Xoshiro256StarStar is the best
00:22 < bridge> <Jupstar ✪> Bcs of the name
00:25 < bridge> <mazty> ///this///
00:25 < bridge> <mazty> //this//
00:25 < bridge> <mazty> //this
00:38 < bridge> <totar> xoshiro is newer than mt19937
00:39 < bridge> <learath2> Hm, I don't remember but are older xorshift generators strictly better than mersenne twister? The earliest xorshift ones do predate the standard random header but idk if modern "good" ones are old enough
00:43 < bridge> <totar> every rng implementation has to just pick one of the algorithms on the pareto front, but there's not many people online who will tell you what those are.
00:43 < bridge> <learath2> > David Blackman and Sebastiano Vigna. Scrambled linear pseudorandom number generators. ACM Trans. Math. Softw., 47:1−32, 2021.
00:43 < bridge> <learath2> This is the paper that `xoshiro256++/xoshiro256**` seems to be first referenced in
00:44 < bridge> <learath2> Actually the initial revision of its is from 2018, but still not quite old enough to be in C++11
00:47 < bridge> <learath2> Though it seems the idea of scrambling the output of a xorshift generator has existed since 2005, so idk maybe they were around and just no one bothered
00:47 < bridge> <totar> it looks like there's many generations of xorshiro algorithms
00:48 < bridge> <totar> xoshiro, xoroshiro, xoroshiro+, xoroshiro star
00:50 < bridge> <learath2> `XOr` `ROtate` `SHift`and iirc the `+` `++` `*` `**` signify the output scramblers
00:50 < bridge> <learath2> `+` and `++` have less random lower bits, `**` has better randomness but is trivially reversible
00:55 < bridge> <totar> lol the PCG people and the xorshift people have drama
00:55 < bridge> <totar> <https://pcg.di.unimi.it/pcg.php>
00:55 < bridge> <totar> <https://www.pcg-random.org/>
01:10 < bridge> <totar> they argue a lot it seems
01:10 < bridge> <totar> but the difference is probably marginal unless you have very specific criteria
01:13 < bridge> <totar> I think it's pretty safe to assume the cpp rand() is literally never a good choice
01:13 < bridge> <totar> I think it's pretty safe to assume the cpp std::rand() is literally never a good choice
01:20 < bridge> <totar> <https://www.pcg-random.org/posts/on-vignas-pcg-critique.html>
01:26 < bridge> <totar> it's impressive how little consensus there is
01:28 < bridge> <totar> everyone runs their own separate and unique prng test suites that do not agree with each other, idk why there isn't just some standard authority that lets you submit your generator and it runs against every benchmark conceivable.
01:31 < bridge> <totar> I would say it's completely reasonable that cpp standard chose mt19937 in 2011 it would have been extremely unclear that pcg or xorshiro were better at that time
01:32 < bridge> <totar> some people are still claiming that the default xorshiro in V8 is bad <https://arxiv.org/abs/1908.10020>
03:39 < bridge> <meloƞ> :suizid:  use nix they said
03:39 < bridge> <meloƞ> https://cdn.discordapp.com/attachments/293493549758939136/1296286457551519875/image.png?ex=6711bc57&is=67106ad7&hm=1126f0c420793b1f48c20eea4fe462490fccdabf162bc4215eefa2dc7c47eea8&
08:42 < bridge> <heinrich5991> https://mobeigi.com/blog/gaming/how-we-outsmarted-csgo-cheaters-with-identitylogger/
08:59 < bridge> <totar> seems a little naive compared to how complex this game is now.
09:01 < bridge> <totar> Probably the only reason it was undetected is because the cheat authors made their cheats to evade official VAC servers. Had they ever tested on this community server they might have figured it out instantly. Of course the script kiddies wouldn't figure it out themselves.
10:26 < bridge> <pathos3005> So wait, can you link Git for *current* working version of a vanilla server?
10:35 < ws-client1> <ChillerDragon> @pathos3005 https://github.com/ddnet-insta/ddnet-insta
10:35 < ws-client1> <ChillerDragon> ``sv_gametype ctf``
11:07 < bridge> <baslcaly> ’’’k’’’
11:08 < bridge> <baslcaly> ´´´
11:08 < bridge> <baslcaly> 
11:08 < bridge> <baslcaly> E´´´
11:08 < bridge> <baslcaly> ´´´
11:08 < bridge> <baslcaly> 
11:08 < bridge> <baslcaly> E
11:08 < bridge> <baslcaly> ´´´
11:08 < bridge> <baslcaly> 
11:09 < bridge> <baslcaly> E
11:09 < bridge> <baslcaly> ´´´
11:09 < bridge> <baslcaly> ´´´ doesnt work ´´´
11:21 < bridge> <jxsl13> \`\`\`
11:21 < bridge> <jxsl13> code
11:21 < bridge> <jxsl13> \`\`\`
11:21 < bridge> <jxsl13> @baslcaly
11:21 < bridge> <jxsl13> ```
11:21 < bridge> <jxsl13> code
11:21 < bridge> <jxsl13> ```
11:22 < bridge> <tsfreddie> ok
11:22 < bridge> <tsfreddie> gradle
11:22 < bridge> <tsfreddie> sucks
11:28 < bridge> <fokkonaut> hello chillerdragon
11:44 < bridge> <teero777> hello chillerdragon
11:46 < bridge> <heinrich5991> https://daniel.haxx.se/blog/2024/10/17/undefinedbehaviorsanitizers-unexpected-behavior/
12:55 < bridge> <heinrich5991> https://cdn.discordapp.com/attachments/293493549758939136/1296426330769854536/image.png?ex=67123e9b&is=6710ed1b&hm=d861b5f8c044e21db6a998ca4726c112b9653ed6dddb95b6bac173c821c2377e&
12:55 < bridge> <heinrich5991> I think we might be better off purchasing @patiga's map recognition bot, it seems to have more traction than accounts
12:56 < bridge> <heinrich5991> (the accounts post is 3 months old, the map recognition one 8 days)
13:12 < bridge> <jxsl13> Patiga ftw!
13:12 < bridge> <jxsl13> Patiga for DDNet president
13:39 < bridge> <milkeeycat> @learath2 checkout this new useless proc macro 😏 
13:39 < bridge> <milkeeycat> ```rust
13:39 < bridge> <milkeeycat> fn main() -> u8 {
13:39 < bridge> <milkeeycat>     let a: u8 = rev_bin_ops!(10 / 20);
13:39 < bridge> <milkeeycat> 
13:39 < bridge> <milkeeycat>     printf("%d\n", a);
13:39 < bridge> <milkeeycat> 
13:40 < bridge> <milkeeycat>     return 0;
13:40 < bridge> <milkeeycat> }
13:40 < bridge> <milkeeycat> ```
13:40 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1296437526021800006/image.png?ex=67124908&is=6710f788&hm=5d02f59d7b362604b1dc855fb1359ffad0b4c9a2eb6b75de96de340a4d071991&
13:46 < bridge> <Jupstar ✪> bot msgs count too tho 😄
13:51 < bridge> <learath2> Show macro code
13:52 < bridge> <milkeeycat> ```C
13:52 < bridge> <milkeeycat> Slice RevBinOps(Slice slice) {
13:52 < bridge> <milkeeycat>     TokenTree *tokenTree = slice.ptr;
13:52 < bridge> <milkeeycat> 
13:52 < bridge> <milkeeycat>     TokenTree tmp = tokenTree[0];
13:52 < bridge> <milkeeycat>     tokenTree[0] = tokenTree[2];
13:52 < bridge> <milkeeycat>     tokenTree[2] = tmp;
13:52 < bridge> <milkeeycat> 
13:52 < bridge> <milkeeycat>     return slice;
13:52 < bridge> <milkeeycat> }
13:52 < bridge> <milkeeycat> ``` :justatest:
13:52 < bridge> <learath2> Cool
13:52 < bridge> <heinrich5991> is that in the target language?
13:53 < bridge> <milkeeycat> it's in C
13:53 < bridge> <milkeeycat> my language doesn't have unions yet
13:53 < bridge> <learath2> Proc macros in C is something I never even thought I'd see
13:53 < bridge> <heinrich5991> why not rust? ^^
13:53 < bridge> <milkeeycat> it's possible to do in rust as well xd
13:53 < bridge> <heinrich5991> ah, did you also write your lang in C? then it makes sense
13:54 < bridge> <milkeeycat> my language is in rust :lol:
13:54 < bridge> <heinrich5991> hmmmmmm
13:54 < bridge> <learath2> He could not say no to the allure of the supreme language C
13:54 < bridge> <avolicious> So when ddnet cookie support 😄
13:55 < bridge> <heinrich5991> never, we're still hoping for the accounts support
13:55 < bridge> <avolicious> hwid, cookies, tracking pixel... we need all of it
13:55 < bridge> <heinrich5991> pls no
13:56 < bridge> <avolicious> The good part, why this CS thingy worked out so well... its not open source, so people cant run their own clients 😄
13:57 < bridge> <heinrich5991> ```rs
13:57 < bridge> <heinrich5991> #[no_mangle]
13:57 < bridge> <heinrich5991> pub extern "C" fn RevBinOps(slice: Slice) -> Slice {
13:57 < bridge> <heinrich5991>     unsafe {
13:57 < bridge> <heinrich5991>         mem::swap(&mut *slice.ptr.offset(0), &mut slice.ptr.offset(2);
13:57 < bridge> <heinrich5991>     }
13:57 < bridge> <heinrich5991>     slice
13:57 < bridge> <heinrich5991> }
13:57 < bridge> <heinrich5991> ```
13:57 < bridge> <avolicious> But I really enjoyed reading it, thanks heinrich
13:57 < bridge> <learath2> On a more serious note. How do you feel about hwid? I think it might work against people that block or spam. But I'm worried it'd push those people into the world of cheat clients that spoof hwid
13:58 < bridge> <milkeeycat> Is `no_mangle` required if there's `extern "C"` ? 0_o
13:58 < bridge> <heinrich5991> I'd prefer to not send more personal data. what good is it that cannot be captured by a randomly generated private key?
13:59 < bridge> <heinrich5991> I *think* so
13:59 < bridge> <learath2> Well it'd technically not be very personal, it'd involve a hash
13:59 < bridge> <heinrich5991> then what good is it beyond a randomly generated private key?
14:00 < bridge> <learath2> The randomly generated private key we'd probably have a button to refresh. Making that button the "unban" button
14:00 < bridge> <avolicious> Or just create a new account 😄
14:00 < bridge> <learath2> A hwid is annoying to spoof or change
14:00 < bridge> <avolicious> Depends, how will you verify the HWID?
14:00 < bridge> <heinrich5991> ok, so let's add a randomly generated thing that doesn't have a button
14:01 < bridge> <heinrich5991> but that's still meh
14:01 < bridge> <learath2> We'd store it in config. You can change it
14:01 < bridge> <heinrich5991> we can store it anywhere ^^
14:01 < bridge> <avolicious> Heinrich is getting evil now 😄
14:01 < bridge> <heinrich5991> not more evil than using hardware data
14:03 < bridge> <heinrich5991> you could e.g. store it in the registry
14:04 < bridge> <learath2> what is wrong with that anyway, the serial number of the harddrives and a mac address hashed together is hardly identifying
14:05 < bridge> <heinrich5991> it needs to have an upside to be considered, I think
14:05 < bridge> <heinrich5991> it's derived from the serial number of the hard drive and a mac address, e.g. so you could verify that someone is playing from a certain computer if you knew those two pieces of data
14:13 < bridge> <learath2> A hidden random private key also provides this info no?
14:13 < bridge> <heinrich5991> not across programs
16:23 < bridge> <milkeeycat> Is it possible to call `free` on pointer which was gotten after leaking a vector?
16:39 < bridge> <learath2> Wym
16:40 < bridge> <milkeeycat> ```rust
16:40 < bridge> <milkeeycat> fn main() {
16:40 < bridge> <milkeeycat>     let foo: Vec<u8> = Vec::new();
16:40 < bridge> <milkeeycat>     let r = foo.leak();
16:40 < bridge> <milkeeycat>     let ptr = r.as_ptr(); // Will it segfault if I call `free` on this ptr?
16:40 < bridge> <milkeeycat> }
16:40 < bridge> <milkeeycat> ```
16:41 < bridge> <milkeeycat> and now it's possible to return multiple statements from "proc macro" :greenthing:
16:47 < bridge> <heinrich5991> you're not allowed to call `free` on this pointer, no
16:48 < bridge> <fokkonaut> heinrich, i need you for a rust bootcamp
16:50 < bridge> <heinrich5991> it'll probably not segfault if you're talking about x86_64 linux with a current rust compiler
16:50 < bridge> <heinrich5991> what's the question? 🙂
16:50 < bridge> <milkeeycat> i found a bug which was causing segfault xd
16:51 < bridge> <milkeeycat> i was freeing it when pointer was null :pepeW:
16:51 < bridge> <heinrich5991> `free(nullptr)` is safe
16:51 < bridge> <heinrich5991> it's a noop
16:51 < bridge> <heinrich5991> that will never crash. your crash is elsewhere
16:52 < bridge> <milkeeycat> oh ye, I also moved a few lines around
16:52 < bridge> <milkeeycat> and I don't even need an if statements
16:52 < bridge> <milkeeycat> cool
16:52 < bridge> <milkeeycat> and I don't even need an if statement
16:54 < bridge> <heinrich5991> you can create a `Box<[u8]>` and leak that
16:54 < bridge> <heinrich5991> you can then later free it by re-assembling the `Box<[u8]>`
16:54 < bridge> <milkeeycat> I free it from C side
17:10 < bridge> <ryozuki> @0xdeen i vaguely remember you were into Lisp?
17:10 < bridge> <ryozuki> https://gitlab.com/lockie/cl-fast-ecs/-/wikis/tutorial-1
17:20 < bridge> <ryozuki> TIL about functors in ocaml https://ocaml.org/docs/functors
17:20 < bridge> <ryozuki> they are functions that instead of values, take entire ocaml modules
17:20 < bridge> <ryozuki> and return another module
17:23 < bridge> <fokkonaut> nothing specific, i need a full introduction
17:26 < bridge> <inv41idu53rn4m3> We getting category-theoretical in here?!
18:57 < bridge> <0xdeen> Haskell
19:39 < bridge> <Jupstar ✪> @ryozuki https://blog.rust-lang.org/2024/10/17/Rust-1.82.0.html
19:39 < bridge> <Jupstar ✪> 
19:39 < bridge> <Jupstar ✪> update
19:39 < bridge> <Jupstar ✪> to the best stable Rust yet
19:44 < bridge> <Jupstar ✪> `error: component download failed for rust-std-x86_64-linux-android`
19:44 < bridge> <Jupstar ✪> here we go again xd
21:26 < bridge> <milkeeycat> Does anyone have ideas for enums syntax which doesn't require pattern matching? :feelsbadman:
21:31 < bridge> <Jupstar ✪> How complex should your enums be?
21:31 < bridge> <Jupstar ✪> simple ints?
21:31 < bridge> <milkeeycat> i want something like C unions but with a tag
21:34 < bridge> <milkeeycat> did you see my proc macros btw? 😏
21:34 < bridge> <Jupstar ✪> I've seen that you planned them, but never in action
21:35 < bridge> <milkeeycat> @jupeyy_keks
21:36 < bridge> <Jupstar ✪> 1337
21:36 < bridge> <Jupstar ✪> next step derive macros, which are basically just proc macros
21:37 < bridge> <milkeeycat> next step is tagged unions 😬
21:37 < bridge> <milkeeycat> and then... imports :pepeW:
21:57 < bridge> <milkeeycat> `thiserror` crate is goated
