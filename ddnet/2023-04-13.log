08:04 < bridge> <fokkonaut> Hi @matricks
08:05 < bridge> <Voxel> Imagine if matricks submits a PR to ddnet
08:06 < bridge> <Voxel> that would be so funny
08:12 < bridge> <fokkonaut> HAHAHA LMAO
08:12 < bridge> <fokkonaut> sorry
08:12 < bridge> <fokkonaut> Excuse my autism, Sir.
08:19 < bridge> <Voxel> its ok im just the same
08:19 < bridge> <Voxel> probably worse
08:26 < bridge> <fokkonaut> xD
08:51 < bridge> <Jupstar ‚ú™> Don't blame something u don't understand for it tho
08:52 < bridge> <Learath2> I've been saying this for a decade now and people keep denying it. Modern text editors have insane input lag
08:52 < bridge> <Learath2> Try vim on a tty, then boot up to windows and try vscode
08:52 < bridge> <Jupstar ‚ú™> Except u have 7ghz Intel running @ 200000watt
08:52 < bridge> <Learath2> It feels like you are typing over ssh
08:53 < bridge> <Jupstar ‚ú™> Ah wait, we are actually not that far away from 7ghz
08:53 < bridge> <Jupstar ‚ú™> Ok 7thz
08:54 < bridge> <Learath2> Make that 700thz and maybe we'll get some visible light out of it. That'd be cool
09:13 < bridge> <chillerdragon> Gotta say tho pasting large texts in insert mode vim always loses against vscode in performance.
09:13 < bridge> <chillerdragon> (@Learath2)
09:15 < bridge> <Learath2> In paste mode it should be better. But yes, that is indeed an issue
09:15 < bridge> <chillerdragon> Yes but I forget to enter paste mode all the time haha. And then there is no going back when vim hangs .\_.
09:16 < bridge> <chillerdragon> Im also a big electron hater. But gotta admit vscode is really smooth.
09:18 < bridge> <bobax> –°–¢–ò–ú –î–ê–†–ò–¢ –î–ò–°–ö–û–†–î –ù–ò–¢–†–û –ù–ê 3 –ú–ï–°–Ø–¶–ê!
09:18 < bridge> <bobax> https://cli.co/discord-steam
09:18 < bridge> <Phish Bot> **#### üö® Phishing Link Detected üö®**
09:18 < bridge> <Phish Bot> **##### A message has been detected to contain a problematic link. We recommend not pressing any links within the message.**
09:18 < bridge> <Phish Bot> **###### If this is a false positive, please let us know by joining our support server through the command `!phish support`**
09:18 < bridge> <Jupstar ‚ú™> A good algorithm in a show language will always win against a slow algorithm in a fast language xd
09:19 < bridge> <Jupstar ‚ú™> Or design or whatever
09:19 < bridge> <Jupstar ‚ú™> A good algorithm in a slow language will always win against a slow algorithm in a fast language xd
09:25 < bridge> <ReiTW> tf is this bot lmao
09:26 < bridge> <Jupstar ‚ú™> At least it seemed to have worked
09:26 < bridge> <Jupstar ‚ú™> Xd
09:27 < bridge> <ReiTW> !phish support
09:27 < bridge> <Phish Bot> Join our space here\: [#phishbot\:matrix.org](https://matrix.to/#/#phishbot:matrix.org)
09:27 < bridge> <ReiTW> ha
09:27 < bridge> <ReiTW> it's a matrix bot
09:32 < bridge> <Jupstar ‚ú™> Mhh I assume the bridge has lot of rights? I wonder if u can make it leave xd
09:32 < bridge> <Jupstar ‚ú™> !phish help
09:32 < bridge> <Phish Bot> **### Commands**
09:32 < bridge> <Phish Bot>  ```
09:32 < bridge> <Phish Bot> !phish help - Displays this menu.
09:32 < bridge> <Phish Bot> !phish ping - Pings the bot and gives uptime.
09:32 < bridge> <Phish Bot> !phish space - Provides a link to join the Phish Bot space.```
09:32 < bridge> <Jupstar ‚ú™> Ah no CMD for that xd
10:32 < bridge> <Ryozuki> i decided ill contribute smth to llvm
10:32 < bridge> <Ryozuki> time to clone this massive monorepo and setup a dev env
10:36 < bridge> <Jupstar ‚ú™> üòéüòéüòé
10:40 < bridge> <Ryozuki> :justatest:
10:40 < bridge> <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1095991888802238594/image.png
10:55 < bridge> <UnlucksMcGee> Couldn't you clone with --depth 1 
10:55 < bridge> <UnlucksMcGee> Since you dont need the entire history of commits :justatest:
11:04 < bridge> <Ryozuki> i want the entire history
11:04 < bridge> <Ryozuki> anyway its just 2gb
11:04 < bridge> <Ryozuki> the build is 20gb
11:04 < bridge> <Learath2> What will you be contributing to llvm?
11:05 < bridge> <Ryozuki> for now i want to extend the c api of mlir to be able to call mlir-translate via the api instead of the tool
11:05 < bridge> <Ryozuki> the cpp api allows this already
11:06 < bridge> <Learath2> Coolcool C is best
11:06 < bridge> <Ryozuki> tf
11:06 < bridge> <Ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1095998409565020160/image.png
11:06 < bridge> <Ryozuki> ok mr discord
11:07 < bridge> <-StormAx> bro, im also shocked
11:08 < bridge> <Learath2> How dare you post that?
11:09 < bridge> <Ryozuki> yeah i know cpp errors are heinous
11:12 < bridge> <Jupstar ‚ú™> Nice try, trying to hack discord
11:24 < bridge> <Ryozuki> i guess i have to use gcc
11:24 < bridge> <Ryozuki> well ill try when im back from work
11:47 < bridge> <hotjop> help!!! me ban,for just like that
12:32 < bridge> <Chairn> would be weird that llvm cannot be compiled with clang
12:32 < bridge> <Chairn> error is in std header, so those are common to gcc and clang
12:42 < bridge> <Jupstar ‚ú™> Clang offers an own cpp std lib. Libc++ and libc++-abi
12:46 < bridge> <Ryozuki> yeah it uses gcc std instead of clang or smth
12:48 < bridge> <deen> @Tater How to run Tater client from https://github.com/sjrc6/TaterClient-ddnet/releases/tag/7.1.5 ? @C√∏ke asked
12:49 < bridge> <Tater> use this version it's updated https://github.com/danielkempf/TaterClient-ddnet/
12:49 < bridge> <C√∏ke> yeah sorry used wrong client version
12:50 < bridge> <Tater> you can download the ddnet version it says from the website then replace the exe
12:50 < bridge> <Tater> or compile it yourself
12:51 < bridge> <C√∏ke> yes thx it works
12:51 < bridge> <Tater> np
13:20 < bridge> <Patiga> @Jupeyy_Keks how do you handle the texture atlases like game.png btw? using it as a texture directly makes the hook bleed into the grenade a little
13:21 < bridge> <Jupstar ‚ú™> I split them. I didn't find another easy solution for gl1
13:21 < bridge> <Jupstar ‚ú™> On cpu
13:21 < bridge> <Patiga> split them as in creating a separate atlas with more space inbetween?
13:22 < bridge> <Patiga> or some texture array?
13:22 < bridge> <Jupstar ‚ú™> Individual textures
13:24 < bridge> <Patiga> so one draw call for each weapon and so on if I understand correctly?
13:24 < bridge> <Jupstar ‚ú™> Yes. But don't u already face this problem with skins
13:25 < bridge> <Patiga> I don't think so, I think pretty much all skins don't go close to the texture borders
13:25 < bridge> <Patiga> wait do you do mipmapping with skins?
13:25 < bridge> <Jupstar ‚ú™> It will not match ddnet rendering then tho. Just that u are aware
13:27 < bridge> <Patiga> hm if it is only about details not noticeable in regular gameplay I think I'd be okay with it
13:34 < bridge> <Jupstar ‚ú™> What you can do is to use texture query lod and then simply apply the query lod to the expected texture size to get the Texel offset  apply that to the texture coordinates (u need to keep track of if it's bottom right etc.) And then with texturelod u have no bleeding . Tho no mipmap interpolation
13:34 < bridge> <Jupstar ‚ú™> Also it will still distort very slightly. Since edges aren't clamped but skipped instead
13:35 < bridge> <Teero> ```void CGameWorld::Clear()
13:36 < bridge> <Teero> {
13:36 < bridge> <Teero>     // delete all entities
13:36 < bridge> <Teero>     for(auto &pFirstEntityType : m_apFirstEntityTypes)
13:36 < bridge> <Teero>         while(pFirstEntityType)
13:36 < bridge> <Teero>             delete pFirstEntityType; // NOLINT(clang-analyzer-cplusplus.NewDelete)
13:36 < bridge> <Teero> }
13:36 < bridge> <Teero> ```
13:36 < bridge> <Teero> did some experimenting with prediction and somehow when clearing a simulated world this crashed on me while deleting.
13:36 < bridge> <Teero> fixed it like this... idk if this is a issue or some preperations where wrong on my side
13:36 < bridge> <Teero> ```void CGameWorld::Clear()
13:36 < bridge> <Teero> {
13:36 < bridge> <Teero>     // delete all entities
13:36 < bridge> <Teero>     for(auto &pFirstEntityType : m_apFirstEntityTypes)
13:36 < bridge> <Teero>     {
13:36 < bridge> <Teero>         while(pFirstEntityType)
13:36 < bridge> <Teero>         {
13:36 < bridge> <Teero>             auto nextEntityType = pFirstEntityType->m_pNextTypeEntity;
13:36 < bridge> <Teero>             delete pFirstEntityType->m_pPrevTypeEntity;
13:36 < bridge> <Teero>             delete pFirstEntityType;
13:36 < bridge> <Teero>             pFirstEntityType = nextEntityType;
13:36 < bridge> <Teero>         }
13:36 < bridge> <Teero>     }
13:36 < bridge> <Teero> }```
13:39 < bridge> <Ryozuki> doesnt delete[] m_apFirstEntityTypes; work?
13:39 < bridge> <Ryozuki> my cpp is rusty anyway
13:39 < bridge> <Ryozuki> pun intended
13:40 < bridge> <Jupstar ‚ú™> It's a linked list
13:40 < bridge> <Jupstar ‚ú™> So no
13:40 < bridge> <Jupstar ‚ú™> Or multiple linked lists even
13:40 < bridge> <Ryozuki> CEntity *m_apFirstEntityTypes[NUM_ENTTYPES];
13:41 < bridge> <Jupstar ‚ú™> Yeah. U can't delete an array
13:41 < bridge> <Ryozuki> isnt this the point of delete[]
13:41 < bridge> <Ryozuki> The delete [] operator deallocates memory and calls destructors for an array of objects created with new [].
13:41 < bridge> <Jupstar ‚ú™> Besides the code is really weird ddnets could should be right i think
13:42 < bridge> <Jupstar ‚ú™> It's a compiler time sized array
13:42 < bridge> <Jupstar ‚ú™> Not heap
13:42 < bridge> <Ryozuki> ah
13:42 < bridge> <Ryozuki> cpp sux
13:42 < bridge> <Jupstar ‚ú™> Lmao
13:42 < bridge> <Teero> it works and i aint complaining xD
13:43 < bridge> <Jupstar ‚ú™> ^^
13:43 < bridge> <Teero> magic üßô‚Äç‚ôÇÔ∏è
13:43 < bridge> <Ryozuki> i hate smileys
13:43 < bridge> <Ryozuki> ^^
13:43 < bridge> <Ryozuki> üôÇ
13:43 < bridge> <Jupstar ‚ú™> :poggers2: :kek: :troll: :justatest:
13:43 < bridge> <Ryozuki> better
13:43 < bridge> <Ryozuki> its like
13:43 < bridge> <Ryozuki> "u did good üôÇ"
13:43 < bridge> <Jupstar ‚ú™> Smileys i usually don't use xd
13:43 < bridge> <Ryozuki> sure üôÇ
13:44 < bridge> <Jupstar ‚ú™> üßê
13:44 < bridge> <Ryozuki> cpp is nice üôÇ
13:44 < bridge> <Jupstar ‚ú™> Rust sucksü•≤
13:46 < bridge> <Patiga> hm then what is actually the ddnet way of tee rendering? if you have every texture separately, what are your actual vertex/transformation buffers?
13:46 < bridge> <Jupstar ‚ú™> I assume they are all push constants
13:47 < bridge> <Jupstar ‚ú™> No buffers involved
13:47 < bridge> <Patiga> oh
13:47 < bridge> <Patiga> what about the camera, are all positional calculations done on the cpu?
13:47 < bridge> <Jupstar ‚ú™> Since max 64 tees are visible it should be fine probably
13:48 < bridge> <Jupstar ‚ú™> Desktop computers might have a slight advantage. But creating rendering info buffers also costs a bit time
13:48 < bridge> <Jupstar ‚ú™> So in total it's probably not too much overhead and works on all renders
13:49 < bridge> <Jupstar ‚ú™> And is pixel perfect
13:49 < bridge> <Jupstar ‚ú™> I'd say if I reimplement ddnets. I'd not put images with different sizes in an Atlas anyway
13:49 < bridge> <Jupstar ‚ú™> Skin bodies could be in an array. But even there I'm not sure
13:50 < bridge> <Jupstar ‚ú™> Or weapons in your case
13:50 < bridge> <Patiga> but in the case of skins it shouldn't actually matter, no? all body parts are much smaller than their atlas segment
13:51 < bridge> <Jupstar ‚ú™> Probably yes. There is some really fat skin in the database
13:51 < bridge> <Jupstar ‚ú™> Maybe it bleeds for body outline
13:52 < bridge> <Jupstar ‚ú™> defatulYoda
13:52 < bridge> <Jupstar ‚ú™> Looks fine tho
13:52 < bridge> <Jupstar ‚ú™> So yeah will probably never happen
13:53 < bridge> <Jupstar ‚ú™> Maybe when zooming out lot
13:53 < bridge> <Patiga> okay and in the case of weapons, if I would put them into an texture array, I would have to rescale some of them since they don't have the same proportions, is that rescaling okay?
13:53 < bridge> <Patiga> https://ddnet.org/skins/skin/community/defatulYoda.png
13:53 < bridge> <Patiga> yeah it looks the closest but is probably still fine
13:54 < bridge> <Jupstar ‚ú™> Mhh then that's also a problem here too
13:54 < bridge> <Jupstar ‚ú™> Thought they are all same
13:55 < bridge> <Jupstar ‚ú™> Generally rescale should be fine. But on fly u probably don't use a very expensive algorithm, which might make it ugly
13:55 < bridge> <Patiga> yea it wouldn't be on the fly
13:56 < bridge> <Jupstar ‚ú™> Tbh. I'd really do the sampling my own completely
13:56 < bridge> <Patiga> I currently have a texture array for the tee skins and want to also insert the weapons in some static slots to be able to use them easily in the same draw call
13:58 < bridge> <Patiga> I don't really have a feel for pushconstants yet, when would you suggest using them. if we have at max 64 tees, I personally would've guessed that its better to have a buffer for all of them together than providing different push constants and doing each individually
13:58 < jupstar> so u want everything in one fat texture? :D
13:58 < bridge> <Patiga> yea :d
13:59 < jupstar> it probably is better to have them in one buffer, but u also have to respect some hardware weirdnesses like caching and stuff
13:59 < jupstar> from feeling i'd say it might be faster, but only very slightly, since it doesnt involve less GPU work
14:00 < jupstar> anyway, skins are different res than game.png? do you want to upscale all skins?
14:00 < bridge> <Patiga> > so u want everything in one fat texture?
14:00 < bridge> <Patiga> my thought was that it would be nice cause then I can render everything a single tee needs in a single draw call. and then even all tees in a single draw call
14:01 < jupstar> yep its nice and for demo rendering where all skins etc can be known beforehead it will probably be faster
14:01 < jupstar> as in you dont update the texture itself
14:02 < bridge> <Patiga> > anyway, skins are different res than game.png?
14:02 < bridge> <Patiga> well by default a skin.png is 256x128, game.png is 1024x512, but shotgun and grenade above each other is 256x128 again. since a tee only uses a few segments from game.png, I thought that I'd just take the size of the skins and use one slot of the skin array texture for 1 or 2 weapons
14:03 < bridge> <Patiga> I mean even for regular gameplay there can be at max 64 different skins
14:04 < jupstar> but anyway, your only real problem is the interpolated sampling isnt it?
14:04 < jupstar> the rest is just design of choice
14:06 < jupstar> since 100% pixel perfection is not your goal, isnt the solution i posted before good enough?
14:06 < bridge> <Jupstar ‚ú™> This
14:07 < bridge> <Patiga> hm well my biggest question still: lets say I wanna make it easy for myself and use exactly one skin slot for each weapon, we only have 6 of them so it should be fine and easy for the texture coordinates. however, will that rescaling make the weapons look much worse? it fear it would smoothen out edges when it shouldn't or smth (maybe I missed your answer)
14:08 < jupstar> btw u dont even need to rescale do you
14:08 < jupstar> simply put the weapon in the top left of the texture and then apply the texture coordinates % of the expected size
14:09 < jupstar> (since texture coordinates are normalized anyway)
14:09 < bridge> <Patiga> hm true, that sounds good
14:10 < bridge> <Patiga> yea I like that
14:10 < bridge> <Patiga> I'll probably also try to put the hook somewhere, so that I can use a single quad to render the entire repeating part of the hook ^^
14:11 < jupstar> that's gonna be the hardest part, since it might look very slightly wrong. But tbf vanilla teeworlds does this since 13 years and nobody really noticed. but yeah if the chains dont repeat pixel perfect u could:tm: notice it
14:13 < bridge> <Patiga> hm I'll see üòÖ
14:14 < bridge> <Patiga> btw how would you rate that indirect rendering thing? I think it looks fancy because you can use it to reuse command buffers where I would otherwise need to record them each time on buffers where I might need a different slice each time
14:15 < bridge> <Patiga> (just looked at it yesterday for the first time)
14:17 < jupstar_> did we talk about smth like that?, bit confused rn :D
14:18 < bridge> <Patiga> not yet
14:19 < bridge> <Patiga> but I currently struggle a lot with gpu buffers, especially with ones where I have them at a dynamic size and need to access the length on the cpu side each time which complicates the code there, since I can't just prerecord it
14:21 < bridge> <Jupstar ‚ú™> All these indirect stuff is really opengls try to reduce some cpu overhead with having a named state machine
14:22 < bridge> <Patiga> also, why do you switch between irc and discord so much? ^^
14:22 < bridge> <Jupstar ‚ú™> Chatting on mobile sucks
14:22 < bridge> <Jupstar ‚ú™> But mobile xd
14:22 < bridge> <Patiga> xd
14:22 < bridge> <Patiga> ah right one more thing
14:23 < bridge> <Patiga> back during the bigger voice chat with matricks, we had also talked a bit about rendering. regarding dilating he mentioned that we should just be able to use the blending mode with premultiplied_alpha, and wouldn't need to dilate ever again
14:24 < bridge> <Jupstar ‚ú™> I'm not quite sure I understand anyway. But prerecord is nice for environment drawing where all stuff always has same amount of vertices etc to draw
14:25 < bridge> <Jupstar ‚ú™> Yes that's true. U have to pre multiply every pixel then tho
14:25 < bridge> <Patiga> yea and with that indirect drawing you could also prerecord stuff with variable amounts of vertices
14:25 < bridge> <Patiga> but the gpu does that for us, no?
14:25 < bridge> <Patiga> eh ^ each line goes to one of your messages
14:26 < bridge> <Jupstar ‚ú™> But wouldn't u need to update the information then?
14:26 < bridge> <Patiga> yeah I thought you could just do a central buffer somewhere, but ofc that would introduce complexity elsewhere
14:26 < bridge> <Jupstar ‚ú™> No the image itself need  to be premultiplied
14:27 < bridge> <Jupstar ‚ú™> I dunno if GPUs have an API for that
14:27 < bridge> <Jupstar ‚ú™> Vanilla does it on cpu
14:29 < bridge> <Jupstar ‚ú™> Also premultiplied implies no alpha modification afterwards(fragment shader)
14:30 < bridge> <Jupstar ‚ú™> Since e.g. a tile layer has a color that is applied at fragment stage
14:30 < bridge> <Patiga> ouch I thought it was a setting of a sampler, but now I see its about blending the different things we render
14:30 < bridge> <Jupstar ‚ú™> A alpha channel inside the color to be precise
14:32 < bridge> <Patiga> @matricks maybe you could chime in here if you have time. premultiplied alpha is a setting at the wrong part of the pipeline to fix needing to dilate, no? dilating fixes the interpolation in the fragment shader
14:33 < bridge> <Jupstar ‚ú™> It does
14:34 < bridge> <Jupstar ‚ú™> But ddnet multiplies tile layer color at fragment stage. U can do it by hand ofc
14:34 < bridge> <Jupstar ‚ú™> 
14:34 < bridge> <Jupstar ‚ú™> Vanilla prepares the color on the cpu already
14:34 < bridge> <Jupstar ‚ú™> And I assume the static pipeline handles the rest then
14:36 < bridge> <Jupstar ‚ú™> It should not matter tho probably when I think about it
14:37 < bridge> <Patiga> not sure what you mean by doing it by hand. dilating solves the issue of the interpolation during the sampling of the texture, no? since pixels with alpha = 0 have an effect on the color
14:37 < bridge> <Jupstar ‚ú™> But I'm not aware of the GPU handling it for textures
14:37 < bridge> <Jupstar ‚ú™> Yep but pre multiplies alpha also don't have the problem ofc
14:39 < bridge> <Patiga> aah but as I just figured out such a thing doesn't exist, right? not sure how you would do that by hand (in the fragment shader) since you would somehow need to get the color of all the pixels you need to interpolate between
14:40 < bridge> <Jupstar ‚ú™> U can get them. But yeah it's a bit of struggle
14:40 < bridge> <Patiga> agreed ^^
14:41 < bridge> <Jupstar ‚ú™> So either go dilate and have disadvantage when creating the img. Or premultiplied and have to run over the full texture
14:41 < bridge> <Patiga> üëç
14:42 < bridge> <Jupstar ‚ú™> I don't recommend any tho. From what I read both methods are used . GTA 5 uses smth like dilate for bushes ans similar assets apparently
14:42 < bridge> <Jupstar ‚ú™> Maybe it depends on how often they upload and unload textures
16:48 < bridge> <Ryozuki> https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/
16:48 < bridge> <Ryozuki> made with rust xd
17:10 < bridge> <Simon'> my ddnet always crashes after a few seconds if i join skyblock on ddnet ger server
17:11 < bridge> <deen> Can you try https://wiki.ddnet.org/wiki/GFX_Troubleshooting and if that doesn't help https://wiki.ddnet.org/wiki/Troubleshooting#Crashes ?
17:14 < bridge> <Simon'> ddnet usa and everything else works fine tho
17:14 < bridge> <Simon'> its just that one server
17:15 < bridge> <chillerdragon> What even is skyblock? Sounds like minecraft xd
17:16 < bridge> <Simon'> skycraft*
17:16 < bridge> <chillerdragon> A
17:17 < bridge> <chillerdragon> https://ddnet.org/maps/skycraft
17:20 < bridge> <Simon'> where is the switch for laser no 7 on that map? i cant find it
17:27 < bridge> <Ryozuki> @Jupeyy_Keks what do u think about this https://mlir.llvm.org/docs/Dialects/MemRef/#
17:27 < bridge> <Ryozuki> this dialect is used to represent a "pointer descripter"
17:27 < bridge> <Ryozuki> this dialect is used to represent a "pointer descriptor"
17:27 < bridge> <Ryozuki> tldr: a pointer an all possible info about it, to optimize better
17:30 < bridge> <Jupstar ‚ú™> Epic af
17:31 < bridge> <Jupstar ‚ú™> Hardware info. F1 after client start whole console and purple text mentioning gfx
17:31 < bridge> <Jupstar ‚ú™> And top right in F1
17:31 < bridge> <Jupstar ‚ú™> Text
17:32 <+ChillerDragon> use chilerbot hax and type ``goto_switch 7`` in console
17:36 < bridge> <Simon'> what?
17:37 < bridge> <Simon'> no fr i searched it in the editor, theres no switch 7. i want to open the laser at the big shortcut where u jump left from spawn and then fly under the big tube
17:40 < bridge> <Jupstar ‚ú™> Press F1 after client start pls and make screenshot
17:42 < bridge> <Simon'> https://cdn.discordapp.com/attachments/293493549758939136/1096098170733350922/screenshot_2023-04-13_17-41-39.png
17:45 < bridge> <Jupstar ‚ú™> Mh ok. Any crash dumps in %appdata%/ddnet/dumps?
17:46 < bridge> <Jupstar ‚ú™> U can delete that btw
17:48 < bridge> <Simon'> no its empty
17:49 < bridge> <Jupstar ‚ú™> Weird then
17:54 < bridge> <gerdoe> also is `MACRO_ALLOC_HEAP()` needed?
17:54 < bridge> <gerdoe> ```cpp
17:54 < bridge> <gerdoe> #define MACRO_ALLOC_HEAP() \
17:54 < bridge> <gerdoe> public: \
17:55 < bridge> <gerdoe>     void *operator new(size_t Size) \
17:55 < bridge> <gerdoe>     { \
17:55 < bridge> <gerdoe>         void *p = malloc(Size); \
17:55 < bridge> <gerdoe>         mem_zero(p, Size); \
17:55 < bridge> <gerdoe>         return p; \
17:55 < bridge> <gerdoe>     } \
17:55 < bridge> <gerdoe>     void operator delete(void *pPtr) \
17:55 < bridge> <gerdoe>     { \
17:55 < bridge> <gerdoe>         free(pPtr); \
17:55 < bridge> <gerdoe>     } \
17:55 < bridge> <gerdoe> \
17:55 < bridge> <gerdoe> private:```
17:55 < bridge> <gerdoe> it does the same thing constructor does
17:57 < bridge> <gerdoe> appears to be used only in `src/game/server/entity.h`
17:58 < bridge> <Jupstar ‚ú™> yes
17:58 < bridge> <Jupstar ‚ú™> its overloading thje new opeartor
17:59 < bridge> <Jupstar ‚ú™> is it not defined twice?
18:00 < bridge> <gerdoe> nope
18:00 < bridge> <Jupstar ‚ú™> ok its not nvm me than, i thought its a different one
18:01 < bridge> <Jupstar ‚ú™> yeah its useless, according to vanilla they once used it for dbg msgs
18:01 < bridge> <gerdoe> huh
18:01 < bridge> <gerdoe> will get rid of alloc.h
18:01 < bridge> <Jupstar ‚ú™> ah but actually its maybe not useless
18:01 < bridge> <Ryozuki> https://github.com/doomemacs/doomemacs
18:01 < bridge> <Jupstar ‚ú™> new CEntity != new CEntity()
18:01 < bridge> <Ryozuki> i need to try this
18:02 < bridge> <Ryozuki> i never rly tried emacs
18:02 < bridge> <Jupstar ‚ú™> first one will leave centity uninitialized if no custom constructor was implemented
18:02 < bridge> <Jupstar ‚ú™> tho we probably always have one
18:02 < bridge> <Ryozuki> @Learath2 probs knows the details
18:03 < bridge> <Ryozuki> @Jupeyy_Keks is there a semantic difference between new with cpp and malloc?
18:03 < bridge> <Ryozuki> maybe thats why its done
18:03 < bridge> <Ryozuki> well this ensures the memory is zeroed atleast
18:03 < bridge> <Jupstar ‚ú™> not with new
18:03 < bridge> <Jupstar ‚ú™> 
18:03 < bridge> <Jupstar ‚ú™> but with implicit constructors
18:03 < bridge> <Learath2> We probably also used it while testing as ASan has trouble with global memory
18:04 < bridge> <Jupstar ‚ú™> that's why this
18:04 < bridge> <Jupstar ‚ú™> 
18:04 < bridge> <Jupstar ‚ú™> for implicit constructors the first would not zero the bytes
18:04 < bridge> <Ryozuki> why not just use calloc here? it zeroes the memory
18:04 < bridge> <Ryozuki> might me more efficient
18:04 < bridge> <Jupstar ‚ú™> the second guarantes it
18:04 < bridge> <Jupstar ‚ú™> tbh just remove that then xD
18:04 < bridge> <Jupstar ‚ú™> then c++ can decide
18:04 < bridge> <Learath2> Ancient code. It's been there forever
18:05 < bridge> <Jupstar ‚ú™> based on the object structure
18:06 < bridge> <Learath2> Btw, we probably should delete the implicit constructors for some of our classes
18:06 < bridge> <Jupstar ‚ú™> well if a custom is provided they are automatically deleted
18:07 < bridge> <Ryozuki> @Learath2 does new from cpp zero memory?
18:07 < bridge> <Ryozuki> oh
18:07 < bridge> <Jupstar ‚ú™> damn
18:08 < bridge> <Jupstar ‚ú™> 
18:08 < bridge> <Jupstar ‚ú™> i tried cargo-geiger
18:08 < bridge> <Jupstar ‚ú™> 
18:08 < bridge> <Jupstar ‚ú™> didn't expect so much use of unsafe tbh xD
18:08 < bridge> <Ryozuki> maybe it uses default values
18:08 < bridge> <Learath2> Depends entirely on what flavor of initialization you do. C++ has like a billion ways
18:08 < bridge> <Ryozuki> this is the thing with cpp, u need to know this, in rust this isnt a problem cuz u just cant have uninit values
18:08 < bridge> <Ryozuki> blegh
18:09 < bridge> <Ryozuki> @Learath2 iirc i saw there are entire books on initialization in cpp
18:09 < bridge> <Ryozuki> its insane
18:09 < bridge> <Jupstar ‚ú™> yep it would defs be nice to have it explicit, like unsafe{new CEntity; //<-- no zeroing }
18:09 < bridge> <Jupstar ‚ú™> would make more sense
18:10 < bridge> <Jupstar ‚ú™> 39850 unsafes linked into the final executable
18:10 < bridge> <Jupstar ‚ú™> 
18:10 < bridge> <Jupstar ‚ú™> ez
18:10 < bridge> <Jupstar ‚ú™> lets see if lto changes smth
18:11 < bridge> <Ryozuki> xd
18:11 < bridge> <Ryozuki> wdym by that
18:11 < bridge> <Ryozuki> unsafes linked
18:11 < bridge> <Ryozuki> i lost u
18:11 < bridge> <Jupstar ‚ú™> i used cargo geiger to see uses of unsafe in dependencies (and own code)
18:12 < bridge> <Jupstar ‚ú™> and apparently 39850 times unsafe code is used that also lands in the final code
18:12 < bridge> <Ryozuki> ah
18:12 < bridge> <Ryozuki> in ur project?
18:12 < bridge> <Jupstar ‚ú™> yeah
18:13 < bridge> <Ryozuki> well if u interface with vulkan c api its inevitable
18:13 < bridge> <Ryozuki> xd
18:13 < bridge> <Jupstar ‚ú™> yep, but there are many unsafes in libs i didnt expect. well pretty much all libs have at least one time use üòÑ
18:14 < bridge> <Ryozuki> does geiger tell u
18:14 < bridge> <Learath2> Yeah, there is a really nice talk in it that tells you that you basically should always be using `T t{}` which is `value-initialization` that invokes `aggregate-initialization` which does `zero-initialization` on every member according to the rules of that
18:14 < bridge> <Ryozuki> @Jupeyy_Keks another awesome thing about rust is exactly this
18:14 < bridge> <Ryozuki> u know where the unsafe is
18:14 < bridge> <Ryozuki> its localized
18:14 < bridge> <Ryozuki> does geiger tell u which*
18:14 < bridge> <Ryozuki> libraries
18:14 < bridge> <Ryozuki> i cant type today
18:14 < bridge> <Jupstar ‚ú™> https://cdn.discordapp.com/attachments/293493549758939136/1096106229580955801/image.png
18:14 < bridge> <Learath2> Which avoids setting some things to zero like memzero would, if not needed that is. And it won't nuke the vtable üòõ
18:14 < bridge> <Ryozuki> slow brain lol
18:14 < bridge> <Ryozuki> pog
18:15 < bridge> <Ryozuki> <a:Noted:1039292851399446538>
18:16 < bridge> <Ryozuki> can u try color_eyre
18:16 < bridge> <Ryozuki> instead of anyhow
18:16 < bridge> <Learath2> https://youtu.be/7DTlWPgX6zs I think this was the talk
18:17 < bridge> <Learath2> Honestly it's mostly shit only because we have to keep 2 decades of code working
18:17 < bridge> <Ryozuki> all u need in rust to know: https://doc.rust-lang.org/book/ch05-01-defining-structs.html
18:17 < bridge> <Learath2> Please, just break this stuff already. The two decade old code can compile with an older compiler. It doesn't need to compile with this one
18:18 < bridge> <Ryozuki> and maybe this https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html
18:18 < bridge> <Ryozuki> if u do advanced stuff
18:19 < bridge> <Voxel> yknow i already forgot
18:19 < bridge> <Voxel> what does the rust code in ddnet do again
18:19 < bridge> <Ryozuki> ```rust
18:19 < bridge> <Ryozuki> use std::mem::MaybeUninit;
18:19 < bridge> <Ryozuki> 
18:19 < bridge> <Ryozuki> // Create an explicitly uninitialized reference. The compiler knows that data inside
18:19 < bridge> <Ryozuki> // a `MaybeUninit<T>` may be invalid, and hence this is not UB:
18:19 < bridge> <Ryozuki> let mut x = MaybeUninit::<&i32>::uninit();
18:19 < bridge> <Ryozuki> // Set it to a valid value.
18:19 < bridge> <Ryozuki> x.write(&0);
18:19 < bridge> <Ryozuki> // Extract the initialized data -- this is only allowed *after* properly
18:19 < bridge> <Ryozuki> // initializing `x`!
18:19 < bridge> <Ryozuki> let x = unsafe { x.assume_init() };
18:19 < bridge> <Ryozuki> ```
18:19 < bridge> <Learath2> Rust is cheating by making the default be the better safe than sorry option
18:19 < bridge> <Learath2> Illegal
18:20 < bridge> <Learath2> Nothing for now
18:20 < bridge> <Ryozuki> printing the rust version
18:20 < bridge> <Voxel> üíÄ
18:20 < bridge> <Ryozuki> which is needed for rust propaganda
18:20 < bridge> <Learath2> Heinrich wanted to replace the entire networking stack with it and someone else wanted to replace the entire gamecore
18:20 < bridge> <Ryozuki> i want to do smth with rust in ddnet but all stuff i think may be too complex or time consuming
18:20 < bridge> <Ryozuki> ideally we should move the http stuff to rust
18:20 < bridge> <Learath2> Neither project ended up being a thing tho
18:21 < bridge> <Voxel> if it replaces graphics related things then i rq being a dev
18:21 < bridge> <Voxel> because in the future i want to make my own client
18:21 < bridge> <Ryozuki> @Voxel with this u can generate maps https://github.com/edg-l/ddnet-map-gen
18:21 < bridge> <Ryozuki> kek
18:22 < bridge> <Voxel> automatic gores
18:22 < bridge> <Learath2> Graphics only @Jupeyy_Keks would dare convert to Rust, and he would only support 40xx series nvidia cards
18:22 < bridge> <Ryozuki> it has a fly map generator and maze for now
18:22 < bridge> <Ryozuki> gores in the future tm
18:22 < bridge> <Voxel> so basically infinite plantknight content
18:22 < bridge> <Jupstar ‚ú™> i already converted the whole vk backend lel
18:22 < bridge> <Ryozuki> kek
18:23 < bridge> <Ryozuki> rust takeover is inevitable
18:23 < bridge> <Jupstar ‚ú™> i might not backport it tho
18:23 < bridge> <Ryozuki> deen also uses rust in his work iirc as a test engineer
18:23 < bridge> <Ryozuki> who is left to convert to the cult?
18:23 < bridge> <Ryozuki> chairn i guess
18:23 < bridge> <Jupstar ‚ú™> i might not even release it. i am still unsure myself...
18:23 < bridge> <Jupstar ‚ú™> heinrich will probably be against rewritting
18:23 < bridge> <Jupstar ‚ú™> 
18:23 < bridge> <Jupstar ‚ú™> ryo and me are for ez
18:24 < bridge> <Jupstar ‚ú™> but not everyone is a fan like u xD
18:24 < bridge> <Voxel> what im saying is in the future i want to rehaul the tee animations thing in its own client to make all the movements procedrial, plus some other stuff
18:24 < bridge> <Voxel> basically making ddnet "pretty" for the fun of it
18:24 < bridge> <Ryozuki> learath is a closet fan
18:24 < bridge> <Ryozuki> he is just a tsundere
18:25 < bridge> <Ryozuki> go for it
18:25 < bridge> <Ryozuki> but prepare a thick skin
18:25 < bridge> <Ryozuki> as the oldies will cry
18:25 < bridge> <Ryozuki> :konsti_zoozer:
18:25 < bridge> <Voxel> its why im making it a seperate client
18:25 < bridge> <Jupstar ‚ú™> how the hell did i end up using turkish google translate xD
18:25 < bridge> <Jupstar ‚ú™> https://cdn.discordapp.com/attachments/293493549758939136/1096109008038928434/image.png
18:25 < bridge> <Ryozuki> xd
18:26 < bridge> <Voxel> xd
18:26 < bridge> <Voxel> anyways i **tried** using rust for smth personal, mainly the ninnou crate
18:26 < bridge> <Voxel> but i gave up after like 5 minutes
18:26 < bridge> <Jupstar ‚ú™> but why
18:27 < bridge> <Jupstar ‚ú™> am i the only person here that thinks that rust isnt as hard as ppl make it seem
18:28 < bridge> <Voxel> you need to do like 20 steps in order to make something more than a "hello world"
18:28 < bridge> <Jupstar ‚ú™> the only annoying things are QOL things. they make it harder bcs of e.g. fighting with borrow checker about valid code
18:29 < bridge> <Ryozuki> rust is ez
18:29 < bridge> <Jupstar ‚ú™> i dunno
18:29 < bridge> <Jupstar ‚ú™> in worst case u can basically use rust like javascript and copy around everything and convert to json xD
18:29 < bridge> <Ryozuki> well voxel do u even know how to do more complex stuff in cpp?
18:29 < bridge> <Ryozuki> maybe u simply lack basics
18:30 < bridge> <Ryozuki> rust facepalms u with quite advanced things
18:30 < bridge> <Ryozuki> slices, iterators, etc
18:30 < bridge> <Ryozuki> some ppl dont even know what that is
18:31 < bridge> <Voxel> barely
18:31 < bridge> <Voxel> i just scavenge the ddnet code and make sense of what i have in front of me
18:31 < bridge> <Ryozuki> u probs tried to use a mutable var inside a for loop withiut knowing how
18:31 < bridge> <Ryozuki> read the rust book
18:31 < bridge> <Ryozuki> and learn lots
18:32 < bridge> <Ryozuki> its a web btw not rly a book
18:32 < bridge> <Voxel> i forgot when i actually tried rust
18:32 < bridge> <Voxel> so i wouldnt know what i tried to do
18:35 < bridge> <Ryozuki> @Jupeyy_Keks https://www.nvidia.com/en-us/geforce/news/rtx-remix-runtime-open-source-download/
18:41 < bridge> <Jupstar ‚ú™> wait it even converts 32bit to 64bit?
18:41 < bridge> <Jupstar ‚ú™> or is it graphics driver only
18:41 < bridge> <Jupstar ‚ú™> "Bridge, which translates the renderer from a x86 to a x64 instruction set. This component uncaps the memory available for rendering."
18:41 < bridge> <Jupstar ‚ú™> mhh i am bit sceptical about that one üòÑ
18:42 < bridge> <Jupstar ‚ú™> as in they convert vs they simply use a server client model
18:45 < bridge> <Jupstar ‚ú™> interesting non than less, have to try for an old game that always had a bug üòÑ
18:57 < bridge> <Devinci> rust syntax seems ugly to me. At least for now.
18:57 < bridge> <Devinci> For example the types, putting them after the name of the var triggers me.
18:57 < bridge> <Devinci> Feels hard when you aren't used to it. (Haven't really looked too deep into it yet though)
18:58 < bridge> <Jupstar ‚ú™> yeah but usually u get used to it
18:59 < bridge> <Jupstar ‚ú™> i started with pascal, so it wasnt uncommon to me
18:59 < bridge> <k2d222> even cpp is moving to types on the right
18:59 < bridge> <k2d222> herb stutter has a whole talk on that I think
18:59 < bridge> <Devinci> Oh really? I guess I'll stay on C then :greenthing:
19:00 < bridge> <Jupstar ‚ú™> how are they doing that? lol
19:00 < bridge> <Jupstar ‚ú™> would be a huge mess to support both
19:00 < bridge> <k2d222> I mean not syntaxically but conceptually
19:00 < bridge> <Devinci> eh?
19:00 < bridge> <k2d222> like `auto x = MyClass()` instead of `MyClass x`
19:00 < bridge> <Jupstar ‚ú™> ah
19:01 < bridge> <Jupstar ‚ú™> i dont think he means that
19:01 < bridge> <Devinci> But auto is the type here
19:01 < bridge> <Jupstar ‚ú™> he means let x: i32<-- = 0
19:01 < bridge> <Devinci> y
19:01 < bridge> <k2d222> well, u dont write explicit types that often in rust do you
19:01 < bridge> <Jupstar ‚ú™> but yeah excpect for functions and struct members u often dont need to set the type
19:01 < bridge> <Jupstar ‚ú™> since it automatically will do it similar to auto
19:02 < bridge> <Devinci> Yeah, I read it's only when there can be confusion. Still, felt strange
19:03 < bridge> <Jupstar ‚ú™> what i really find ugly is calling generic functions
19:03 < bridge> <Jupstar ‚ú™> Type::<i32>::func()
19:03 < bridge> <Jupstar ‚ú™> or func::<i32>()
19:04 < bridge> <Devinci> Btw, are there slices on cpp? Didn't really here of them, and tried googling it and I just got the class std::slice (which didn't seem to be the same)
19:04 < bridge> <k2d222> yea but they compensate with a cool name the **turbofish operator** XD
19:04 < bridge> <Jupstar ‚ú™> there are ranges
19:04 < bridge> <Devinci> on iterators?
19:05 < bridge> <k2d222> iterator adaptators
19:05 < bridge> <Devinci> y kk, thanks
19:05 < bridge> <Ryozuki> rust slices are beautiful
19:05 < bridge> <Ryozuki> and safe
19:05 < bridge> <k2d222> *adaptor whatever
19:05 < bridge> <Ryozuki> cpp iterators are a minefield
19:05 < bridge> <Jupstar ‚ú™> xd
19:05 < bridge> <Ryozuki> xd
19:05 < bridge> <Ryozuki> string_view
19:05 < bridge> <Ryozuki> kekw
19:06 < bridge> <Jupstar ‚ú™> rip
19:06 < bridge> <Jupstar ‚ú™> only good thing is that c++20 supports them for hashes xd
19:07 < bridge> <Jupstar ‚ú™> can u hash a str in rust? not even sure rn
19:07 < bridge> <Jupstar ‚ú™> for a HashMap<String, ...> ofc
19:07 < bridge> <k2d222> there is a hash trait no?
19:08 < bridge> <Ryozuki> define hashing a str
19:08 < bridge> <Jupstar ‚ú™> but can u use it for a HashMap that uses String
19:08 < bridge> <Jupstar ‚ú™> i mean let a = HashMap<String, ...>
19:08 < bridge> <Jupstar ‚ú™> 
19:08 < bridge> <Jupstar ‚ú™> let b = "str";
19:08 < bridge> <Jupstar ‚ú™> a.get(b);
19:08 < bridge> <Ryozuki> the hash trait allows the type to be hashed by a type implementing hasher
19:08 < bridge> <Ryozuki> https://doc.rust-lang.org/std/hash/trait.Hash.html
19:08 < bridge> <Ryozuki> that works
19:09 < bridge> <Jupstar ‚ú™> ok
19:09 < bridge> <Ryozuki> but its also kinda a special case
19:09 < bridge> <Ryozuki> well its not special
19:09 < bridge> <Ryozuki> its well defined
19:09 < bridge> <Ryozuki> what happens here is that
19:09 < bridge> <Ryozuki> get accepts a reference to a String
19:09 < bridge> <Ryozuki> and &str derefs to it xd
19:10 < bridge> <Ryozuki> .get() arg is a &String
19:10 < bridge> <Ryozuki> so it accepts a &str
19:10 < bridge> <Ryozuki> is what i mean
19:10 < bridge> <Jupstar ‚ú™> yeah
19:10 < bridge> <Jupstar ‚ú™> sounds good
19:11 < bridge> <Ryozuki> hashmaps take keys by reference unless they need the key to insert
19:11 < bridge> <Ryozuki> due to thread safety iirc
19:11 < bridge> <Ryozuki> @Jupeyy_Keks btw u should look at the entry api of hashmaps
19:11 < bridge> <Ryozuki> and dashmap is nice for mt hashmap
19:12 < bridge> <Ryozuki> ```rust
19:12 < bridge> <Ryozuki> let mut letters = HashMap::new();
19:12 < bridge> <Ryozuki> 
19:12 < bridge> <Ryozuki> for ch in "a short treatise on fungi".chars() {
19:12 < bridge> <Ryozuki>     letters.entry(ch).and_modify(|counter| *counter += 1).or_insert(1);
19:12 < bridge> <Ryozuki> }
19:12 < bridge> <Ryozuki> 
19:12 < bridge> <Ryozuki> assert_eq!(letters[&'s'], 2);
19:12 < bridge> <Ryozuki> assert_eq!(letters[&'t'], 3);
19:12 < bridge> <Ryozuki> assert_eq!(letters[&'u'], 1);
19:12 < bridge> <Ryozuki> assert_eq!(letters.get(&'y'), None);
19:12 < bridge> <Ryozuki> ```
19:12 < bridge> <Ryozuki> epic
19:12 < bridge> <Ryozuki> https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry
19:12 < bridge> <Ryozuki> dashmap uses this api kinda to allow atomic get or inserts
19:13 < bridge> <Jupstar ‚ú™> oh interesting
19:13 < bridge> <Ryozuki> ```rust
19:13 < bridge> <Ryozuki> let entry = STRING_CACHE
19:13 < bridge> <Ryozuki>             .entry(string.to_owned())
19:13 < bridge> <Ryozuki>             .or_insert_with(|| CString::new(string).unwrap());
19:13 < bridge> <Ryozuki> unsafe { Self::from_raw(mlirStringRefCreateFromCString(entry.as_ptr())) }
19:13 < bridge> <Ryozuki> ```
19:13 < bridge> <Chairn> sorry, no time for this
19:13 < bridge> <Ryozuki> this is using dashmap
19:14 < bridge> <Jupstar ‚ú™> and rust needs more const/constexpr everywhere xd
19:14 < bridge> <Jupstar ‚ú™> 
19:14 < bridge> <Jupstar ‚ú™> but i heard they working on it
19:14 < bridge> <Ryozuki> ```rust
19:14 < bridge> <Ryozuki> // We need to pass null-terminated strings to functions in the MLIR API although
19:14 < bridge> <Ryozuki> // Rust's strings are not.
19:14 < bridge> <Ryozuki> static STRING_CACHE: Lazy<DashMap<String, CString>> = Lazy::new(Default::default);
19:14 < bridge> <Ryozuki> ```
19:14 < bridge> <Ryozuki> xd
19:14 < bridge> <Ryozuki> stupid c deciding null terminated strings
19:14 < bridge> <Jupstar ‚ú™> rip
19:14 < bridge> <Ryozuki> they make rust less efficient when interfacing with it
19:15 < bridge> <Jupstar ‚ú™> yeah
19:15 < bridge> <Ryozuki> some c apis dont require null terminated strings
19:15 < bridge> <Ryozuki> some llvm parts use a array with len
19:15 < bridge> <Ryozuki> but not here
19:15 < bridge> <Jupstar ‚ú™> well the vk api is even worse
19:15 < bridge> <Jupstar ‚ú™> it sometimes expects i8 arrays xD
19:15 < bridge> <Ryozuki> xdd
19:15 < bridge> <Jupstar ‚ú™> char arrays basically
19:15 < bridge> <Ryozuki> oof
19:15 < bridge> <Jupstar ‚ú™> converting to them sucks
19:15 < bridge> <Jupstar ‚ú™> or from
19:16 < bridge> <Ryozuki> its c fault
19:16 < bridge> <Ryozuki> rust is the sane one here
19:16 < bridge> <Ryozuki> imagine needing to loop a string to figure out its length
19:16 < bridge> <Devinci> How does rust do it?
19:17 < bridge> <Jupstar ‚ú™> size: usize
19:17 < bridge> <Ryozuki> it has a array with the data and a variable holding the length of the data
19:17 < bridge> <Jupstar ‚ú™> ez
19:17 < bridge> <Ryozuki> so getting the length is constant time
19:17 < bridge> <Ryozuki> u keep track of it separate of the data itself
19:17 < bridge> <Ryozuki> and u don have limitations
19:17 < bridge> <Ryozuki> for example ur data can hold null chars
19:17 < bridge> <Ryozuki> unlike c
19:17 < bridge> <Devinci> yeah but where do you get the lenght initially? From the constructor?
19:18 < bridge> <Jupstar ‚ú™> str is basically a slice
19:18 < bridge> <Jupstar ‚ú™> so it also does the same
19:18 < bridge> <Jupstar ‚ú™> so basically its always known
19:18 < bridge> <Jupstar ‚ú™> if not working with c or filesystems or other io stuff
19:19 < bridge> <Ryozuki> its like vec
19:19 < bridge> <Ryozuki> ```
19:19 < bridge> <Ryozuki> #[stable(feature = "rust1", since = "1.0.0")]
19:19 < bridge> <Ryozuki> #[cfg_attr(not(test), rustc_diagnostic_item = "Vec")]
19:19 < bridge> <Ryozuki> #[rustc_insignificant_dtor]
19:19 < bridge> <Ryozuki> pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
19:19 < bridge> <Ryozuki>     buf: RawVec<T, A>,
19:19 < bridge> <Ryozuki>     len: usize,
19:19 < bridge> <Ryozuki> }
19:19 < bridge> <Ryozuki> ```
19:19 < bridge> <Ryozuki> for the String type
19:19 < bridge> <Ryozuki> ```rust
19:19 < bridge> <Ryozuki> #[stable(feature = "rust1", since = "1.0.0")]
19:19 < bridge> <Ryozuki> #[cfg_attr(not(test), rustc_diagnostic_item = "Vec")]
19:19 < bridge> <Ryozuki> #[rustc_insignificant_dtor]
19:19 < bridge> <Ryozuki> pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
19:19 < bridge> <Ryozuki>     buf: RawVec<T, A>,
19:19 < bridge> <Ryozuki>     len: usize,
19:19 < bridge> <Ryozuki> }
19:19 < bridge> <Ryozuki> ```
19:19 < bridge> <Ryozuki> the size is always known ye
19:20 < bridge> <Devinci> ic
19:20 < bridge> <Jupstar ‚ú™> btw c++ does it too but additionally has null termination
19:21 < bridge> <Devinci> Can't C have null chars on array? I'm pretty sure it can, but will just stop there
19:21 < bridge> <Jupstar ‚ú™> yes
19:21 < bridge> <Jupstar ‚ú™> but is that a desired functionality? üòÑ
19:21 < bridge> <Devinci> "it's not a bug it's a feature"
19:21 < bridge> <Ryozuki> thats the thing
19:22 < bridge> <Ryozuki> null chars are used for behaviour
19:22 < bridge> <Ryozuki> so u cant have them for data as is
19:22 < bridge> <Devinci> Ah I got what you meant
19:23 < bridge> <Ryozuki> give me the length in C of a array of null chars with length 10
19:23 < bridge> <Jupstar ‚ú™> c follows the paradigma "everything is a file"
19:23 < bridge> <Jupstar ‚ú™> 
19:23 < bridge> <Jupstar ‚ú™> so a string ends with a null
19:23 < bridge> <Jupstar ‚ú™> 
19:23 < bridge> <Jupstar ‚ú™> just like a file ends with EOF
19:23 < bridge> <Ryozuki> of a string array*
19:23 < bridge> <Ryozuki> xd
19:23 < bridge> <Devinci> char pointer üòé
19:23 < bridge> <Devinci> 0?
19:23 < bridge> <Ryozuki> i mean using strlen yeah
19:45 < bridge> <Jupstar ‚ú™> Ain't Nobody Got Time for That
20:01 < bridge> <Ryozuki> knowing the len allows for neat things, knowing a str is valid utf always too
20:01 < bridge> <Ryozuki> its actually UB to unsafely create a str with invalid utf8
21:34 < bridge> <Ryozuki> https://www.ccma.cat/324/espanya-investiga-chatgpt-per-una-possible-violacio-de-la-proteccio-de-dades-dels-usuaris/noticia/3223411/
21:34 < bridge> <Ryozuki> spain is also investigating chatgpt lmao
21:34 < bridge> <Ryozuki> (catalan news kek)
21:35 < bridge> <Jupstar ‚ú™> what is there to investigate xD
21:35 < bridge> <Ryozuki> privacy concerns xd
21:35 < bridge> <Ryozuki> @Jupeyy_Keks everybody talks about AI
21:35 < bridge> <Ryozuki> even normies
21:35 < bridge> <Ryozuki> on the bars
21:35 < bridge> <Ryozuki> trust me
21:35 < bridge> <Ryozuki> i heard on restaurants too
21:35 < bridge> <Ryozuki> the revolution is imminent
21:39 < bridge> <Voxel> it still irks me tbh
21:40 < bridge> <Ryozuki> well yeah
21:40 < bridge> <Ryozuki> its untested waters
21:43 < bridge> <Ryozuki> @Jupeyy_Keks https://www.reddit.com/r/rust/comments/12ks0ka/png_crate_gets_an_ultrafast_compression_mode_up/
21:43 < bridge> <Ryozuki> more perf
21:43 < bridge> <Ryozuki> ```
21:43 < bridge> <Ryozuki> The latest release, v0.17.8, takes from 15% to 75% less time to decode images than the previous v0.17.7. 75% less time means 4x faster! The gains depend heavily on the exact image used, but even 15% is impressive given how fast the code already is.
21:43 < bridge> <Ryozuki> 
21:43 < bridge> <Ryozuki> These gains in decompression are achieved by:
21:43 < bridge> <Ryozuki> 
21:43 < bridge> <Ryozuki>     A new, specialized Zlib implementation designed specifically for PNG from the ground up. It delivers much higher performance than the generic Zlib implementation used previously.
21:43 < bridge> <Ryozuki> 
21:43 < bridge> <Ryozuki>     PNG filters were rewritten to take advantage of autovectorization, making use of SIMD without unsafe or platform-specific code.
21:43 < bridge> <Ryozuki> 
21:43 < bridge> <Ryozuki> This should make the png crate faster than the reference C implementation in most cases. But it's difficult to benchmark libpng because its API is so unwieldy, and it doesn't provide example code for decoding an image. We'd be very happy to see such benchmark results!
21:43 < bridge> <Ryozuki> ```
21:43 < bridge> <Jupstar ‚ú™> WTF a lib i saw before ryo saw it, ez
21:44 < bridge> <Jupstar ‚ú™> a news*
21:44 < bridge> <Jupstar ‚ú™> lol
21:44 < bridge> <Ryozuki> xd
21:45 < bridge> <Ryozuki> somehow i just need to read the rust reddit to get more hyped about rust
21:45 < bridge> <Ryozuki> and keeps going
21:47 < bridge> <Ryozuki> i need to write a blog about llvm and rust
21:47 < bridge> <Ryozuki> someday
21:47 < bridge> <Ryozuki> but i always feel lazy
21:47 < bridge> <Ryozuki> the life of a dev
21:48 < bridge> <Ryozuki> im literally the only maintainer of the active mlir api bindings for rust
21:48 < bridge> <Jupstar ‚ú™> i'll read
21:48 < bridge> <Jupstar ‚ú™> the tl;dr
21:50 < bridge> <Ryozuki> xd
21:50 < bridge> <Ryozuki> then ill make no tldr
21:54 < bridge> <LE07D> How do I run football maps on my server?
21:55 < bridge> <LE07D> I have the map but I need to configure the teams and rules
21:55 < bridge> <LE07D> and I dont know hoe
21:55 < bridge> <LE07D> and I dont know how
22:05 < bridge> <deen> you probably need to download the football mod source code and compile it
22:30 < bridge> <Ryozuki> https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html
22:30 < bridge> <Ryozuki> @Jupeyy_Keks
23:02 < bridge> <Ewan> unless you predefine the size & access exactly that many chars, either by just using the proper size or using a fixed-size array, you won't be able to use strings with null bytes in them because string functions that glean info from char pointers will always end at \0
23:16 < bridge> <Jupstar ‚ú™> Mimimi xdd
