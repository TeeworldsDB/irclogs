05:34 < bridge> <pathos3005> @chillerdragon https://github.com/ddnet-insta/ddnet-insta/tree/master
05:34 < bridge> <pathos3005> Any reason why master isn't default branch?
05:34 < bridge> <pathos3005> And approximately how long until DM/CTF is implemented? :D
06:17 < ws-client1> <ChillerDragon> @pathos3005 the only known todo for dm/ctf is some minor warmup thing thats not too important https://github.com/ddnet-insta/ddnet-insta/issues/136
06:19 < ws-client1> <ChillerDragon> the thing that is missing for it to be called completed is a proper gameplay test. My public server is already public at 88.198.96.203:8309 please report any issues you find :)
06:21 < ws-client1> <ChillerDragon> the master branch is used for pure ddnet and merging could also name that one "ddnet" or "upstream" i think it was more convienient for me back in the days if i could click "sync fork" for the master on github and then just pull. So I can merge into ddnet without a remote.
12:39 < bridge> <milkeeycat> Any rust pro have a link to a resource where described how procedural macros work, how `rustc` calls them etc.
13:26 < bridge> <Jupstar âœª> Have you used them before?
13:26 < bridge> <Jupstar âœª> 
13:26 < bridge> <Jupstar âœª> They simply take tokens and output tokens.
13:26 < bridge> <Jupstar âœª> 
13:26 < bridge> <Jupstar âœª> You could say u take text and give back text
13:26 < bridge> <milkeeycat> ye, I know that xd
13:26 < bridge> <milkeeycat> I'm more interested how they are used by compiler, they are first compiled by `rustc` and then somehow get called
13:27 < bridge> <Jupstar âœª> Yes, exactly like that xd
13:39 < bridge> <milkeeycat> Found this https://blog.jetbrains.com/rust/2022/07/07/procedural-macros-under-the-hood-part-ii/
14:04 < bridge> <learath2> That's the reason they have to be in a different crate in rust iirc
14:07 < bridge> <learath2> They are probably handled as a compiler plugin of sorts. You compile the proc macro, then call out to it after building the initial ast to clean up the macro nodes
17:09 < bridge> <zhn> for vanilla mods use jsaurus fork
17:10 < bridge> <zhn> we did discuss it with chiller before, ddnet-insta is insta only and will not have any vanilla mods in it eh
17:26 < bridge> <_voxeldoesart> Is this a better color for freeze lasers?
17:26 < bridge> <_voxeldoesart> https://cdn.discordapp.com/attachments/293493549758939136/1020451693495844925/unknown.png?ex=670b97f2&is=670a4672&hm=157ada020b1ae42b2d0e7991b2e04e16bd7ea6c4f73695c5c637586f3fb66b47&
17:27 < bridge> <louis> but the big one is cool cuz then u can like https://cdn.discordapp.com/attachments/692544608823148588/1022754828050497579/unknown.png
17:28 < bridge> <scrumplex> I am using DDraceNetwork to narrow down a Mesa bug ðŸ‘€ https://gitlab.freedesktop.org/mesa/mesa/-/issues/7352#note_1568950
17:32 < bridge> <heinrich5991> I have bad news for you: https://github.com/NationalSecurityAgency/ghidra/pull/1889
17:33 < bridge> <Jupstar âœª> stackoverflow gives a shit in their surveys.. are they now considered unreliable?
17:33 < bridge> <Jupstar âœª> https://survey.stackoverflow.co/2022/#integrated-development-environment
17:33 < bridge> <Jupstar âœª> 
17:33 < bridge> <Jupstar âœª> some ppl could have not answered it bcs they dont use vim or vscode as IDE ðŸ˜‰
17:33 < bridge> <ryozuki> https://github.com/edg-l/rustyman
17:43 < bridge> <c0d3d3v> Ravie and I just revise part of the "hud.png"  and now just talking about merging it with extras.png and the new shields from game.png. for example like that:
17:43 < bridge> <c0d3d3v> 
17:43 < bridge> <c0d3d3v> Now the question, do we want to also add arrow.png and strong_weak.png to it, so we have all textures related to our game in one png?
17:43 < bridge> <c0d3d3v> https://cdn.discordapp.com/attachments/293493549758939136/996807225509163008/unknown.png?ex=670b44d2&is=6709f352&hm=2945687076b0e63e73275ed3794f4b3dfa1faf9b570e24df045d27230c5df712&
22:06 < bridge> <milkeeycat> ```rust
22:06 < bridge> <milkeeycat> fn add(lhs: usize, rhs: usize) -> usize {
22:06 < bridge> <milkeeycat>     return lhs + rhs;
22:06 < bridge> <milkeeycat> }
22:06 < bridge> <milkeeycat> fn sub(lhs: usize, rhs: usize) -> usize {
22:06 < bridge> <milkeeycat>     return lhs - rhs;
22:06 < bridge> <milkeeycat> }
22:06 < bridge> <milkeeycat> 
22:06 < bridge> <milkeeycat> fn main() -> u8 {
22:06 < bridge> <milkeeycat>     let ptrs: fn(usize, usize)->usize[2] = [sub, add];
22:06 < bridge> <milkeeycat> 
22:07 < bridge> <milkeeycat>     let value: usize;
22:07 < bridge> <milkeeycat>     // there're whoopsie daisies with other types than u8(segfault)
22:07 < bridge> <milkeeycat>     for let i: u8 = 0; i < 2; i = i + 1 {
22:07 < bridge> <milkeeycat>         value = ptrs[(i as usize)](i as usize, i as usize);
22:07 < bridge> <milkeeycat> 
22:07 < bridge> <milkeeycat>         printf("%d", value);
22:07 < bridge> <milkeeycat>     }
22:07 < bridge> <milkeeycat> 
22:07 < bridge> <milkeeycat>     return 0;
22:07 < bridge> <milkeeycat> }
22:07 < bridge> <milkeeycat> ```
22:07 < bridge> <milkeeycat> @learath2 I didn't decide anything regarding but I added function pointers :justatest:
22:10 < bridge> <milkeeycat> ```rust
22:10 < bridge> <milkeeycat> fn add(lhs: usize, rhs: usize) -> usize {
22:10 < bridge> <milkeeycat>     return lhs + rhs;
22:10 < bridge> <milkeeycat> }
22:10 < bridge> <milkeeycat> fn sub(lhs: usize, rhs: usize) -> usize {
22:10 < bridge> <milkeeycat>     return lhs - rhs;
22:10 < bridge> <milkeeycat> }
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat> fn main() -> u8 {
22:10 < bridge> <milkeeycat>     let ptrs: fn(usize, usize)->usize[2] = [sub, add];
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat>     let value: usize;
22:10 < bridge> <milkeeycat>     // there're whoopsie daisies with other types than u8(segfault)
22:10 < bridge> <milkeeycat>     for let i: u8 = 0; i < 2; i = i + 1 {
22:10 < bridge> <milkeeycat>         value = ptrs[(i as usize)](i as usize, i as usize);
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat>         printf("%d", value);
22:10 < bridge> <milkeeycat>     }
22:10 < bridge> <milkeeycat> 
22:10 < bridge> <milkeeycat>     return 0;
22:10 < bridge> <milkeeycat> }
22:10 < bridge> <milkeeycat> ```
22:10 < bridge> <milkeeycat> @learath2 I didn't decide anything regarding enums but I added function pointers :justatest:
22:15 < bridge> <pioooooo> Currently swap msg sent to dummy is not shown and I can't think of any solution without using strcmp under the current protocol. Imo swap msgs deserve a unique protocol, but I'm not familiar with ddnet protocols so...
22:16 < bridge> <pioooooo> I also hope for a better display of swap msgs, as well as whispers, to differentiate a msg is sent from/to player/dummy
