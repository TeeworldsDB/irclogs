01:45 < bridge> <totar> If you mean workshop mods they just get dropped into a folder and it's entirely up to the official application to manage the functionality of the mods.
01:46 < bridge> <totar> Some games just support re-textures or changing assets.
01:49 < bridge> <totar> Most games that have highly advanced mods on the steam workshop either have an extensive modding api, or they use C# and let the mods do whatever runtime patching they want.
01:57 < bridge> <jxsl13> time to ditch rust and c++ in favor of c#
02:01 < bridge> <learath2> OR, the mods can monkeypatch ddnet by compiling their code at runtime and injecting into memory
02:01 < bridge> <jxsl13> with a launcher, one could support multiple executables, given, they live in some specific folder
02:01 < bridge> <jxsl13> sounds reasonable
02:07 < bridge> <louis> whats that
02:15 < bridge> <louis> the sub tick aiming stuff?
02:17 < bridge> <totar> it functionally applies antiping to your tee based on the inputs you're currently holding
02:18 < bridge> <totar> idk if that makes any sense
02:28 < bridge> <01000111g> what do u mean exactly, can u elaborate? I thought it just adds some visuals, does it change how pred works completely?
02:28 < bridge> <louis> oh, is it for gores gameplay
02:38 < bridge> <Ewan> it was just explained 10 minutes before u replied (with the ping on :steamsuffering: )
02:39 < bridge> <totar> it's not really related to the gamemode at all but it's probably much more useful in gores? idk
02:39 < bridge> <totar> I couldn't tell you because I suck at ddrace
02:39 < bridge> <Ewan> works on ddnet too but the use of pretty much anything but static map tiles and player movement is buggy
02:39 < bridge> <louis> I remember smth abt antipi g applying whether youre frozen or not too
02:39 < bridge> <totar> that's a different feature but that one is almost entirely for gores
02:40 < bridge> <louis> related, itd be nice for mods to send their custom prediction or antiping
02:40 < bridge> <Ewan> yea there‚Äôs not really a model that works for that atm
02:40 < bridge> <totar> what does that mean
02:41 < bridge> <Ewan> server could theoretically send some kind of data to help the client predict its stuff
02:41 < bridge> <totar> ah
02:41 < bridge> <totar> ddpg works that way
02:41 < bridge> <totar> the server sends the entire game physics so everything is predicted
02:41 < bridge> <totar> it would be nearly impossible to do that in ddnet though
02:42 < bridge> <Ewan> It would just require major refactoring and would be incompatible with old clients and servers
02:42 < bridge> <Ewan> so yeah. nearly impossible üòÉ
02:42 < bridge> <louis> i will be switching to ddpg on release üôã
02:42 < bridge> <Ewan> I have bad news for u
02:43 < bridge> <totar> the issue is you need ddpg servers and every mod needs to be written based on ddpg
02:43 < bridge> <totar> there's no cross compatibility
02:43 < bridge> <totar> but maybe some mod authors will make cool mods that use super different physics
02:44 < bridge> <louis> its okay ill be good at rust by the time it releases
02:44 < bridge> <melo∆û> gerd√∂h already implemented insta :kek:
02:44 < bridge> <melo∆û> you have ~1 1/2 months
02:45 < bridge> <melo∆û> i'll be implementing zombies boys
02:45 < bridge> <louis> ill do bomb tag :poggers2:
03:10 < bridge> <melo∆û> I think that's reserved to furo: and bencie I'm afraid :feelsbadman:
03:12 < bridge> <louis> ok then im taking zombies so you can find something else
03:14 < bridge> <melo∆û> Ok I code battlefield
06:05 < bridge> <tsfreddie> https://cdn.discordapp.com/attachments/293493549758939136/1290887452554297418/e85b8a6fda51d647aeb4f02d310a05a2.jpg?ex=66fe1820&is=66fcc6a0&hm=543afb19bdd3cd9098e306f6e6511fc2236f1f0d30ecb5b1312de0c41765c892&
07:53 < bridge> <teero777> I am in a public space and was just enjoying some reading in dev chat :(
07:54 < bridge> <tsfreddie> :nouis:
08:08 < bridge> <milkeeycat> I didn't even need a separate rule for this, I just slapped this and it works xd:
08:08 < bridge> <milkeeycat> ```
08:08 < bridge> <milkeeycat> ((identifier) @variable.builtin
08:08 < bridge> <milkeeycat>     (#eq? @variable.builtin "this")
08:08 < bridge> <milkeeycat>     (#has-ancestor? @variable.builtin method_definition))
08:08 < bridge> <milkeeycat> ```
08:08 < bridge> <milkeeycat> I didn't even need a separate rule for this, I just slapped this and it works xd:
08:08 < bridge> <milkeeycat> ```scm
08:08 < bridge> <milkeeycat> ((identifier) @variable.builtin
08:08 < bridge> <milkeeycat>     (#eq? @variable.builtin "this")
08:08 < bridge> <milkeeycat>     (#has-ancestor? @variable.builtin method_definition))
08:08 < bridge> <milkeeycat> ```
09:24 < bridge> <Jupstar ‚ú™> I just spam you with my brainstorming about it. But it kinda removes the time until next tick
09:24 < bridge> <Jupstar ‚ú™> ## Fast prediction code (lower input lag) brainstorming
09:24 < bridge> <Jupstar ‚ú™> 
09:24 < bridge> <Jupstar ‚ú™> Biggest problem is a direction change (looks jittery and is FPS dependent).
09:24 < bridge> <Jupstar ‚ú™> One thing is clear. this gives _up to_ 20ms less input lag (visually).
09:24 < bridge> <Jupstar ‚ú™> ```
09:24 < bridge> <Jupstar ‚ú™> Tick        0 --------------- 1 Tick  
09:24 < bridge> <Jupstar ‚ú™>                  ^ input to move right at 0.25 intra tick
09:24 < bridge> <Jupstar ‚ú™> Tee-pos (0,0) --------------- (1,0) Predicted tee-pos 
09:24 < bridge> <Jupstar ‚ú™>                  <----------> in this range the tee has to do
09:24 < bridge> <Jupstar ‚ú™>                               the full movement from non-redicted
09:24 < bridge> <Jupstar ‚ú™>                               to predicted pos   
09:24 < bridge> <Jupstar ‚ú™> ```
09:24 < bridge> <Jupstar ‚ú™> 
09:24 < bridge> <Jupstar ‚ú™> holding move:
09:24 < bridge> <Jupstar ‚ú™> 
09:24 < bridge> <Jupstar ‚ú™> ```
09:24 < bridge> <Jupstar ‚ú™> Tick        1 --------------- 2 Tick  
09:24 < bridge> <Jupstar ‚ú™>                          ^ input to STOP moving at 0.75 intra tick
09:25 < bridge> <Jupstar ‚ú™> Tee-pos (1,0) --------------- (1,0) Predicted tee-pos 
09:25 < bridge> <Jupstar ‚ú™>                          ^ (1.75, 0) at this moement the tee is here visually
09:25 < bridge> <Jupstar ‚ú™>                           <-> in this range the tee has to do
09:25 < bridge> <Jupstar ‚ú™>                               the RESET the movement from non-redicted
09:25 < bridge> <Jupstar ‚ú™>                               to predicted pos
09:25 < bridge> <Jupstar ‚ú™>                               So literally reverting 0.75 moved units
09:25 < bridge> <Jupstar ‚ú™>                               Additionally it would need to keep a second prediction
09:25 < bridge> <Jupstar ‚ú™>                               world, to even have something to interpolate against.
09:25 < bridge> <Jupstar ‚ú™> ```
09:25 < bridge> <Jupstar ‚ú™> 
09:25 < bridge> <Jupstar ‚ú™> - Since this is kind of anti-input lag (similar to anti-ping) this should maybe be configurable
09:25 < bridge> <Jupstar ‚ú™> - How can we make the impact of the reset less?
09:25 < bridge> <Jupstar ‚ú™> - How to keep track of the second prediction world (or even more?)
09:40 < bridge> <totar> I've had a lot of people on 60hz say they prefer it
09:41 < bridge> <totar> idk if fps has any impact
09:41 < bridge> <totar> the real issue is that it makes jump timing way harder
09:42 < bridge> <totar> any action that sets your velocity instead of giving you acceleration feels worse
09:43 < bridge> <totar> > How to keep track of the second prediction world (or even more?)
09:43 < bridge> <totar> the client already saves the positions of every tee on every tick of prediction so you don't need multiple worlds for most things unless you care about non-tee objects
09:47 < bridge> <avolicious> The number of ppl losing their e-mail account is not very accurate as they can login with their username password on the website. But after most people registered and have their ingame login, they dont reach out to us for months until they leaked it & then the fun begins.
09:47 < bridge> <avolicious> 
09:47 < bridge> <avolicious> As we cant give out information & mods dont see e-mails at all, they have to escalate it to admins
09:47 < bridge> <Jupstar ‚ú™> ah, i think that part was about our idea to make it more smooth
09:48 < bridge> <Jupstar ‚ú™> it kinda would need multiple prediction worlds i think
09:48 < bridge> <Jupstar ‚ú™> to interpolate between the predicted worlds xd
09:48 < bridge> <totar> ah
09:48 < bridge> <Jupstar ‚ú™> But that part is defs the hardest
09:49 < bridge> <Jupstar ‚ú™> esp. for dd-pg bcs all mods would need to implement it
09:49 < bridge> <Jupstar ‚ú™> I wonder if it would look better anyway xd
09:50 < bridge> <Jupstar ‚ú™> >> I've had a lot of people on 60hz say they prefer it
09:50 < bridge> <Jupstar ‚ú™> idk if fps has any impact
09:50 < bridge> <Jupstar ‚ú™> 
09:50 < bridge> <Jupstar ‚ú™> Ah ok, well I'm not very used to 60hz. But for me it felt extra terrible üòÑ
09:50 < bridge> <heinrich5991> does regeneration of the ingame login invalidate the old token?
09:50 < bridge> <Jupstar ‚ú™> > I've had a lot of people on 60hz say they prefer it
09:50 < bridge> <Jupstar ‚ú™> > idk if fps has any impact
09:50 < bridge> <Jupstar ‚ú™> 
09:50 < bridge> <Jupstar ‚ú™> Ah ok, well I'm not very used to 60hz. But for me it felt extra terrible üòÑ
09:50 < bridge> <avolicious> Yes
09:51 < bridge> <learath2> This scheme doesn‚Äôt sound very fps dependent. Why is it?
09:51 < bridge> <Jupstar ‚ú™> At least my brain thinks the impact is negitble on 240hz
09:51 < bridge> <Jupstar ‚ú™> I think it's a brain thing
09:51 < bridge> <Jupstar ‚ú™> the frames come out faster so the brain has more info
09:52 < bridge> <Jupstar ‚ú™> On 60hz it felt like it jumped quite hard xd
09:52 < bridge> <heinrich5991> > they dont reach out to us for months until they leaked it & then the fun begins.
09:52 < bridge> <heinrich5991> @avolicious what's the fun there? going back and cleaning up the malicious logins?
09:52 < bridge> <totar> I was going to implement variable amount of fast input between 0-20ms so you can set it to 10ms and experience less jitter but the issue with this is that it requires the client to lerp between 3 world states during a single intratick period.
09:52 < bridge> <totar> 
09:52 < bridge> <totar> Basically like this
09:52 < bridge> <totar> 
09:52 < bridge> <totar> ```
09:52 < bridge> <totar> 0 -------------- 1 -------------- 2
09:52 < bridge> <totar>         ^ Intratick = 0 here
09:52 < bridge> <totar>                            ^ Intratick = 1 here
09:52 < bridge> <totar> ```
09:52 < bridge> <totar> but the client only saves 2 values at a time which makes it so you have to change a bunch of stuff
09:53 < bridge> <Jupstar ‚ú™> Yeah that is defs also a cool idea üòÑ
09:53 < bridge> <Jupstar ‚ú™> At least to see if that still feels smoother
09:54 < bridge> <totar> yeah but it probably doesn't feel as good
09:54 < bridge> <totar> idk if there is any perfect solution, I think there probably isn't because the game will always run on 50tps steps
09:55 < bridge> <Jupstar ‚ú™> yep
09:55 < bridge> <avolicious> They forget their e-mail they used, mostly creating new discord accounts, so its hard to verify if they are the real owner of this account
09:55 < bridge> <avolicious> This is the "fun" part
09:55 < bridge> <heinrich5991> ah
09:55 < bridge> <heinrich5991> so it does happen üò¶
09:55 < bridge> <learath2> There can be no perfect solution to prediction, it‚Äôs a prediction after all
09:55 < bridge> <heinrich5991> let's hope there's less of this with steam-bound accounts
09:56 < bridge> <learath2> Unless you invent time travel I guess
09:56 < bridge> <totar> well this is like a meta sub-tick prediction where you try to fake a higher tickrate
09:56 < bridge> <totar> you're predicting where the tee will be in 0.5 ticks from now
09:57 < bridge> <avolicious> I was also thinking of linking steam accounts too üòÑ
09:57 < bridge> <learath2> But it still increases the odds of a mispredict by predicting at all
09:57 < bridge> <totar> well if you don't predict there cannot be a mispredict
09:57 < bridge> <totar> so infinity% increase in odds
09:57 < bridge> <learath2> Exaclty, and thus less jitter
09:57 < bridge> <Jupstar ‚ú™> Tbf "normal" prediction almost always works for the local tee.
09:57 < bridge> <Jupstar ‚ú™> 
09:57 < bridge> <Jupstar ‚ú™> This one _always_ breaks it even for the local tee
09:58 < bridge> <Jupstar ‚ú™> fast input is like a bet
09:58 < bridge> <Jupstar ‚ú™> that u don't change the direction xD
10:00 < bridge> <totar> also you pay 20ms ping penalty if you have antiping on for the privilege to make this bet
10:00 < bridge> <learath2> If it always breaks you might be doing something wrong. Afaik, the client technically actually has all the information needed to pretend there is 0 ping and even do this subtick fakery perfectly. As long as it‚Äôs the local tee and there are no other tees in the way
10:00 < bridge> <Jupstar ‚ú™> this isnt anti ping
10:00 < bridge> <Jupstar ‚ú™> this is predicting the future
10:00 < bridge> <Jupstar ‚ú™> i also call it future prediction üò¨
10:01 < bridge> <Jupstar ‚ú™> it doesnt have enough info inside the sub tick
10:01 < bridge> <learath2> All predictions are by definition about the future, it‚Äôs just that you are using a different reference time
10:01 < bridge> <Jupstar ‚ú™> so it kinda has to hope the input doesnt change during the same sub tick
10:01 < bridge> <Jupstar ‚ú™> Yeah but, normally u talk about ticks
10:01 < bridge> <Jupstar ‚ú™> 
10:01 < bridge> <Jupstar ‚ú™> here u talk about subticks
10:02 < bridge> <Jupstar ‚ú™> in some sense, if u say 1 tick is 1 time unit. then this doesn't make sense
10:02 < bridge> <totar> regular prediction is just the client pretending to be the server, this is like trying to know what the next tick will be before the server or the client knows
10:04 < bridge> <avolicious> Ah, and we have people trying to iterate over login codes üòÑ
10:04 < bridge> <avolicious> Generating them randomly & trying to login
10:04 < bridge> <learath2> Why don‚Äôt you stay behind one subtick at all times? Then you will never get jitter from this and you will only be 1 subtick behind of ‚Äútruth‚Äù
10:04 < bridge> <Jupstar ‚ú™> lmao
10:04 < bridge> <totar> I thought the login codes are huge, why would anyone even attempt that
10:05 < bridge> <avolicious> ¬Ø\_(„ÉÑ)_/¬Ø
10:05 < bridge> <learath2> Kids ‚Ñ¢Ô∏è
10:05 < bridge> <avolicious> It gets detected anyways
10:05 < bridge> <avolicious> then they open a ticket & ask why they cant login
10:05 < bridge> <avolicious> Seen that a few times now
10:05 < bridge> <avolicious> ü§£
10:05 < bridge> <Jupstar ‚ú™> u'd need to be 1 tick behind. in other words, u get what ddnet is doing rn anyway üòÑ
10:05 < bridge> <Jupstar ‚ú™> well up to 1 tick
10:06 < bridge> <Jupstar ‚ú™> to be precise
10:06 < bridge> <totar> to be fair I think all games do it how ddnet does it atm, it's sort of the objectively correct way to do it
10:06 < bridge> <learath2> I don‚Äôt seem to have the right words to convey this. Worry not, I‚Äôll show you how when I make ddnet-asm
10:07 < bridge> <totar> idk what minecraft does tho
10:07 < bridge> <motkote> guys, who knows how to add such a thing to their server, or create their own???
10:07 < bridge> <motkote> https://cdn.discordapp.com/attachments/293493549758939136/1290948227805347851/image.png?ex=66fe50ba&is=66fcff3a&hm=2f0ee50884b11f0dc11cc4216f236cfa36591c79eacf77ebeb7c62a9f4788a9f&
10:07 < bridge> <totar> somehow it runs at 20tps and I don't think the client has any input lag or server desyncs
10:07 < bridge> <Jupstar ‚ú™> yeah, normally games simply do more ticks if u need better gameplay xd
10:07 < bridge> <learath2> A fair bit of games just let the client run their own simulation entirely and they trust the client for it mostly
10:08 < bridge> <Jupstar ‚ú™> true
10:08 < bridge> <avolicious> And in CS case the server and client can negotiate the tick-rate üòè
10:08 < bridge> <Jupstar ‚ú™> i think minecraft also trusts the client?
10:08 < bridge> <Jupstar ‚ú™> at least in past u could just fly xD
10:08 < bridge> <learath2> This would be my guess with all the rampant cheating
10:08 < bridge> <totar> it's not so simple
10:08 < bridge> <totar> the minecraft client and server have a complex relationship
10:08 < bridge> <totar> a highly janky one
10:08 < bridge> <Jupstar ‚ú™> time for minetee, the better minecraft
10:09 < bridge> <avolicious> https://wiki.vg/Main_Page
10:09 < bridge> <Jupstar ‚ú™> @avolicious is it a secret how your login tokens are generated?
10:09 < bridge> <Jupstar ‚ú™> like what algo
10:09 < bridge> <avolicious> Algo = os.random
10:09 < bridge> <Jupstar ‚ú™> i see so just random bytes, 32?
10:09 < bridge> <avolicious> Yep
10:10 < bridge> <avolicious> No need for complex computing
10:10 < bridge> <motkote> who knows???
10:10 < bridge> <Jupstar ‚ú™> yeah, that is defs unbreakable for any normal player üòÑ
10:10 < bridge> <totar> ok wtf
10:10 < bridge> <totar> minecraft has 50ms input delay??
10:10 < bridge> <totar> > The physics engine runs at 20 ticks per second, meaning the game's physics are updated every 50ms.
10:10 < bridge> <totar> > 
10:10 < bridge> <totar> > This includes the player‚Äôs position and speed, the environment, and entities.
10:10 < bridge> <totar> > 
10:10 < bridge> <totar> > In-game actions are performed at the end of each tick, regardless of the time or order in which they were called.
10:10 < bridge> <totar> > 
10:10 < bridge> <totar> > Due to the game working this way, inputs may take up to 50ms of delay between the button press and their activation.
10:10 < bridge> <Jupstar ‚ú™> i mean in 3d everything feels different anyway
10:11 < bridge> <totar> idk how I never noticed it
10:11 < bridge> <totar> I guess you get used to it
10:11 < bridge> <motkote> guys help please
10:11 < bridge> <Jupstar ‚ú™> also minecraft is kinda slow
10:11 < bridge> <totar> jumping is a fast action
10:11 < bridge> <Jupstar ‚ú™> if it would add osu gameplay u'd probs notice it easier xdd
10:11 < bridge> <avolicious> We detect bruteforce attacks & block the ip üòÑ So yeah, its pretty unbreakable
10:12 < bridge> <Jupstar ‚ú™> i guess even without it would be unbreakable, but yeah that makes it impossible
10:12 < bridge> <avolicious> https://github.com/PaperMC/Folia might be interesting tho
10:12 < bridge> <totar> I think some crypto wallets might use less bits than the kog login token
10:13 < bridge> <Jupstar ‚ú™> also kog servers need to actively report if the token was correct. that alone is a rate limit
10:13 < bridge> <totar> yes
10:13 < bridge> <avolicious> It works async, so you could theoretically spam login tokens
10:14 < bridge> <avolicious> As its just a chat message/command
10:14 < bridge> <avolicious> every chat message/command is an event
10:14 < bridge> <avolicious> and treated that way
10:14 < bridge> <Jupstar ‚ú™> a ed25519 is also just 32bytes long
10:14 < bridge> <Jupstar ‚ú™> and u often have the public key to it
10:14 < bridge> <matodor> 1) you need to come up with a name for the community
10:14 < bridge> <matodor> 2) draw a logo sized 128x64
10:14 < bridge> <matodor> 3) launch about 20 servers with a Linear map
10:14 < bridge> <matodor> 4) wait until there are 30-40 people online
10:14 < bridge> <matodor> 5) create a request to add a community via GitHub https://github.com/ddnet/ddnet/issues or Discord bot #‚úâ-create-a-ticket
10:15 < bridge> <totar> idk this is a lot of work to get a less stable version which doesn't support plugins and still only has 2x-3x total players
10:15 < bridge> <learath2> It‚Äôs probably unbreakable period. I don‚Äôt imagine any modern linux kernel shipping with subpar `/dev/urandom`
10:15 < bridge> <avolicious> Paper is fairly stable, Folia is just an addition
10:15 < bridge> <motkote> thank you, I'll try
10:15 < bridge> <totar> did you read the github?
10:16 < bridge> <totar> > Current broken API
10:16 < bridge> <totar> >     Most API that interacts with portals / respawning players / some player login API is broken.
10:16 < bridge> <totar> >     ALL scoreboard API is considered broken (this is global state that I've not figured out how to properly implement yet)
10:16 < bridge> <totar> >     World loading/unloading
10:16 < bridge> <totar> >     Entity#teleport. This will NEVER UNDER ANY CIRCUMSTANCE come back, use teleportAsync
10:16 < bridge> <totar> >     Could be more
10:16 < bridge> <learath2> Conclusive proof that tickrate isn‚Äôt that important. It‚Äôs all in the brains of impressionable young men
10:16 < bridge> <motkote> 20 servers? and how do people who have only 3 servers create?
10:16 < bridge> <matodor> 20 for example
10:17 < bridge> <totar> I think Folia is a fork of paper not an addon, it's rewrites the entire engine
10:17 < bridge> <motkote> okay
10:17 < bridge> <totar> it is cool tho
10:17 < bridge> <avolicious> Folia and Paper is from the same devs üòÑ
10:17 < bridge> <avolicious> But yeah, they are adding multithreads to it
10:18 < bridge> <avolicious> or atleast they try
10:18 < bridge> <avolicious> but all the minecraft server implementation differ a bit
10:18 < bridge> <avolicious> from the original implementation
10:19 < bridge> <learath2> Did they multithread minecraft?
10:19 < bridge> <totar> yes
10:19 < bridge> <totar> it's region based
10:20 < bridge> <learath2> That‚Äôs smart, I wonder how they handled the boundaries of the threads
10:20 < bridge> <avolicious> Hardware
10:20 < bridge> <avolicious> > What hardware will Folia run best on?
10:20 < bridge> <avolicious> > Ideally, at least 16 cores (not threads).
10:20 < bridge> <totar> I think it would be cool if there was a multi instance version and associated client mod so you could scale a single world to infinite players at the cost of boundaries
10:21 < bridge> <avolicious> Lets assume they have 16 cores and HT enabled üòÑ
10:21 < bridge> <avolicious> Thats an expensive server tho
10:21 < bridge> <learath2> I meant as in how they handled something crossing the boundary from one threads authoritative region to the other
10:21 < bridge> <totar> I think it's dynamic
10:22 < bridge> <totar> > For a server with many spread out players, Folia will create many spread out regions and tick them all in parallel on a configurable sized threadpool. Thus, Folia should scale well for servers like this.
10:22 < bridge> <Jupstar ‚ú™> contention incoming
10:23 < bridge> <totar> <https://docs.papermc.io/folia/reference/region-logic>
10:23 < bridge> <Jupstar ‚ú™> i wonder how fast it would be in a system programming language
10:23 < bridge> <Jupstar ‚ú™> java is always like twice as slow xd
10:23 < bridge> <totar> it appears very complicated
10:23 < bridge> <totar> it appears to be very complicated
10:24 < bridge> <learath2> Hm, this sounds very hard to do, I‚Äôll have to read it
10:24 < bridge> <totar> I agree and it looks like they tried very hard
10:24 < bridge> <avolicious> > Inter-region operations
10:24 < bridge> <avolicious> > Inter-region operations refer to operations that work with other regions that are not the current ticking region that are in a completely unknown state. These regions may be transient, may be ticking, or may not even exist.
10:25 < bridge> <learath2> Stuff like redstone crossing the boundary sounds impossible to handle properly
10:25 < bridge> <totar> they probably do not care
10:25 < bridge> <totar> paper does not even have vanilla redstone mechanics normally
10:33 < bridge> <yourparano1a> hi, what should I do if I was banned for a bot client, but I don't use it and no CFGs, please help
10:34 < bridge> <oxyzo.> were you using any custom client
10:34 < bridge> <yourparano1a> no
10:34 < bridge> <yourparano1a> client or stiam
10:34 < bridge> <yourparano1a> steam*
10:34 < bridge> <oxyzo.> for how long did you get banned
10:35 < bridge> <yourparano1a> 1 day , next time for a year , I don 't want to , it 's a Varna - type system
10:35 < bridge> <yourparano1a> \
10:35 < bridge> <yourparano1a> https://cdn.discordapp.com/attachments/293493549758939136/1290955341970018308/image.png?ex=66fe575a&is=66fd05da&hm=35b2baba7653cd5192e2016fbb1fe6f8b1a2acd940514c65c7fa32a8298df004&
10:35 < bridge> <oxyzo.> it should be a week next time if i remember correctly
10:36 < bridge> <Jupstar ‚ú™> if you are 100% certain u used steam version. #‚úâ-create-a-ticket -> ban appeal
10:36 < bridge> <Jupstar ‚ú™> 
10:36 < bridge> <Jupstar ‚ú™> But be prepared to be rejected
10:36 < bridge> <yourparano1a> okey
10:37 < bridge> <yourparano1a> thanks
10:39 < bridge> <learath2> https://www.reddit.com/r/yuzu/s/5XNp0ISC2i Nintendo going all out
10:40 < bridge> <Jupstar ‚ú™> Is this the past?
10:40 < bridge> <Jupstar ‚ú™> Or what is different this time
10:40 < bridge> <learath2> It's today. They took down another emulator, Ryujinx
10:41 < bridge> <Jupstar ‚ú™> Ah I was confused by the yuzu subreddit xD
10:41 < bridge> <learath2> Oh, yeah the subreddit is still there
11:02 < bridge> <ryozuki> morning fellas
11:06 < bridge> <ar1gin> ohayou mr ryozuki :owo:
11:14 < bridge> <reitw> fuck Nintendo lmao
12:40 < bridge> <motkote> who knows how to fix the fact that emotions cannot be spammed on my server?
12:42 < bridge> <Jupstar ‚ú™> https://ddnet.org/settingscommands/
12:42 < bridge> <oxyzo.> :f3:
12:42 < bridge> <motkote> thx
12:42 < bridge> <Jupstar ‚ú™> sv_emoticon_ms_delay
12:42 < bridge> <Jupstar ‚ú™> is probably what u want
12:59 < bridge> <milkeeycat> @learath2 what do you think about variable shadowing?
13:00 < bridge> <learath2> Idk, no strong opinions on it
13:01 < bridge> <heinrich5991> depends on the language, I'd guess
13:03 < bridge> <milkeeycat> I like it in rust so Ill yoink it to my language xd
13:41 < bridge> <ryozuki> https://github.blog/changelog/2024-10-01-evolving-github-issues-public-preview/
16:22 < bridge> <melo∆û> @learath2 ? :(
16:49 < bridge> <learath2> LOL, I guess BagleR got bored of waiting for me to add people
16:49 < bridge> <learath2> Ok ok, I'll do it now
16:50 < bridge> <learath2> It's your weird name you know. I started adding people, then I couldn't find your player profile link then I stopped
17:03 < bridge> <zhn> xd
17:03 < bridge> <zhn> @heinrich5991 sorry for ping, just for clarification, did you test 0.5 spec .json and its outcome from generate.py in libtw2?
17:04 < bridge> <zhn> seems it misses `NETMSG_SERVERINFO`
17:05 < bridge> <zhn> ah seems it's hardcoded, there's nothing in spec xd
17:07 < bridge> <Jupstar ‚ú™> OMFGGGG CHILLER
17:07 < bridge> <Jupstar ‚ú™> YOU DID NOT XDDDDDD
17:09 < bridge> <ryozuki> > ‚ÄúSystems program building is an entropy-decreasing process, hence inherently metastable. Program maintenance is an entropy-increasing process, and even its most skillful execution only delays the subsidence of the system into unfixable obsolescence.‚Äù
17:09 < bridge> <ryozuki> > ‚Äï Frederick P. Brooks Jr., The Mythical Man-Month: Essays on Software
17:09 < bridge> <ryozuki> what u think
17:10 < bridge> <Jupstar ‚ú™> Better dialog that anything in frieren
17:10 < bridge> <ryozuki> i wanna read this book https://www.amazon.es/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959
17:10 < bridge> <Jupstar ‚ú™> Better dialog than anything in frieren
17:10 < bridge> <ryozuki> its from there
17:10 < bridge> <Jupstar ‚ú™> What holds you back?
17:11 < bridge> <ryozuki> money
17:11 < bridge> <ryozuki> and that
17:11 < bridge> <ryozuki> i barely read books i buy
17:11 < bridge> <ryozuki> XD
17:11 < bridge> <ryozuki> ill ask my company to buy it
17:11 < bridge> <ryozuki> they bought me the x86 asm book
17:11 < bridge> <Jupstar ‚ú™> I never read a book from start to finish
17:11 < bridge> <Jupstar ‚ú™> So I can relate
17:12 < bridge> <Jupstar ‚ú™> That is also why I suck so hard at expressing myself
17:12 < bridge> <Jupstar ‚ú™> üòè
17:14 < bridge> <ryozuki> xd
17:14 < bridge> <zhn> wrong ‚ùó
17:14 < bridge> <ryozuki> @jupeyy_keks i like this quote more
17:14 < bridge> <ryozuki> >     The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.... Yet the program construct, unlike the poet's words, is real in the sense that it moves and works, producing visible outputs separate from the co
17:14 < bridge> <ryozuki> > 
17:14 < bridge> <ryozuki> >     ‚ÄîFred Brooks, The Mythical Man-Month
17:15 < bridge> <ryozuki> programmers are artists that build things that can make stuff that also build things
17:15 < bridge> <ryozuki> a artist just makes a painting and thats it
17:15 < bridge> <Jupstar ‚ú™> well programming is like playing god
17:15 < bridge> <ryozuki> yes
17:15 < bridge> <Jupstar ‚ú™> your own physics
17:15 < bridge> <ryozuki> we gods
17:15 < bridge> <ryozuki> and if u use rust
17:15 < bridge> <ryozuki> ur godlier
17:15 < bridge> <Jupstar ‚ú™> your own what do i know
17:15 < bridge> <ryozuki> kek
17:15 < bridge> <ryozuki> ur a safer god
17:15 < bridge> <ryozuki> :gigachad: :poggers2:
17:15 < bridge> <Jupstar ‚ú™> rust is the language of gods
17:16 < bridge> <ryozuki> > 
17:16 < bridge> <ryozuki> > ‚ÄúThe general tendency is to over-design the second system, using all the ideas and frills that were cautiously sidetracked on the first one.‚Äù
17:16 < bridge> <ryozuki> so true
17:16 < bridge> <ryozuki> is dd-pg over designed?
17:17 < bridge> <Jupstar ‚ú™> In some aspects probably it is already
17:17 < bridge> <ryozuki> > 
17:17 < bridge> <ryozuki> > ‚ÄúBy documenting a design, the designer exposes himself to the criticisms of everyone, and he must be able to defend everything he writes. If the organizational structure is threatening in any way, nothing is going to be documented until it is completely defensible.‚Äù
17:17 < bridge> <ryozuki> this guy got some nice quotes
17:18 < bridge> <Jupstar ‚ú™> One thing I like about many rust things is, that you understand the intend without the docs
17:18 < bridge> <Jupstar ‚ú™> I think this is generally also better
17:18 < bridge> <zhn> gimme generics
17:18 < bridge> <Jupstar ‚ú™> But everytime that is not the case, it sucks even more
17:18 < bridge> <zhn> ill make any code unreadable
17:19 < bridge> <Jupstar ‚ú™> But the way rust does generics is abstracted in a sense, that you most likely need traits too
17:19 < bridge> <Jupstar ‚ú™> But I understand what you mean
17:19 < bridge> <zhn> rust generics are not that abstracted tbh
17:19 < bridge> <ryozuki> generics and traits are a way to express logic that u cant do wrong
17:19 < bridge> <zhn> its kinda painless to work with cpp templates
17:20 < bridge> <ryozuki> what doesthat mean
17:20 < bridge> <ryozuki> rust is more strongly typed than cpp
17:20 < bridge> <learath2> Don't make me crime you
17:20 < bridge> <ryozuki> also it has lot of nice patterns
17:20 < bridge> <ryozuki> like new types
17:20 < bridge> <zhn> please give me some notes on how to make good abstracted proxy trait
17:20 < bridge> <ryozuki> or type state pattern
17:20 < bridge> <ryozuki> https://cliffle.com/blog/rust-typestate/
17:20 < bridge> <ryozuki> https://doc.rust-lang.org/rust-by-example/generics/new_types.html
17:21 < bridge> <learath2> Clearly false, the bible is in Latin
17:21 < bridge> <Jupstar ‚ú™> Sorry my heart. I love frieren from second 0 to second 33600
17:21 < bridge> <ryozuki> define abstracted proxy trait
17:22 < bridge> <zhn> im trying to implement multiprotocol using libtw2 and im struggling to come up with something good to abstract protocol away
17:22 < bridge> <ryozuki> its true that in rust some patterns are better than others u might use in a more oop oriented lang
17:22 < bridge> <ryozuki> u know the best way? just use a enum
17:22 < bridge> <zhn> currently its just small enum with underlying structs that implement same trait
17:23 < bridge> <ryozuki> @gerdoe maybe this helps u, https://crates.io/crates/enum_dispatch
17:23 < bridge> <zhn> lemme check, thank you
17:24 < bridge> <zhn> ah its literally what im doing manually
17:24 < bridge> <zhn> big brain crate
17:24 < bridge> <ryozuki> its like dyn dispatch with static dispatch perfomance
17:24 < bridge> <ryozuki> 10x speed
17:25 < bridge> <ryozuki> ```
17:25 < bridge> <ryozuki> test benches::boxdyn_homogeneous_vec       ... bench:   5,900,191 ns/iter (+/- 95,169)
17:25 < bridge> <ryozuki> test benches::refdyn_homogeneous_vec       ... bench:   5,658,461 ns/iter (+/- 137,128)
17:25 < bridge> <ryozuki> test benches::enumdispatch_homogeneous_vec ... bench:     479,630 ns/iter (+/- 3,531)
17:25 < bridge> <ryozuki> ```
17:26 < bridge> <learath2> I wonder why Rust fails to "devirtualize" these calls
17:26 < bridge> <learath2> or LLVM I guess, one or the other is at fault there
17:27 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1291058896445767702/image.png?ex=66feb7cb&is=66fd664b&hm=373da91e9300cd170131f04331ec86bce9b2acc2e63b5fe8ee086af8004b1661&
17:27 < bridge> <ryozuki> maybe its because it doesnt do exactly what c++ does
17:27 < bridge> <ryozuki> and clang is thought more for c++ sadly
17:27 < bridge> <ryozuki> idk
17:27 < bridge> <ryozuki> llvm*
17:27 < bridge> <learath2> Or maybe I'm missing something, idk, it has happened before
17:28 < bridge> <ryozuki> > 
17:28 < bridge> <ryozuki> > 
17:28 < bridge> <ryozuki> > "I was surprised to see that the data members of the object had an additional layer of indirection."
17:28 < bridge> <ryozuki> > 
17:28 < bridge> <ryozuki> > If you think about how dynamic dispatch is often used ‚Äì structs/classes behind a pointer ‚Äì you'll notice that C++ has in fact more layers of indirection. Or more like, in C++ you do sequential dereference, whereas Rust allows for parallel dereference. In Rust you have two pointers in the local trait object, and you can dereference them right away. In C++, you'll have to dereference the pointer that points to the data, and only after that data
17:28 < bridge> <ryozuki> itneresting
17:28 < bridge> <ryozuki> > 
17:29 < bridge> <ryozuki> > 
17:29 < bridge> <ryozuki> > People often miss this incredibly important nuance. The reason why it matters so much is that CPUs tend to be pretty good at predicting a pointer dereference (and thus prefetching the data before it's needed) when they see it coming up, but they can't predict a two-layer deref nowhere near as well. So the way Rust does it is great for perf.
17:29 < bridge> <ryozuki> > 
17:29 < bridge> <ryozuki> > It's another one of those fundamental design decisions that make Rust more amenable to faster code execution than C or C++ (another crowd favorite being no pointer aliasing).
17:29 < bridge> <ryozuki> @learath2 according to comments even dynamic dispatch rust should be faster than cpp
17:30 < bridge> <learath2> It sounds sane to me, but I've lived long enough to know that this sort of architectural detail needs to be benchmarked on many different cpus to be certain about
17:36 < bridge> <zhn> i was wrong and used github search again. this shit gave me results from 0.7 master and no from 0.5 tag, im sorry again xd
17:36 < bridge> <zhn> not*
18:41 < bridge> <melo∆û> OMG CHAT IS THIS REAL????
18:41 < bridge> <oxyzo.> its fake watermelon
18:42 < bridge> <melo∆û> @rootjie added to europe :kekw:
18:42 < bridge> <melo∆û> south african european gigachad
19:01 < bridge> <hades019848> guys can 1 of u make tut how to change mi skin or hammer im new
19:41 < bridge> <murpi> @learath2 Ryu is SA üòÑ
19:50 < bridge> <kollpotato> hi developas
19:50 < bridge> <kollpotato> love u
19:57 < bridge> <learath2> You can fix it if you'd like. I was confused about some people as Ryu's ranks are all over the place serverwise
19:59 < bridge> <bumm.> https://tenor.com/view/mr-worldwide-gif-26368506
20:06 < bridge> <01000111g> he is playing more on eu, keep it
20:07 < bridge> <zhn> finally!
20:07 < bridge> <zhn> https://cdn.discordapp.com/attachments/293493549758939136/1291099220123717673/image.png?ex=66fedd59&is=66fd8bd9&hm=418e6e0e4a623f3528e4c65530defa8d4379992d9b6ec171df27ecedfb1952f1&
20:07 < bridge> <kollpotato> whats this
20:07 < bridge> <kollpotato> bold font?
20:08 < bridge> <zhn> thank you 5991 for providing such powerful tools, you can literally generate same thing for any other language i believe
20:08 < bridge> <zhn> no
20:08 < bridge> <zhn> 0.5-0.6 bridge
20:08 < bridge> <zhn> quite simple atm
20:08 < bridge> <kollpotato> i dont get it but seems epic
20:09 < bridge> <kollpotato> keep going dont give up
20:09 < bridge> <zhn> https://teeworlds.com/?page=downloads&id=5063
20:11 < bridge> <rootjie> i identify as south african european american korean
20:11 < bridge> <learath2> I'll add a section for you
20:11 < bridge> <rootjie> :poggers2:
20:24 < bridge> <milkeeycat> why does `memset` segfaults :pepeW:
20:24 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1291103625057271949/image.png?ex=66fee173&is=66fd8ff3&hm=9053d3d4c075b52ef1a2c4524ca2c700d158d022c72ae221b42ce8930c3bd13f&
20:30 < bridge> <Jupstar ‚ú™> https://tenor.com/view/darthvader-nooooo-funny-starwars-no-gif-4920019
20:36 < bridge> <learath2> You are memsetting memory outside of your mapped memory
20:37 < bridge> <milkeeycat> sounds not good:\
20:37 < bridge> <learath2> Since you don't have any libc debug symbols, these things are rather annoying to debug. I would highly suggest linking to a debug libc when working with things this fundamental
20:38 < bridge> <learath2> Or, you know the signature of memset, and you know the amd64 calling convention, you can set a breakpoint before the call and look at what the register contains
20:39 < bridge> <learath2> Either rdi is directly outside your mapped regions, or rdx is too big
20:40 < bridge> <milkeeycat> ohh, i forgot that i commented out `rdx`
20:40 < bridge> <milkeeycat> but it's used as 3rd argument register :pepeW:
20:41 < bridge> <learath2> Isn't the signature of memset `void *memset(void *dst, int/unsigned/whatever value, size_t len)`?
20:41 < bridge> <milkeeycat> yea
20:41 < bridge> <learath2> rdx is len, if it's too large you'll write outside your memory allocation
20:41 < bridge> <learath2> Then the cpu will do a page fault moment
20:42 < bridge> <learath2> Then the kernel will bonk you
20:42 < bridge> <milkeeycat> and i commented out 3rd argument registers because it's not cool
20:42 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1291108006511116320/image.png?ex=66fee588&is=66fd9408&hm=e028d8a01a5a1424e010e8de21d586e761a1904a274de535ab27587c3de37aa3&
20:42 < bridge> <learath2> LOL
20:42 < bridge> <milkeeycat> i guess it's time to handle it then üò¨
20:43 < bridge> <learath2> Where were you putting your 3rd argument?
20:43 < bridge> <learath2> I did not know you broke ABI this early on
20:43 < bridge> <milkeeycat> nono, all gud
20:43 < bridge> <milkeeycat> you can see they are ordered from end in argument order
20:44 < bridge> <milkeeycat> only `rdx` is commented xd
20:44 < bridge> <learath2> Yeah so you were putting your 3rd argument into rcx, breaking abi, no? üòÑ
20:45 < bridge> <milkeeycat> i commented it and everything's fine
20:45 < bridge> <learath2> I guess it's fine as long as you never call C ever
20:45 < bridge> <milkeeycat> i uncommented it and everything's fine
20:46 < bridge> <milkeeycat> nah, i just have to fix the fun stuff with multiplication/division
20:47 < bridge> <learath2> I guess it'll be extremely annoying to fix something like `add(10/5, 10/5, 3/5)`
20:51 < bridge> <milkeeycat> im so happy that at least i can pack integers xdd
20:51 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1291110300824764526/image.png?ex=66fee7ab&is=66fd962b&hm=a42c16c353e0d491f69f8caed18ce2af803f6e067ff92b64536d191702cd5efe&
21:09 < bridge> <learath2> Wooooo
21:09 < bridge> <milkeeycat> that's 105 lines of my own programming language ü•π
21:10 < bridge> <milkeeycat> and a few C functions :santatrollet:
21:10 < bridge> <learath2> You probably should have done `AddRaw` first, so you can use that for `AddInt`
21:10 < bridge> <learath2> But it would be a quick win if you do `AddRaw` now, it's trivial
21:11 < bridge> <milkeeycat> i added so much stuff because of int packing
21:11 < bridge> <milkeeycat> `>>` `<<` `~`
21:11 < bridge> <learath2> Though I guess it involves a mem copy call or a `REP MOVSB` which idk if you can generate yet
21:11 < bridge> <milkeeycat> idk wat's `REP MOVSB`
21:12 < bridge> <learath2> `REP MOVSB` is a very rare instance of an instruction that works between two memory locations
21:12 < bridge> <milkeeycat> i can just call `memcpy`
21:12 < bridge> <learath2> It moves memory to memory, 1 byte at a time, ECX times
21:13 < bridge> <ryozuki> rep is more optimized
21:13 < bridge> <ryozuki> memcpy probs uses that tho
21:13 < bridge> <learath2> It's basically a naive memcpy loop implemented in microcode
21:13 < bridge> <learath2> oooh, this is a discussion of EXTREMELY hot debate
21:13 < bridge> <ryozuki> well i think it depends a lot on the cpu and size of the alloc
21:13 < bridge> <learath2> On modern architectures, since iirc 2012, it's better
21:13 < bridge> <ryozuki> the implementation takes into acocount this
21:14 < bridge> <learath2> As far as I'm aware, most architectures still share the vectorized memcpy implementation in glibc, since it performs well in many arches
21:14 < bridge> <ryozuki> i need to find out how one can do portable simd without overhead
21:14 < bridge> <ryozuki> like i know ppl do it i dont know yet how it works
21:15 < bridge> <ryozuki> for example memcpy is optimized on my platform to use avx512
21:15 < bridge> <ryozuki> but how do they do it portably
21:15 < bridge> <ryozuki> and it doesnt incur a branch?
21:15 < bridge> <learath2> FreeBSD uses rep movsq and rep movsb
21:16 < bridge> <learath2> You chunk, do 512 at a time until you have less, then use some other routine to clean up. It does incur a branch that is usually taken so well predicted
21:17 < bridge> <learath2> You first copy byte by byte until the dst is aligned, then you copy word by word until you can't anymore, then finish up copying byte by byte
21:19 < bridge> <learath2> If you are letting LLVM go at it, it's better if you just emit the naive byte copy loop and let LLVM optimize it per platform, as I said, sometimes rep movsb is better in some platforms
21:20 < bridge> <ryozuki> yeah llvm has a intrinsic for all these ops
21:21 < bridge> <ryozuki> it even has memcpy.inline
21:21 < bridge> <ryozuki> https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic
21:21 < bridge> <ryozuki> > The ‚Äòllvm.memcpy.inline.*‚Äô intrinsics copy a block of memory from the source location to the destination location and guarantees that no external functions are called.
21:21 < bridge> <ryozuki> > 
21:21 < bridge> <ryozuki> > Note that, unlike the standard libc function, the llvm.memcpy.inline.* intrinsics do not return a value, takes extra isvolatile arguments and the pointers can be in specified address spaces.
21:21 < bridge> <ryozuki> ```
21:21 < bridge> <ryozuki> The ‚Äòllvm.memcpy.inline.*‚Äô intrinsics copy a block of memory from the source location to the destination location and guarantees that no external functions are called.
21:21 < bridge> <ryozuki> Ôªø
21:22 < bridge> <ryozuki> Note that, unlike the standard libc function, the llvm.memcpy.inline.* intrinsics do not return a value, takes extra isvolatile arguments and the pointers can be in specified address spaces.
21:22 < bridge> <ryozuki> ```
21:25 < bridge> <milkeeycat> it compile first try and didn't even segfault :poggers2:
21:25 < bridge> <milkeeycat> it compiled first try and didn't even segfault :poggers2:
21:25 < bridge> <learath2> woooo
21:27 < bridge> <milkeeycat> now it's time to find out why it allocates 2x memory than it needs to :feelsbadman:
21:53 < bridge> <ryozuki> u using malloc?
21:53 < bridge> <ryozuki> with malloc u can allocate like 4 bytes but maybe if u address the next bytes it wont segfault
21:53 < bridge> <ryozuki> but its not smth u should rely xd
21:53 < bridge> <ryozuki> but maybe thats what happens?
21:54 < bridge> <milkeeycat> no, it allocates a lot of memory on stack :p
