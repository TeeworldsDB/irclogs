00:00 < bridge> <Mr.Gh0s7> in contrast to rust which already has it and you just use it
00:00 < bridge> <Mr.Gh0s7> programming vs coding
00:01 < bridge> <ryozuki> ah
00:01 < bridge> <ryozuki> i disagree
00:01 < bridge> <Mr.Gh0s7> plz disagree in greater detail :)
00:02 < bridge> <ryozuki> ```c
00:02 < bridge> <ryozuki> // Compare function for qsort
00:02 < bridge> <ryozuki> int cmpfunc(const void* a, const void* b)
00:02 < bridge> <ryozuki> {
00:02 < bridge> <ryozuki>     return (*(int*)a - *(int*)b);
00:02 < bridge> <ryozuki> }
00:02 < bridge> <ryozuki>  
00:02 < bridge> <ryozuki> // Function to return K'th smallest
00:02 < bridge> <ryozuki> // element in a given array
00:02 < bridge> <ryozuki> int kthSmallest(int arr[], int N, int K)
00:02 < bridge> <ryozuki> {
00:02 < bridge> <ryozuki>     // Sort the given array
00:02 < bridge> <ryozuki>     qsort(arr, N, sizeof(int), cmpfunc);
00:02 < bridge> <ryozuki>  
00:02 < bridge> <ryozuki>     // Return k'th element in the sorted array
00:02 < bridge> <ryozuki>     return arr[K - 1];
00:02 < bridge> <ryozuki> }
00:02 < bridge> <ryozuki> ```
00:02 < bridge> <ryozuki> see
00:02 < bridge> <ryozuki> is this programming
00:02 < bridge> <ryozuki> a quick google and copy
00:02 < bridge> <ryozuki> its no different
00:02 < bridge> <ryozuki> u just complain about having more functions available in std
00:02 < bridge> <ryozuki> but u can do the same with C
00:02 < bridge> <ryozuki> its why i find this argument pointless
00:04 < bridge> <ryozuki> but its because u focus "programming" or "engineeriing" to simple algorithm exercises
00:04 < bridge> <ryozuki> engineering is how you architect applications in whole
00:04 < bridge> <ryozuki> etc
00:04 < bridge> <Mr.Gh0s7> was this (that `k_smallest` is using) <https://en.wikipedia.org/wiki/Sorting_network> true btw?
00:04 < bridge> <ryozuki> no
00:04 < bridge> <ryozuki> well
00:04 < bridge> <ryozuki> idk
00:04 < bridge> <ryozuki> > Note: This is functionally-equivalent to self.sorted().take(k) but much more efficient.
00:04 < bridge> <Mr.Gh0s7> xD
00:04 < bridge> <ryozuki> its just that
00:04 < bridge> <ryozuki> sort and take the k element
00:05 < bridge> <ryozuki> doesnt sound related
00:05 < bridge> <Mr.Gh0s7> hmm
00:05 < bridge> <ryozuki> [4,3,6,1] -> k = 3 -> [1,3,4]
00:06 < bridge> <Mr.Gh0s7> I mean how the sorting works
00:06 < bridge> <Mr.Gh0s7> the algorithm
00:07 < bridge> <ryozuki> ```rust
00:07 < bridge> <ryozuki> pub(crate) fn k_smallest<T: Ord, I: Iterator<Item = T>>(mut iter: I, k: usize) -> BinaryHeap<T> {
00:07 < bridge> <ryozuki>     if k == 0 {
00:07 < bridge> <ryozuki>         return BinaryHeap::new();
00:07 < bridge> <ryozuki>     }
00:07 < bridge> <ryozuki> 
00:07 < bridge> <ryozuki>     let mut heap = iter.by_ref().take(k).collect::<BinaryHeap<_>>();
00:07 < bridge> <ryozuki> 
00:07 < bridge> <ryozuki>     iter.for_each(|i| {
00:07 < bridge> <ryozuki>         debug_assert_eq!(heap.len(), k);
00:07 < bridge> <ryozuki>         // Equivalent to heap.push(min(i, heap.pop())) but more efficient.
00:07 < bridge> <ryozuki>         // This should be done with a single `.peek_mut().unwrap()` but
00:07 < bridge> <ryozuki>         //  `PeekMut` sifts-down unconditionally on Rust 1.46.0 and prior.
00:07 < bridge> <ryozuki>         if *heap.peek().unwrap() > i {
00:07 < bridge> <ryozuki>             *heap.peek_mut().unwrap() = i;
00:07 < bridge> <ryozuki>         }
00:07 < bridge> <ryozuki>     });
00:07 < bridge> <ryozuki> 
00:07 < bridge> <ryozuki>     heap
00:07 < bridge> <ryozuki> }
00:07 < bridge> <ryozuki> ```
00:07 < bridge> <ryozuki> this is itertools version
00:07 < bridge> <ryozuki> idk if its same as std
00:07 < bridge> <ryozuki> ah std returns a iterator
00:07 < bridge> <ryozuki> not a binary heap
00:08 < bridge> <Mr.Gh0s7> btw how did you find it? (asking bcs I was also looking for `crate::k_smallest::k_smallest(self, k)`)
00:08 < bridge> <ryozuki> ah wait
00:08 < bridge> <ryozuki> u linked to itertools
00:08 < bridge> <ryozuki> u are using a library in the first place!
00:08 < bridge> <Mr.Gh0s7> ikr!
00:08 < bridge> <Mr.Gh0s7> I am not against using libs
00:08 < bridge> <ryozuki> so ur comparision is already completly wrong
00:09 < bridge> <ryozuki> u also have  libs in C
00:09 < bridge> <ryozuki> for common algos
00:09 < bridge> <ryozuki> biased
00:09 < bridge> <Mr.Gh0s7> xD
00:09 < bridge> <ryozuki> https://github.com/rust-itertools/itertools/blob/c116c200f97b39d521285e93e06f00ce9093bf40/src/k_smallest.rs#L4
00:10 < bridge> <ryozuki> i go sleep
00:10 < bridge> <ryozuki> gn
00:10 < bridge> <Mr.Gh0s7> gn and ty
00:18 < bridge> <heinrich5991> the ABI requires you to AFAIK
00:20 < bridge> <heinrich5991> IMO it's nice that you can use good algorithms without implementing everything yourselves
00:20 < bridge> <heinrich5991> even C has qsort 😉
00:21 < bridge> <Mr.Gh0s7> yeah but I went researching about sorting an array of fixed length and I found about this <https://en.wikipedia.org/wiki/Sorting_network>
00:34 < bridge> <learath2> I did some leetcode today, I'm soooo out of practice 😦
00:35 < bridge> <Mr.Gh0s7> :O leetcode sounds fun
00:36 < bridge> <Mr.Gh0s7> btw Learath have you heard about this before?
00:38 < bridge> <heinrich5991> I've heard about it before, however I'm not sure how relevant they are in practice
00:47 < bridge> <chillerdragon> Wot you doing?
00:47 < bridge> <chillerdragon> What even are you scanning?
00:54 < bridge> <Mr.Gh0s7> hmm it appears that `qsort` uses `quicksort` which in worst-case performance is `O(n^2)` while `Bitonic sort` worst-case is `O(log^2(n))`.
00:57 < bridge> <Mr.Gh0s7> xD I completely missed these two last msgs from chiller I read `BOT` and thought it was github :kek:
01:02 < bridge> <chillerdragon> :c
01:17 < bridge> <heinrich5991> bitonic sort cannot be implemented on (current) CPUs though
01:17 < bridge> <heinrich5991> so it's not really useful for C ^^
01:17 < bridge> <Mr.Gh0s7> :O true
01:27 < bridge> <learath2> not always
01:30 < bridge> <learath2> glibc qsort will try mergesort first, musl uses heapsort, msvc uses quicksort
01:31 < bridge> <Mr.Gh0s7> ah ty I was looking for this info 😉
01:31 < bridge> <learath2> glibc also might be falling back to insertion sort when it gets small enough, though I don't remember
01:32 < bridge> <Mr.Gh0s7> ic, well then this is nullified xD
01:32 < bridge> <learath2> https://elixir.bootlin.com/glibc/latest/source/stdlib/qsort.c yeah if it resorts to quicksort, it'll only partially quicksort and finish it off with insertion sort
01:33 < bridge> <learath2> Only in context of hardware
01:33 < bridge> <Mr.Gh0s7> ok ty :)
01:36 < bridge> <learath2> Funnily enough as far as the standard is concerned qsort doesn't even have any requirements, it could be quantum bogo sort
01:39 < bridge> <Mr.Gh0s7> I guess that this makes standard-compliance practically easier than having to prove performance requirements for compliance -- zogtib
01:41 < bridge> <learath2> Sometimes requirements can become an issue, like the requirements on `unordered_map` in C++ permanently crippling it. So maybe the C approach of leaving it up to the implementers was the better choice
01:51 < bridge> <zogtib> I guess that performace behaviour is something important but it can make standard-compliance maybe harder than necessary because programmers don't care only for things required by the standards anyways.
01:52 < bridge> <zogtib> *because programmers depend on implementations also for things the standards doesn't include etc
01:57 < bridge> <zogtib> Thus, including things like that in standards would make doings things correctly harder because of the compliance overhead, even if those are practically necessary in implementations anyways. (I think this is want I mean)
01:57 < bridge> <zogtib> Thus, including things like that in standards would make doings things correctly harder because of the compliance overhead, even if those are practically necessary in implementations anyways. (I think this is what I mean)
02:11 < bridge> <Ewan> what's this
02:46 < bridge> <Mr.Gh0s7> I just found out that desmos has `tone()` funcion 😮
08:31 < bridge> <Jupstar ✪> The server automatically does that bcs of spoofed atks
08:33 < bridge> <Jupstar ✪> This. You can reinvent the wheel million times. But for stuff that doesn't exist anyway you are forced to engineer, no way around it
08:46 < bridge> <ryozuki> morning :poggers2:
08:47 < bridge> <Jupstar ✪> Good morning
08:53 < bridge> <Mr.Gh0s7> gm :)
08:54 < bridge> <Mr.Gh0s7> xD it's been 6 hours since this
09:37 < bridge> <chillerdragon> Still don’t get it. Is someone spoofing a ip and pinging you with master traffic which your server then responds to? The reflection attack? What’s the target of the attack? Did your Hoster Complain?
09:49 < bridge> <Jupstar ✪> Well that's the question. If the hoster also complains for master servers, then rip
09:50 < bridge> <Jupstar ✪> Let's wait until the attacker reads this chat and tries out😬
10:20 < bridge> <ryozuki> lot of places say the abi in linux is parameters in `rdi, rsi, rdx, rcx, r8, and r9.` but i found for syscalls rcx is replaced by r10
10:21 < bridge> <ryozuki> why are all cheat sheets using at&t omg
10:29 < bridge> <ryozuki> > Functions preserve the registers rbx, rsp, rbp, r12, r13, r14, and r15; while rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11 are scratch registers. The return value is stored in the rax register, or if it is a 128-bit value, then the higher 64-bits go in rdx. Optionally, functions push rbp such that the caller-return-rip is 8 bytes above it, and set rbp to the address of the saved rbp. This allows iterating through the existing stack frames. This can 
10:29 < bridge> <ryozuki> @heinrich5991 this is from the osdev wiki
10:45 < bridge> <Ewan> gn
12:55 < ws-client> <ChillerDragon> @Jupstar ✪ do you think it is a targeted attack to you? Or are all servers abused for one bundled reflection attack?
13:00 < bridge> <Jupstar ✪> The target is teeworlds ofc
13:00 < bridge> <Jupstar ✪> Not me
13:01 < bridge> <Jupstar ✪> If it would be me personally. I'd demand a wild Western like fight to settle this once and for all
13:48 < ws-client> <ChillerDragon> lmao
13:49 < ws-client> <ChillerDragon> Ah you assume the target is the master server it self
13:49 < ws-client> <ChillerDragon> Which servers do you even host? Some alive fng 0.7 servers?
13:59 < bridge> <theflexbert> Why arent there more emotes
13:59 < bridge> <theflexbert> Like a hammer or hook emote
13:59 < bridge> <theflexbert> Hf emote
14:00 < bridge> <cyberfighter> because teeworlds didnt have hammerflying intended
14:01 < bridge> <theflexbert> Who cares about that
14:16 < bridge> <Jupstar ✪> Not the target, but kind of the source
14:16 < bridge> <Jupstar ✪> The fake source
14:16 < bridge> <Jupstar ✪> For the reflection
14:48 < bridge> <ryozuki> do u guys knows how much players a vps can handle per core/ghz
14:59 < bridge> <stormaxd> i broke hammer welp
14:59 < bridge> <stormaxd> https://cdn.discordapp.com/attachments/293493549758939136/1176522307611676743/Base_Profile_2023.11.12_-_02.43.58.04.DVR_3.mp4?ex=656f2cc8&is=655cb7c8&hm=5cd7d1adbffa47ee3336ae175f5a0ce36fb584bf739637b441b61e47023978ec&
14:59 < bridge> <stormaxd> but really, where can i fix it?
15:07 < bridge> <Jupstar ✪> 128p per shittiest vps u can buy
15:46 < bridge> <teero777> 😂:brownbear:
15:51 < bridge> <stormaxd> and after i updated my client
15:51 < bridge> <stormaxd> https://i.imgur.com/D49GEZn.png
15:51 < bridge> <stormaxd> gg
15:52 < bridge> <teero777> Provide src and we can help you :troll:
15:52 < bridge> <stormaxd> faie
15:52 < bridge> <stormaxd> fair
15:52 < bridge> <stormaxd> https://github.com/StormAxs/StA
15:53 < bridge> <teero777> oh lol didn't actually think it was open source
15:53 < bridge> <stormaxd> https://media.discordapp.net/attachments/1091796670951456809/1116992248970747945/62.gif
15:54 < bridge> <teero777> XDD how long did you not merge master?
15:56 < bridge> <stormaxd> i just synced fork
15:56 < bridge> <stormaxd> i just synced the fork
15:56 < bridge> <milkeeycat> do u use vulkan?
15:56 < bridge> <stormaxd> i tryed all render metods
15:56 < bridge> <stormaxd> even open gl 106
15:57 < bridge> <milkeeycat> rip
15:57 < bridge> <Jupstar ✪> U see far into the future
15:57 < bridge> <Jupstar ✪> I'd say you have a missing data directory entry
15:57 < bridge> <Jupstar ✪> Do a clean rebuild
16:03 < bridge> <stormaxd> @jupeyy_keks helped as always
16:03 < bridge> <stormaxd> thanks jupi
16:03 < bridge> <stormaxd> :happy_cry_cat:
16:05 < bridge> <stormaxd> well
16:06 < bridge> <stormaxd> where can i find hammer position while spectating?
16:06 < bridge> <stormaxd> still this goofy bug
16:25 < bridge> <ryozuki> @jupeyy_keks do u think player count scales log or linear
16:25 < bridge> <ryozuki> perf wise
16:28 < bridge> <learath2> ???
16:28 < bridge> <learath2> Uncorrelated
16:28 < bridge> <ryozuki> @learath2 ok i had a brain fart
16:28 < bridge> <ryozuki> i meant perf per player count
16:29 < bridge> <ryozuki> hmm like if u get a beefy vps
16:29 < bridge> <learath2> Okay that makes more sense 😄
16:30 < bridge> <learath2> Theoretically it should exhibit polynomial behaviour with all the n^2 algorithms we use
16:31 < bridge> <learath2> But that's assuming one gameserver with player count going to infinity 😄
16:36 < bridge> <ryozuki> xd
16:36 < bridge> <ryozuki> at work they doing a backend game server with elixir and i think something in rust
16:36 < bridge> <ryozuki> on a 24 core machine they could handle 600 players
16:37 < bridge> <ryozuki> which idk if its a lot
16:37 < bridge> <ryozuki> but well completly unrelated game
16:37 < bridge> <ryozuki> i think its 3d too
16:37 < bridge> <Jupstar ✪> Uff that's really bad
16:37 < bridge> <ryozuki> i thought so too
16:37 < bridge> <ryozuki> xd
16:37 < bridge> <Jupstar ✪> Is the game so complex?
16:37 < bridge> <ryozuki> i doubt
16:37 < bridge> <ryozuki> im not in the team
16:37 < bridge> <ryozuki> i dont do elixir
16:38 < bridge> <Jupstar ✪> But network can quickly become a limiting factor
16:38 < bridge> <ryozuki> i think its mainly cuz elixir ngl
16:38 < bridge> <ryozuki> true
16:38 < bridge> <ryozuki> i think they use websockets tho
16:38 < bridge> <ryozuki> they considering quic
16:38 < bridge> <Jupstar ✪> I assume these 600 players are on different lobbies too?
16:39 < bridge> <ryozuki> ye
16:39 < bridge> <ryozuki> lobbies of 10 players iirc
16:39 < bridge> <Jupstar ✪> I c
16:39 < bridge> <ryozuki> 2.9ghz
16:39 < bridge> <ryozuki> 256gb ram
16:39 < bridge> <ryozuki> but itjust uses 2gb iirc
16:39 < bridge> <ryozuki> xd
16:39 < bridge> <Jupstar ✪> XD
16:40 < bridge> <ryozuki> gotta have backup kek
16:44 < bridge> <ryozuki> @learath2 when use quad trees or bsp on ddnet
16:46 < bridge> <heinrich5991> maybe in @Zwelf's rust impl of ddnet physics 😉
16:46 < bridge> <heinrich5991> it's probably easier there
17:43 < bridge> <chillerdragon> Oh yea had the same. I think something with the mapres changed. Make sure your user wide storage location matches the source code generated data folders and so on. So just running a make install in your repo should fix it
17:47 < bridge> <chillerdragon> Or updating ddnet via the package manager
18:47 < bridge> <learath2> https://paste.pr0.tips/Hnw?c if anyone has a couple minutes, I'm curious how you would do this task
18:48 < bridge> <Jupstar ✪> where is the task?
18:48 < bridge> <learath2> You just merge two sorted linked lists
18:48 < bridge> <Jupstar ✪> list.append(list2)
18:48 < bridge> <learath2> The resulting list must also be sorted 😄
18:49 < bridge> <Jupstar ✪> then i'd use a datatype that is called sortedlist xd
18:49 < bridge> <learath2> ok
18:49 < bridge> <Jupstar ✪> is that yours or from someone else?
18:49 < bridge> <learath2> That's mine
18:51 < bridge> <zogtib> seems trivialish but also interesting, lemme try 🙂
18:51 < bridge> <learath2> It's absolutely trivial, just curious how other people would go about it, there are lots of ways to do it
18:51 < bridge> <Jupstar ✪> ```c
18:51 < bridge> <Jupstar ✪> struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2) {
18:51 < bridge> <Jupstar ✪>     struct ListNode dummy;  // Dummy head node.
18:51 < bridge> <Jupstar ✪>     struct ListNode *cur = &dummy;
18:51 < bridge> <Jupstar ✪> 
18:51 < bridge> <Jupstar ✪>     // While there are elements in either list.
18:51 < bridge> <Jupstar ✪>     while (list1 && list2) {
18:51 < bridge> <Jupstar ✪>         if (list1->val < list2->val) {
18:51 < bridge> <Jupstar ✪>             cur->next = list1;
18:51 < bridge> <Jupstar ✪>             list1 = list1->next;
18:52 < bridge> <Jupstar ✪>         } else {
18:52 < bridge> <Jupstar ✪>             cur->next = list2;
18:52 < bridge> <Jupstar ✪>             list2 = list2->next;
18:52 < bridge> <Jupstar ✪>         }
18:52 < bridge> <Jupstar ✪>         cur = cur->next;
18:52 < bridge> <Jupstar ✪>     }
18:52 < bridge> <Jupstar ✪> 
18:52 < bridge> <Jupstar ✪>     // Append the remaining elements of `list1` or `list2`.
18:52 < bridge> <Jupstar ✪>     cur->next = list1 ? list1 : list2;
18:52 < bridge> <Jupstar ✪> 
18:52 < bridge> <Jupstar ✪>     return dummy.next;
18:52 < bridge> <Jupstar ✪> }
18:52 < bridge> <Jupstar ✪> ```
18:52 < bridge> <heinrich5991> hello chatgpt
18:52 < bridge> <Jupstar ✪> hi
18:52 < bridge> <gerdoe> nice one
18:52 < bridge> <learath2> ChatGPT definitely ruined the world
18:53 < bridge> <heinrich5991> yea, I think I like that one better
18:53 < bridge> <learath2> It's the same as my first one 😄
18:53 < bridge> <learath2> Well same idea
18:53 < bridge> <heinrich5991> I was going to complain that yours does unnecessary writes
18:53 < bridge> <gerdoe> inner cycle got removed
18:54 < bridge> <heinrich5991> also I find your first solution/chatgpt's solution easier to understand
18:54 < bridge> <gerdoe> +1
18:54 < bridge> <learath2> Yeah, I think I like that one better too
18:54 < bridge> <Jupstar ✪> ```c
18:54 < bridge> <Jupstar ✪> struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2) {
18:54 < bridge> <Jupstar ✪>     if (!list1) return list2;
18:54 < bridge> <Jupstar ✪>     if (!list2) return list1;
18:54 < bridge> <Jupstar ✪> 
18:54 < bridge> <Jupstar ✪>     if (list1->val < list2->val) {
18:54 < bridge> <Jupstar ✪>         list1->next = mergeTwoLists(list1->next, list2);
18:54 < bridge> <Jupstar ✪>         return list1;
18:54 < bridge> <Jupstar ✪>     } else {
18:54 < bridge> <Jupstar ✪>         list2->next = mergeTwoLists(list1, list2->next);
18:54 < bridge> <Jupstar ✪>         return list2;
18:55 < bridge> <Jupstar ✪>     }
18:55 < bridge> <Jupstar ✪> }
18:55 < bridge> <Jupstar ✪> ```
18:55 < bridge> <Jupstar ✪> xd
18:55 < bridge> <heinrich5991> no
18:55 < bridge> <gerdoe> https://tenor.com/view/discordmemes-gif-25118502
18:55 < bridge> <gerdoe> noo
18:55 < bridge> <Jupstar ✪> NOOO
18:55 < bridge> <learath2> Meh, chatgpt definitely ruined the fun of these kinds of challanges
18:56 < bridge> <Mr.Gh0s7> I got zogpt
18:56 < bridge> <Mr.Gh0s7> aka I just ask zogtib
18:56 < bridge> <learath2> I was curious how you'd solve it, not how a machine learning model trained on stackoverflow where this question has been asked 10000 times would solve it
18:56 < bridge> <Jupstar ✪> the problem is, u didnt ask me if u want the fastest, or the cleanst, or the shortest
18:57 < bridge> <heinrich5991> fastest: don't use linked lists
18:57 < bridge> <gerdoe> hm, are you golfing on so?
18:57 < bridge> <learath2> I have a feeling you'd just ask chatgpt either way
18:57 < bridge> <gerdoe> i think there's no gpt answers
18:57 < bridge> <Jupstar ✪> i mean i've done such coding challenges so often already
18:58 < bridge> <learath2> I'm just doing some leetcode to warm back up to coding
18:58 < bridge> <learath2> Which solution you'd pick on your own volition given nothing but the challange is what's curious to me
18:58 < bridge> <Jupstar ✪> @learath2 ok, here's is one i 100% did myself
18:58 < bridge> <Jupstar ✪> 
18:58 < bridge> <Jupstar ✪> https://www.codewars.com/kata/52774a314c2333f0a7000688
18:59 < bridge> <Jupstar ✪> ||
18:59 < bridge> <Jupstar ✪> ```c
18:59 < bridge> <Jupstar ✪> #include <stdbool.h>
18:59 < bridge> <Jupstar ✪> 
18:59 < bridge> <Jupstar ✪> bool validParentheses(const char *s) {
18:59 < bridge> <Jupstar ✪>   int CurP = 1;
18:59 < bridge> <Jupstar ✪>   while(*s) {
18:59 < bridge> <Jupstar ✪>     switch(*s++) {
18:59 < bridge> <Jupstar ✪>       case '(': CurP *= 2; break;
18:59 < bridge> <Jupstar ✪>       case ')': CurP /= 2; break;
18:59 < bridge> <Jupstar ✪>     }
18:59 < bridge> <Jupstar ✪>   }
18:59 < bridge> <Jupstar ✪>   return CurP == 1;
18:59 < bridge> <Jupstar ✪> }
18:59 < bridge> <Jupstar ✪> ```
18:59 < bridge> <Jupstar ✪> ||
18:59 < bridge> <Jupstar ✪> my solution:
18:59 < bridge> <Jupstar ✪> ||
18:59 < bridge> <Jupstar ✪> ```c
18:59 < bridge> <Jupstar ✪> #include <stdbool.h>
18:59 < bridge> <Jupstar ✪> 
18:59 < bridge> <Jupstar ✪> bool validParentheses(const char *s) {
18:59 < bridge> <Jupstar ✪>   int CurP = 1;
18:59 < bridge> <Jupstar ✪>   while(*s) {
18:59 < bridge> <Jupstar ✪>     switch(*s++) {
18:59 < bridge> <Jupstar ✪>       case '(': CurP *= 2; break;
18:59 < bridge> <Jupstar ✪>       case ')': CurP /= 2; break;
19:00 < bridge> <Jupstar ✪>     }
19:00 < bridge> <Jupstar ✪>   }
19:00 < bridge> <Jupstar ✪>   return CurP == 1;
19:00 < bridge> <Jupstar ✪> }
19:00 < bridge> <Jupstar ✪> ```
19:00 < bridge> <Jupstar ✪> ||
19:00 < bridge> <learath2> Ah I did this one yesterday too
19:00 < bridge> <learath2> Oh, actually a different one nvm
19:00 < bridge> <learath2> See now that's cute
19:00 < bridge> <Jupstar ✪> give me the codewars next time, then it's more fun, bcs it can compile etc.
19:01 < bridge> <learath2> Hm, never tried codewars, let me give that a go too
19:02 < bridge> <gerdoe> 🤓 `CurP <<= 1;` `CurP >>= 1;`
19:02 < bridge> <learath2> Oh actually I did try codewars a bit apparently
19:02 < bridge> <heinrich5991> ```c
19:02 < bridge> <heinrich5991> struct list {
19:02 < bridge> <heinrich5991>     int val;
19:02 < bridge> <heinrich5991>     struct list *next;
19:02 < bridge> <heinrich5991> };
19:02 < bridge> <heinrich5991> 
19:02 < bridge> <heinrich5991> struct list *merge_inplace(struct list *a, struct list *b) {
19:02 < bridge> <heinrich5991>     struct list *result;
19:02 < bridge> <heinrich5991>     struct list **cur = &result;
19:02 < bridge> <heinrich5991> 
19:02 < bridge> <heinrich5991>     while(a && b) {
19:02 < bridge> <heinrich5991>         if(a->val < b->val) {
19:02 < bridge> <heinrich5991>             *cur = a;
19:02 < bridge> <heinrich5991>             cur = &cur->next;
19:02 < bridge> <heinrich5991>             a = a->next;
19:03 < bridge> <heinrich5991>         } else {
19:03 < bridge> <heinrich5991>             *cur = b;
19:03 < bridge> <heinrich5991>             cur = &cur->next;
19:03 < bridge> <heinrich5991>             b = b->next;
19:03 < bridge> <heinrich5991>         }
19:03 < bridge> <heinrich5991>     }
19:03 < bridge> <heinrich5991> 
19:03 < bridge> <heinrich5991>     if(a) {
19:03 < bridge> <heinrich5991>         *cur = a;
19:03 < bridge> <heinrich5991>     } else {
19:03 < bridge> <heinrich5991>         *cur = b;
19:03 < bridge> <heinrich5991>     }
19:03 < bridge> <heinrich5991>     return result;
19:03 < bridge> <heinrich5991> }
19:03 < bridge> <heinrich5991> ```
19:03 < bridge> <heinrich5991> here's mine, untested
19:03 < bridge> <heinrich5991> it has also never seen a compiler
19:04 < bridge> <learath2> As a fan of the double pointer trick I approve, the dummy head in gpts answer was ugly
19:04 < bridge> <heinrich5991> yea, I also didn't like it so much
19:05 < bridge> <heinrich5991> it's essentially a hidden double pointer with a useless value field
19:06 < bridge> <learath2> You are missing some *s I think
19:06 < bridge> <heinrich5991> yes
19:06 < bridge> <learath2> Atleast my mental compiler isn't liking the amount of -> and & there per datatype 😄
19:06 < bridge> <heinrich5991> compiler says I should use `&(*cur)->next` instead of `&cur->next`
19:06 < bridge> <heinrich5991> not necessary in rust :p
19:07 < bridge> <learath2> Yeah I think I would change the very last if block to a ternary and have this as my final answer
19:24 < bridge> <heinrich5991> ```rs
19:24 < bridge> <heinrich5991> use std::mem;
19:24 < bridge> <heinrich5991> 
19:24 < bridge> <heinrich5991> struct List {
19:24 < bridge> <heinrich5991>     val: i32,
19:24 < bridge> <heinrich5991>     next: Option<Box<List>>,
19:24 < bridge> <heinrich5991> }
19:24 < bridge> <heinrich5991> 
19:24 < bridge> <heinrich5991> fn merge_inplace(mut a: Option<Box<List>>, mut b: Option<Box<List>>) -> Option<Box<List>> {
19:24 < bridge> <heinrich5991>     let mut result = None;
19:24 < bridge> <heinrich5991>     let mut cur: &mut Option<Box<List>> = &mut result;
19:24 < bridge> <heinrich5991> 
19:24 < bridge> <heinrich5991>     loop {
19:24 < bridge> <heinrich5991>         match (a, b) {
19:24 < bridge> <heinrich5991>             (Some(mut a_inner), Some(mut b_inner)) => {
19:24 < bridge> <heinrich5991>                 if a_inner.val < b_inner.val {
19:24 < bridge> <heinrich5991>                     let a_next = mem::replace(&mut a_inner.next, None);
19:24 < bridge> <heinrich5991>                     cur = &mut cur.insert(a_inner).next;
19:24 < bridge> <heinrich5991>                     a = a_next;
19:24 < bridge> <heinrich5991>                     b = Some(b_inner);
19:24 < bridge> <heinrich5991>                 } else {
19:24 < bridge> <heinrich5991>                     let b_next = mem::replace(&mut b_inner.next, None);
19:24 < bridge> <heinrich5991>                     cur = &mut cur.insert(b_inner).next;
19:24 < bridge> <heinrich5991>                     a = Some(a_inner);
19:24 < bridge> <heinrich5991>                     b = b_next;
19:24 < bridge> <heinrich5991>                 }
19:24 < bridge> <heinrich5991>             }
19:24 < bridge> <heinrich5991>             (Some(a_inner), None) => {
19:24 < bridge> <heinrich5991>                 *cur = Some(a_inner);
19:24 < bridge> <heinrich5991>                 break;
19:24 < bridge> <heinrich5991>             }
19:24 < bridge> <heinrich5991> wow, that took a while
19:25 < bridge> <heinrich5991> can chatgpt do this? I'd be impressed 😮
19:25 < bridge> <heinrich5991> took me ~15min
19:25 < bridge> <heinrich5991> this time developed together with the compiler
19:25 < bridge> <heinrich5991> @learath2 ^
19:25 < bridge> <Jupstar ✪> ```rust
19:25 < bridge> <Jupstar ✪> use std::mem;
19:25 < bridge> <Jupstar ✪> 
19:25 < bridge> <Jupstar ✪> // Definition for singly-linked list.
19:25 < bridge> <Jupstar ✪> #[derive(PartialEq, Eq, Clone, Debug)]
19:25 < bridge> <Jupstar ✪> pub struct ListNode {
19:25 < bridge> <Jupstar ✪>     pub val: i32,
19:25 < bridge> <Jupstar ✪>     pub next: Option<Box<ListNode>>,
19:25 < bridge> <Jupstar ✪> }
19:25 < bridge> <Jupstar ✪> 
19:25 < bridge> <Jupstar ✪> impl ListNode {
19:25 < bridge> <Jupstar ✪>     #[inline]
19:25 < bridge> <Jupstar ✪>     fn new(val: i32) -> Self {
19:25 < bridge> <Jupstar ✪>         ListNode { next: None, val }
19:25 < bridge> <Jupstar ✪>     }
19:25 < bridge> <Jupstar ✪> }
19:25 < bridge> <Jupstar ✪> 
19:25 < bridge> <Jupstar ✪> pub fn merge_two_lists(
19:25 < bridge> <Jupstar ✪>     list1: Option<Box<ListNode>>,
19:25 < bridge> <Jupstar ✪>     list2: Option<Box<ListNode>>,
19:25 < bridge> <Jupstar ✪> ) -> Option<Box<ListNode>> {
19:25 < bridge> <Jupstar ✪>     // Using a dummy head to simplify edge cases
19:25 < bridge> <Jupstar ✪>     let mut dummy = Box::new(ListNode::new(0));
19:26 < bridge> <Jupstar ✪>     let mut cur = &mut dummy;
19:26 < bridge> <Jupstar ✪> 
19:26 < bridge> <Jupstar ✪>     // Two mutable references to list1 and list2
19:26 < bridge> <Jupstar ✪>     let mut l1 = list1;
19:26 < bridge> <Jupstar ✪>     let mut l2 = list2;
19:26 < bridge> <Jupstar ✪> 
19:26 < bridge> <Jupstar ✪>     while l1.is_some() && l2.is_some() {
19:26 < bridge> <Jupstar ✪>         let next_node = if l1.as_ref().unwrap().val < l2.as_ref().unwrap().val {
19:26 < bridge> <Jupstar ✪> NOT CHECKED
19:26 < bridge> <Jupstar ✪> just copy pasted
19:26 < bridge> <Mr.Gh0s7> rip chiller
19:26 < bridge> <heinrich5991> not bad, compiles
19:26 < bridge> <learath2> It's impressive that it can write rust at all given it's training set doesn't include quite as much of it
19:26 < bridge> <heinrich5991> it's writing rust like C though
19:26 < bridge> <Jupstar ✪> it is pretty bad in it tbh
19:27 < bridge> <learath2> Yeah, it just wrote whatever one would write in C in Rust 😄
19:27 < bridge> <_voxeldoesart> arent strusts just objects LOL
19:27 < bridge> <heinrich5991> but color me impressed
19:27 < bridge> <Jupstar ✪> but now that it can serch the internet it's sometimes useful to find crates, bcs it reads the docs and at least kind of understands it 😄
19:27 < bridge> <heinrich5991> hmm. what was the prompts, @jupeyy_keks?
19:27 < bridge> <teero777> *s++ would increment the value not the pointer no?
19:28 < bridge> <learath2> Does rust have some guarantee as to the order match branches will be checked?
19:28 < bridge> <Jupstar ✪> rewrite in rust
19:28 < bridge> <heinrich5991> top to bottom
19:28 < bridge> <teero777> or does ++ have more priority than derefrence
19:28 < bridge> <heinrich5991> `*s++` increments the pointer
19:28 < bridge> <learath2> ++ sticks harder
19:28 < bridge> <teero777> ah ok
19:28 < bridge> <teero777> good to knwo
19:28 < bridge> <teero777> good to know
19:28 < bridge> <heinrich5991> everything is evaluated in order it's written
19:29 < bridge> <heinrich5991> also applies to function arguments, etc.
19:29 < bridge> <learath2> Hm, that sounds bad for performance, the compiler isn't allowed to reorder stuff?
19:29 < bridge> <heinrich5991> no, unless it can prove it doesn't affect the outcome
19:30 < bridge> <learath2> Oh, okay
19:30 < bridge> <heinrich5991> I think C++ does the same nowadays?
19:30 < bridge> <learath2> I thought even if it could prove it doesn't matter it wasn't allowed to change the order
19:30 < bridge> <teero777> why *= and /= instead of just += and -= xdd
19:30 < bridge> <learath2> C and C++ both use the same as-if rule, as long as there is no observable change it's fine
19:30 < bridge> <heinrich5991> that actually serves a value there 😉
19:31 < bridge> <heinrich5991> same for rust
19:31 < bridge> <heinrich5991> but in C, order was undefined at some point, I thought
19:31 < bridge> <heinrich5991> and C++
19:31 < bridge> <teero777> what value xd
19:31 < bridge> <heinrich5991> 1 / 2 * 2 = 0
19:32 < bridge> <heinrich5991> 1 / 2 * 2 = 0 ≠ 1
19:32 < bridge> <teero777> ah
19:32 < bridge> <teero777> that makes sense
19:32 < bridge> <heinrich5991> 0 - 1 + 1 = 0 = 0
19:32 < bridge> <teero777> nice
19:34 < bridge> <chairn> what if there are more than 64 parenthesis?
19:34 < bridge> <learath2> If there are no sequence points order is undefined. If there are sequence points the compiler is only allowed to reorder if it can prove that it changes nothing
19:35 < bridge> <heinrich5991> *31
19:35 < bridge> <learath2> If no sequence points the compiler can do whatever anyway
19:35 < bridge> <learath2> I don't think Rust has the idea of sequence points though, atleast I haven't encountered it yet
19:41 < bridge> <Jupstar ✪> then your computer explodes
19:42 < bridge> <Jupstar ✪> gcc -Dint=__int128
19:43 < bridge> <Jupstar ✪> 😏
19:49 < bridge> <learath2> Did any of you know about the Boyer-Moore string search algorithm?
19:50 < bridge> <learath2> After doing an exercise implementing strstr I was curious what a less naive solution looks like and came across it
19:50 < bridge> <ryozuki> looks weird xd
19:51 < bridge> <ryozuki> one thing i dislike about c++, this is confusing, but it makes some code look "nice" or "smart"
19:52 < bridge> <learath2> It makes code look sexy asf and you know it
19:52 < bridge> <ryozuki> @learath2 it makes it look smart as i said
19:52 < bridge> <ryozuki> but not always writing "smart" code is good
19:52 < bridge> <ryozuki> specially if its not for a code golf
19:53 < bridge> <ryozuki> anyway rn im a nasm guy not rust guy
19:53 < bridge> <ryozuki> :poggers2:
19:54 < bridge> <ryozuki> @learath2 i found a snippet of asm to calc next power of 2
19:54 < bridge> <ryozuki> and its rly nice
19:54 < bridge> <Jupstar ✪> ```c
19:54 < bridge> <Jupstar ✪> void a () {
19:54 < bridge> <Jupstar ✪>     int c = 0;
19:54 < bridge> <Jupstar ✪>     ++++++++++++++c;
19:54 < bridge> <Jupstar ✪> }
19:54 < bridge> <Jupstar ✪> ```
19:54 < bridge> <Jupstar ✪> 
19:54 < bridge> <Jupstar ✪> how do you like this code?
19:54 < bridge> <ryozuki> xd
19:54 < bridge> <ryozuki> https://github.com/edg-l/aoc2023-nasm
19:54 < bridge> <learath2> oh look yet another snippet no one would ever see anywhere but in IOCCC
19:55 < bridge> <ryozuki> ```x86asm
19:55 < bridge> <ryozuki> next_pow_2:
19:55 < bridge> <ryozuki>     dec eax
19:55 < bridge> <ryozuki>     bsr rcx, rax
19:55 < bridge> <ryozuki>     inc ecx
19:55 < bridge> <ryozuki>     mov eax, 1
19:55 < bridge> <ryozuki>     shl rax, cl
19:55 < bridge> <ryozuki>     ret
19:55 < bridge> <ryozuki> ```
19:55 < bridge> <ryozuki> @learath2 can u generate this with C
19:55 < bridge> <learath2> Oh wait, is AOC now?
19:55 < bridge> <ryozuki> no its in december
19:55 < bridge> <learath2> Yes, I think I even sent a blog post about it sometime 😄
19:55 < bridge> <ryozuki> @learath2 this snippet uses eax and rax
19:55 < bridge> <ryozuki> so my understanding is
19:56 < bridge> <ryozuki> using eax builds to a instruction that is smaller
19:56 < bridge> <ryozuki> than rax?
19:56 < bridge> <ryozuki> and thats why its better?
19:56 < bridge> <ryozuki> or using rax will result in same perf
19:56 < bridge> <ryozuki> smaller instructions = better cache
19:56 < bridge> <learath2> that's a question for @chairn
19:57 < bridge> <learath2> It should in theory, but who knows, maybe it ends up pipelining worse and performs worse with 131 of them in a row
19:57 < bridge> <learath2> Modern CPUs are a mystery
19:57 < bridge> <zogtib> (it's taken me a while (I have some "minor" health difficulties))
19:57 < bridge> <zogtib> ```c
19:57 < bridge> <zogtib> struct listnode {
19:57 < bridge> <zogtib>     int val;
19:57 < bridge> <zogtib>     struct listnode *next;
19:57 < bridge> <zogtib> }
19:57 < bridge> <zogtib> 
19:57 < bridge> <zogtib> struct listnode *
19:57 < bridge> <zogtib> mergeTwoLists(struct listnode *a, struct listnode *b)
19:57 < bridge> <zogtib> {
19:57 < bridge> <zogtib>     struct listnode **p[2] = { &a, &b };
19:57 < bridge> <zogtib>     struct listnode *n, *lh;
19:57 < bridge> <zogtib>     int i;
19:58 < bridge> <zogtib> 
19:58 < bridge> <zogtib>     if (!a) return b;
19:58 < bridge> <zogtib>     if (!b) return a;
19:58 < bridge> <zogtib>     lh = a->val < b->val ? a : b; /* list head */
19:58 < bridge> <zogtib> 
19:58 < bridge> <zogtib>     n = lh;
19:58 < bridge> <zogtib>     while (1) {
19:58 < bridge> <zogtib>         i = a->val < b->val;
19:58 < bridge> <zogtib>         n = n->next = *p[i];
19:58 < bridge> <zogtib>         if (!(*p = (*p)->next)) {
19:58 < bridge> <zogtib>             n->next = *p[i ^ 1];
19:58 < bridge> <zogtib>             break;
19:58 < bridge> <zogtib>         }
19:58 < bridge> <zogtib>     }
19:58 < bridge> <zogtib> 
19:58 < bridge> <zogtib>     return lh;
19:58 < bridge> <zogtib> }
19:58 < bridge> <zogtib> ```
19:58 < bridge> <ryozuki> i found out there is a mov instruction that can be used for branchless programming
19:58 < bridge> <learath2> Ah yep, it's also iirc turing complete on it's own 😄
19:58 < bridge> <ryozuki> CMOVL
19:58 < bridge> <Jupstar ✪> COVIDL
19:58 < bridge> <ryozuki> https://www.felixcloutier.com/x86/cmovcc
19:58 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1176597629879193622/image.png?ex=656f72ef&is=655cfdef&hm=d37b772c767985d40a90dfd29029ca680e49fdbc6be7585f54cc2f4414bc86c2&
19:58 < bridge> <ryozuki> there is lot of variants
19:59 < bridge> <Jupstar ✪> @ryozuki if u want the real fun, do the opposite: reverse engineerig
19:59 < bridge> <ryozuki> too hard, i gotta start with mastering assembly first
19:59 < bridge> <learath2> conditional moves are so hard to program with, I learned assembly on things that don't have them
20:00 < bridge> <learath2> You also don't think in terms of conditional moves when programming in C either, so it's not easy from that direction either
20:00 < bridge> <ryozuki> but thats the dope thing about asm
20:00 < bridge> <ryozuki> fine grained control
20:00 < bridge> <ryozuki> u cant get more control
20:00 < bridge> <ryozuki> if ur a master of asm u are a magician
20:00 < bridge> <learath2> At that point, I found it's just more rope to hang yourself with, atleast on modern cpus 😦
20:01 < bridge> <teero777> https://www.reddit.com/r/teeworlds/s/pSAOHT7Liu
20:01 < bridge> <learath2> I wish it was possible for mere humans like me to properly understand and program assembly for cpus that span a decade and are complicated beyond belief
20:01 < bridge> <ryozuki> well im off, im taking a bike to some place and walk a mountain with a friend
20:01 < bridge> <teero777> Woahh
20:01 < bridge> <ryozuki> kek
20:01 < bridge> <ryozuki> cya later
20:01 < bridge> <learath2> don't, it's too late, bears will eat you
20:01 < bridge> <ryozuki> xdd
20:01 < bridge> <ryozuki> its rly relaxing to do this
20:01 < bridge> <ryozuki> u see the whole city of barcelona
20:01 < bridge> <ryozuki> with their lights
20:01 < bridge> <ryozuki> from the mountain
20:02 < bridge> <ryozuki> a good stress relief from work
20:02 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1176598559265673267/IMG_20231029_193348.jpg?ex=656f73cc&is=655cfecc&hm=2ddedbc744a8386650c07a549649fbeb4cb0116b1af25d1295beb86ecdf2ffdb&
20:02 < bridge> <ryozuki> took this some time ago
20:02 < bridge> <ryozuki> and my camera is shot
20:02 < bridge> <ryozuki> shit
20:02 < bridge> <ryozuki> mobile
20:02 < bridge> <learath2> That is a nice picture
20:03 < bridge> <ryozuki> ye
20:09 < bridge> <zogtib> This is incorrect actually, this could be OK but it's definitely less wrong.
20:10 < bridge> <zogtib> ```c
20:10 < bridge> <zogtib> struct listnode *
20:10 < bridge> <zogtib> mergeTwoLists(struct listnode *a, struct listnode *b)
20:10 < bridge> <zogtib> {
20:10 < bridge> <zogtib>     struct listnode **p[2] = { &a, &b };
20:10 < bridge> <zogtib>     struct listnode *n, ln;
20:10 < bridge> <zogtib>     int i;
20:10 < bridge> <zogtib> 
20:10 < bridge> <zogtib>     if (!a) return b;
20:10 < bridge> <zogtib>     if (!b) return a;
20:10 < bridge> <zogtib> 
20:10 < bridge> <zogtib>     n = &ln;
20:10 < bridge> <zogtib>     while (1) {
20:10 < bridge> <zogtib>         i = a->val < b->val;
20:10 < bridge> <zogtib>         n = n->next = *p[i];
20:10 < bridge> <zogtib>         if (!(*p = (*p)->next)) {
20:10 < bridge> <zogtib>             n->next = *p[i ^ 1];
20:10 < bridge> <zogtib>             break;
20:10 < bridge> <zogtib>         }
20:10 < bridge> <zogtib>     }
20:10 < bridge> <zogtib> 
20:10 < bridge> <zogtib>     return lh.next;
20:10 < bridge> <zogtib> }```
20:14 < bridge> <zogtib> That's also wrong. This compiles though (last submission):
20:14 < bridge> <zogtib> ```c
20:14 < bridge> <zogtib> struct listnode *
20:14 < bridge> <zogtib> mergeTwoLists(struct listnode *a, struct listnode *b)
20:14 < bridge> <zogtib> {
20:14 < bridge> <zogtib>     struct listnode **p[2] = { &a, &b };
20:14 < bridge> <zogtib>     struct listnode *n, ln;
20:14 < bridge> <zogtib>     int i;
20:14 < bridge> <zogtib> 
20:14 < bridge> <zogtib>     if (!a) return b;
20:14 < bridge> <zogtib>     if (!b) return a;
20:14 < bridge> <zogtib> 
20:14 < bridge> <zogtib>     n = &ln;
20:14 < bridge> <zogtib>     while (1) {
20:14 < bridge> <zogtib>         i = a->val < b->val;
20:14 < bridge> <zogtib>         n = n->next = *p[i];
20:14 < bridge> <zogtib>         if (!(*p[i] = (*p[i])->next)) {
20:15 < bridge> <zogtib>             n->next = *p[i ^ 1];
20:15 < bridge> <zogtib>             break;
20:15 < bridge> <zogtib>         }
20:15 < bridge> <zogtib>     }
20:15 < bridge> <zogtib> 
20:15 < bridge> <zogtib>     return ln.next;
20:15 < bridge> <zogtib> }```
20:16 < bridge> <chairn> what if more than 128 parenthesis ?
20:16 < bridge> <Jupstar ✪> ryozuki can give you the llvm code to allow any amount of bits
20:16 < bridge> <Jupstar ✪> xd
20:16 < bridge> <chairn> i want your solution with recursive call
20:19 < bridge> <zogtib> If I wanted to sell it I'd prob say that it checks if `a` or `b` is `NULL` only they get changed and not on every iteration. 🙂
20:21 < bridge> <chairn> in general yes, but there can be alignment issues or different uops generated leading to overall less performance. But that's intel's fault though
20:32 < bridge> <_voxeldoesart> @furo321 ancient idea but lol
20:32 < bridge> <learath2> With a single type of paren you can just use a single bit to keep track of it, no?
20:34 < bridge> <learath2> Mh, not enough, just a single int should be enough for `2^sizeof (int)` pairs tho
20:37 < bridge> <learath2> Open paren is always legal s++, close paren legal iff s > 0 s--, if you end with anything but s == 0 invalid, otherwise valid
20:41 < bridge> <robyt3> Yeah, that also how I solved recursively, but the same works in a loop:
20:41 < bridge> <robyt3> ```cpp
20:41 < bridge> <robyt3> bool ValidParenthesesImpl(const char *pStr, unsigned Num)
20:41 < bridge> <robyt3> {
20:41 < bridge> <robyt3>     switch(pStr[0])
20:41 < bridge> <robyt3>     {
20:41 < bridge> <robyt3>     case '(': return ValidParenthesesImpl(pStr + 1, Num + 1);
20:41 < bridge> <robyt3>     case ')': return Num > 0 && ValidParenthesesImpl(pStr + 1, Num - 1);
20:41 < bridge> <robyt3>     case '\0': return Num == 0;
20:41 < bridge> <robyt3>     default: return ValidParenthesesImpl(pStr + 1, Num);
20:41 < bridge> <robyt3>     }
20:42 < bridge> <robyt3> }
20:42 < bridge> <robyt3> 
20:42 < bridge> <robyt3> bool ValidParentheses(const char *pStr)
20:42 < bridge> <robyt3> {
20:42 < bridge> <robyt3>     return ValidParenthesesImpl(pStr, 0);
20:42 < bridge> <robyt3> }
20:42 < bridge> <robyt3> ```
20:52 < bridge> <learath2> Why did your mind go directly to recursive? The problem doesn't intuitively look recursive to me
20:53 < bridge> <robyt3> I only went specifically for recursive because Chairn asked
20:53 < bridge> <learath2> Ah, I see
20:54 < bridge> <learath2> I really need to make peace with recursion. Whenever I feel like doing recursion for a problem I'll use an explicit stack instead
21:04 < bridge> <heinrich5991> yes, default substring search algorithm AFAIK
21:04 < bridge> <learath2> Atleast for glibc yeah
21:05 < bridge> <learath2> glibc is my goto for seeing what is better than naive
21:08 < bridge> <heinrich5991> interesting. I think I like the earlier solutions better, due to clarity. this one might minimize branches though
21:10 < bridge> <heinrich5991> that's usually the better idea, no stack smashing due to untrusted inpt
21:10 < bridge> <heinrich5991> that's usually the better idea, no stack smashing due to untrusted input
21:30 < bridge> <Jupstar ✪> ```c
21:30 < bridge> <Jupstar ✪> struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2) {
21:31 < bridge> <Jupstar ✪>     struct ListNode *head = (struct ListNode *)&list1;
21:31 < bridge> <Jupstar ✪>     struct ListNode **tail = &head;
21:31 < bridge> <Jupstar ✪> 
21:31 < bridge> <Jupstar ✪>     while (list1 && list2) {
21:31 < bridge> <Jupstar ✪>         struct ListNode **min = list1->val < list2->val ? &list1 : &list2;
21:31 < bridge> <Jupstar ✪>         *tail = *min;
21:31 < bridge> <Jupstar ✪>         *min = (*min)->next;
21:31 < bridge> <Jupstar ✪>         tail = &((*tail)->next);
21:31 < bridge> <Jupstar ✪>     }
21:31 < bridge> <Jupstar ✪> 
21:31 < bridge> <Jupstar ✪>     *tail = (struct ListNode *)((uintptr_t)list1 | (uintptr_t)list2);
21:31 < bridge> <Jupstar ✪>     return head->next;
21:31 < bridge> <Jupstar ✪> }
21:31 < bridge> <Jupstar ✪> ```
21:31 < bridge> <Jupstar ✪> GPeakT
21:31 < bridge> <Jupstar ✪> the line before the return is cool xd
21:31 < bridge> <heinrich5991> it might also break clang
21:53 < bridge> <learath2> it might break more than clang as it's implementation defined behaviour
22:26 < bridge> <heinrich5991> ah right nullptr doesn't need to be 0
22:32 < bridge> <heinrich5991> hmmm. but in clang/gcc on common targets, this is defined to be all-0-bit-pattern, no?
22:32 < bridge> <Ewan> where is the impl defined behavior
22:33 < bridge> <heinrich5991> `((uintptr_t)list1 | (uintptr_t)list2)`
22:34 < bridge> <heinrich5991> `nullptr` isn't guaranteed to translate to `0` if it is cast to some integer type
22:35 < bridge> <Ewan> oh i see
22:36 < bridge> <Ewan> seems annoying to have to list1 ? list1 : 0 lol
22:36 < bridge> <Ewan> darn
22:43 < bridge> <stormaxd> i got a problem while using TAB to fill commands `/top5` for example 
22:43 < bridge> <stormaxd> but get the game crash, the question is: where can i find `NumCommands` probably this is where i missed
22:43 < bridge> <stormaxd> https://cdn.discordapp.com/attachments/293493549758939136/1176639113215086662/image.png?ex=656f9991&is=655d2491&hm=ad302e74557b0b5c6fae8d903e4d17c30390dd35828b2a88471b536102aaf8d4&
22:44 < bridge> <Ewan> does this happen in ddnet
22:44 < bridge> <stormaxd> own client
22:44 < bridge> <stormaxd> or means gameMode?
22:47 < bridge> <stormaxd> btw i still have this hammer issue
22:50 < bridge> <Ewan> that's a divide by zero error
22:50 < bridge> <Ewan> % implicitly divides to find the remainder
