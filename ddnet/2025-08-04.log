00:46 < bridge> <luhzym> https://media.discordapp.net/attachments/1238944786551931043/1401695462905610413/image.png?ex=68913620&is=688fe4a0&hm=c8aa2b7d6c344b3589d3b6125a4462247a18b10752476ed61e7c05709c1dc6cf&=&format=webp&quality=lossless&width=718&height=958
00:46 < bridge> <luhzym> https://media.discordapp.net/attachments/1238944786551931043/1401695506517987499/image.png?ex=6891362a&is=688fe4aa&hm=428025d4bc3d00277c07cb94fbe2c67df09fe080280580b1874337065954a5c6&=&format=webp&quality=lossless&width=751&height=958
00:46 < bridge> <luhzym> https://media.discordapp.net/attachments/1238944786551931043/1400794125183483954/image.png?ex=689091b0&is=688f4030&hm=1410d3cc4acf6f82535cf0e8d2827498735f7d8cc6e971571a789267e72036de&=&format=webp&quality=lossless&width=718&height=958
00:46 < bridge> <luhzym> https://media.discordapp.net/attachments/1238944786551931043/1401666355291230340/image.png?ex=68911b04&is=688fc984&hm=4615d8927311871530d5634cf919718b07006dcb4b6b90c8d34d8a963036401b&=&format=webp&quality=lossless @everyone
00:47 < bridge> <kebscs> its not hard to setup a bot so they cant send the same scam msg in every single channel
00:54 < bridge> <melon> its the fourth person today, what are people clicking üò†
01:04 < bridge> <teero777> fingers
06:31 < bridge> <pioooooo> Classic editor moment
08:06 < bridge> <pilonpl> Yeah, maybe the editor needs to be rewritten in rust
08:21 < bridge> <Assa> yet another undo moment üôà
08:21 < bridge> <Assa> and automapper was also known to be buggy
08:22 < bridge> <Assa> gumo ^.^
09:27 < ws-client> **<ChillerDragon>** back in the days i used magic values such as -1 or methods such as IsValid to check if data is valid
09:28 < ws-client> **<ChillerDragon>** then i became a pointer enjoyer to use nullptr to represent empty values
09:28 < ws-client> **<ChillerDragon>** now i am slowly migrating to std::optional to save on memory allocations. Just not sure yet if its actually better.
09:28 < ws-client> **<ChillerDragon>** Opinions?
10:22 < bridge> <ryozuki> if u become a kernel dev, you embrace global static variables
10:28 < bridge> <milkeeycat> TIL you can do this:
10:28 < bridge> <milkeeycat> ```c
10:28 < bridge> <milkeeycat> typedef struct {
10:28 < bridge> <milkeeycat>   size_t bar;
10:28 < bridge> <milkeeycat> #define also_bar bar
10:28 < bridge> <milkeeycat> } Foo;
10:28 < bridge> <milkeeycat> 
10:28 < bridge> <milkeeycat> int main() {
10:28 < bridge> <milkeeycat>   Foo foo;
10:28 < bridge> <milkeeycat> 
10:28 < bridge> <milkeeycat>   foo.also_bar = 5;
10:28 < bridge> <milkeeycat> }
10:28 < bridge> <milkeeycat> ```
10:44 < bridge> <ryozuki> til
10:44 < bridge> <ryozuki> but why
10:45 < bridge> <ryozuki> and spinlocks
10:45 < bridge> <ryozuki> i should look into how i can support a proper mutex
10:45 < bridge> <totar> Does the macro have to be in the struct for this to work?
10:46 < bridge> <totar> This just looks like regular string replacement macro to me but idk
10:46 < ws-client> **<ChillerDragon>** but its only a define
10:46 < ws-client> **<ChillerDragon>** its never "called"
10:46 < ws-client> **<ChillerDragon>** how does that work wtf
10:46 < ws-client> **<ChillerDragon>** ah sure it is
10:47 < ws-client> **<ChillerDragon>** called at the bottom
10:50 < ws-client> **<ChillerDragon>** annoy lerato=0 annoy milkeey=1 potato=2
10:50 < ws-client> **<ChillerDragon>** !roll 0 2
10:50 < chillerbot> 1
10:50 < ws-client> **<ChillerDragon>** @milkeeycat when merge
10:50 < bridge> <milkeeycat> chillerdragon: I did merge a pr yesterday
10:51 < ws-client> **<ChillerDragon>** yes the boring one i saw 
10:52 < ws-client> **<ChillerDragon>** what about ChillerDragon:pr_iwishihadsomuchgameirl
11:21 < bridge> <learath2> modern developers when they hear you have to have globals in the kernel :noo:
11:24 < bridge> <ryozuki> xD
11:24 < bridge> <ryozuki> but u do need
11:24 < bridge> <ryozuki> otherwise its impossible
11:24 < bridge> <ryozuki> but well, in kernel u literally control everything, so i know x stuff is initialized only once etc
11:24 < bridge> <ryozuki> iim now setting up ring3 for user mode
11:25 < bridge> <ryozuki> the privilege stack table for ring 3 already done
11:25 < bridge> <ryozuki> (the stack that user mode uses)
11:25 < bridge> <learath2> You should move all globals into a "large stack frame" for kernelmain, then you can say you have no globals and compsci people will be happy
11:25 < bridge> <ryozuki> xd
11:26 < bridge> <ryozuki> i also have mouse support
11:26 < bridge> <ryozuki> and keyboard
11:26 < bridge> <ryozuki> but i want user mode before doing a fake tty
11:26 < bridge> <ryozuki> @learath2 async rust fits extremely well with kernel and interrupt handling
11:26 < bridge> <ryozuki> i pass an atomic waker to the keyboard interrupt
11:26 < bridge> <ryozuki> and use a atomic queue from crossbeam
11:27 < bridge> <learath2> Do you have tokio in your kernel?
11:27 < bridge> <ryozuki> ```rust
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki> extern "x86-interrupt" fn keyboard_interrupt_handler(_stack_frame: InterruptStackFrame) {
11:27 < bridge> <ryozuki>     use x86_64::instructions::port::Port;
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     let mut port = Port::new(PS2_DATA_PORT);
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     let scancode: u8 = unsafe { port.read() };
11:27 < bridge> <ryozuki>     crate::task:‚å®:add_scancode(scancode);
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     unsafe { get_lapic().end_of_interrupt() };
11:27 < bridge> <ryozuki> }
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki> extern "x86-interrupt" fn mouse_interrupt_handler(_stack_frame: InterruptStackFrame) {
11:27 < bridge> <ryozuki>     use x86_64::instructions::port::Port;
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     let mut port = Port::new(PS2_DATA_PORT);
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     let packet: u8 = unsafe { port.read() };
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     crate::task:üêÅ:add_packet(packet);
11:27 < bridge> <ryozuki> 
11:27 < bridge> <ryozuki>     unsafe { get_lapic().end_of_interrupt() };
11:27 < bridge> <ryozuki> }
11:27 < bridge> <ryozuki> ```
11:27 < bridge> <ryozuki> no, its a self made executor ofc
11:27 < bridge> <learath2> Or are you implementing your kernel as a weird sort of rust async runtime?
11:28 < bridge> <ryozuki> ```rust
11:28 < bridge> <ryozuki> /// Called by the keyboard interrupt handler
11:28 < bridge> <ryozuki> ///
11:28 < bridge> <ryozuki> /// Must not block or allocate.
11:28 < bridge> <ryozuki> pub(crate) fn add_scancode(scancode: u8) {
11:28 < bridge> <ryozuki>     if let Some(queue) = SCANCODE_QUEUE.get() {
11:28 < bridge> <ryozuki>         if queue.push(scancode).is_err() {
11:28 < bridge> <ryozuki>             println!("WARNING: scancode queue full; dropping keyboard input");
11:28 < bridge> <ryozuki>         } else {
11:28 < bridge> <ryozuki>             WAKER.wake();
11:28 < bridge> <ryozuki>         }
11:28 < bridge> <ryozuki>     } else {
11:28 < bridge> <ryozuki>         println!("WARNING: scancode queue uninitialized");
11:28 < bridge> <ryozuki>     }
11:28 < bridge> <ryozuki> }
11:28 < bridge> <ryozuki> ```
11:28 < bridge> <ryozuki> the kernel uses a self made async runtime for task management
11:28 < bridge> <learath2> ngl that is a good use of rust async
11:28 < bridge> <ryozuki> ```rust
11:28 < bridge> <ryozuki> pub struct Task {
11:28 < bridge> <ryozuki>     id: TaskId,
11:28 < bridge> <ryozuki>     future: Pin<Box<dyn Future<Output = ()>>>,
11:28 < bridge> <ryozuki> }
11:28 < bridge> <ryozuki> 
11:28 < bridge> <ryozuki> impl Task {
11:29 < bridge> <ryozuki> ```rust
11:29 < bridge> <ryozuki> pub struct Executor {
11:29 < bridge> <ryozuki>     tasks: BTreeMap<TaskId, Task>,
11:29 < bridge> <ryozuki>     // Array so interrupts dont allocate on push
11:29 < bridge> <ryozuki>     task_queue: Arc<ArrayQueue<TaskId>>,
11:29 < bridge> <ryozuki>     // Ensures refcounted wakers are not deallocated on interrupt handlers.
11:29 < bridge> <ryozuki>     waker_cache: BTreeMap<TaskId, Waker>,
11:29 < bridge> <ryozuki> }
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> impl Executor {
11:29 < bridge> <ryozuki>     pub fn new() -> Self {
11:29 < bridge> <ryozuki>         Executor {
11:30 < bridge> <ryozuki>             tasks: BTreeMap::new(),
11:30 < bridge> <ryozuki>             task_queue: Arc::new(ArrayQueue::new(100)),
11:30 < bridge> <ryozuki>             waker_cache: BTreeMap::new(),
11:30 < bridge> <ryozuki>         }
11:30 < bridge> <ryozuki>     }
11:30 < bridge> <ryozuki> 
11:30 < bridge> <ryozuki>     pub fn spawn(&mut self, task: Task) {
11:30 < bridge> <ryozuki>         let task_id = task.id;
11:30 < bridge> <ryozuki>         if self.tasks.insert(task.id, task).is_some() {
11:30 < bridge> <ryozuki>             panic!("task with same ID already in tasks");
11:30 < bridge> <ryozuki>         }
11:30 < bridge> <ryozuki>         self.task_queue.push(task_id).expect("queue full");
11:30 < bridge> <ryozuki>     }
11:30 < bridge> <ryozuki> 
11:30 < bridge> <ryozuki>     pub fn run(&mut self) -> ! {
11:30 < bridge> <ryozuki>         loop {
11:30 < bridge> <ryozuki>             self.run_ready_tasks();
11:30 < bridge> <ryozuki>             self.sleep_if_idle();
11:30 < bridge> <ryozuki>         }
11:30 < bridge> <ryozuki> @learath2 the async executor
11:30 < bridge> <ryozuki> the kernel ends up calling run, which diverges
11:30 < bridge> <ryozuki> and its a efficient loop that halts
11:30 < bridge> <ryozuki> so no cpu waste
11:30 < bridge> <ryozuki> (thanks to wakers and interrupts)
11:31 < bridge> <ryozuki> ```rust
11:31 < bridge> <ryozuki>     let mut executor = Executor::new();
11:31 < bridge> <ryozuki>     executor.spawn(Task::new(keyboard::process_keyboard_scancodes()));
11:31 < bridge> <ryozuki>     executor.spawn(Task::new(mouse::process_mouse_packets()));
11:31 < bridge> <ryozuki>     executor.run();
11:31 < bridge> <ryozuki> ```
11:31 < bridge> <ryozuki> and use like this
12:22 < bridge> <Ewan> "waker" giving me job ptsd
12:22 < bridge> <always> @chillerdragon i think u should move ur bot to the ger1 blocker server with no dummies to make people move there (45.141.57.22:8301)
12:23 < bridge> <always> because dummies are gay
12:23 < bridge> <always> source: me
12:38 < ws-client> **<ChillerDragon>** @always the bot follows the players so it looks like the players prefer dummies
12:51 < bridge> <always> well dummies take up player slots
12:51 < bridge> <always> so i wouldnt say thats 100% true
12:56 < bridge> <always> the ge1 server was full untill it went down
12:57 < bridge> <always> then it cem back
12:57 < bridge> <always> and no one plyed on it
12:57 < bridge> <always> and no one played on it
12:57 < bridge> <always> the ge1 server was full untill it went down and people was wishing for it come back
15:11 < bridge> <Assa> @robyt3 there is a lot that should be moved into the game/map directory I am working on. How do I split this up best? I know that I can split RenderTools and move a lot of parts of it there, technically mapitems.h should belong there, and probably much more. Introducing EnvelopeEval was the smallest change in order to move render layers, or I add a PR where I **just** move them and then start refactoring in smaller chunks
17:17 < bridge> <cellegenrih> Yo, can someone confirm to me if I did this formula right for rounding float values' increments?
17:17 < bridge> <cellegenrih> https://cdn.discordapp.com/attachments/293493549758939136/1401947037276045385/image.png?ex=6892206c&is=6890ceec&hm=af13387d5195e0bcedfdb129c1222e76a7b1a811766592e1b3c6001fa33d4340&
17:17 < bridge> <cellegenrih> https://cdn.discordapp.com/attachments/293493549758939136/1401947037678829688/image.png?ex=6892206c&is=6890ceec&hm=88c54823ec0157f77df427dc8c7e3dd6da2c7474cd396ff57cb1c16eb6307c1e&
17:17 < bridge> <cellegenrih> Or perhaps, is there a better way to round float values?
17:18 < bridge> <teero777> (int)(f + 0.5)
17:18 < bridge> <cellegenrih> With a specific increment value?
17:19 < bridge> <cellegenrih> like turning 5.34691 into 5.34000 with amount (2)
17:20 < bridge> <teero777> then you would multiply your value by 100, round it to a whole number, then divide by 100
17:20 < bridge> <cellegenrih> So my implementation is close to that
17:23 < bridge> <cellegenrih> Do I need a condition incase the amount is larger, than what it can increment onto?
17:23 < bridge> <cellegenrih> For example if  x = 5.34691 and amount = 6, then since there isn't a 6th increment, I should abandon the calculation and return x?
17:31 < bridge> <melon> yes
17:33 < bridge> <cellegenrih> Now question... how :thonk:
17:33 < bridge> <cellegenrih> I somehow need an increment amount, so perhaps I can use the ROUND_UP_LIST to determine?
17:34 < bridge> <cellegenrih> like x % Math::ROUND_UP_LIST[amount] > 0
17:34 < bridge> <cellegenrih> idk
17:35 < bridge> <melon> curious why you dont just use https://docs.rs/libmath/latest/math/round/
17:36 < bridge> <cellegenrih> Are they constant functions?
17:36 < bridge> <cellegenrih> answer is no, sadge
17:36 < bridge> <cellegenrih> Well, then it's good I make it this way
17:38 < bridge> <melon> precomputing everything sounds annoying xd
17:39 < bridge> <cellegenrih> ```#include <cmath>
17:39 < bridge> <cellegenrih> 
17:39 < bridge> <cellegenrih> template <std::floating_point T>
17:39 < bridge> <cellegenrih> constexpr T round_up(T val, int dec) noexcept {
17:39 < bridge> <cellegenrih>   if (dec <= 0) {
17:39 < bridge> <cellegenrih>     return std::ceil(val);
17:39 < bridge> <cellegenrih>   } else {
17:39 < bridge> <cellegenrih>     T multi = std::pow(T(10), dec);
17:39 < bridge> <cellegenrih>     return (std::ceil(val * multi) / multi);
17:39 < bridge> <cellegenrih>   }
17:39 < bridge> <cellegenrih> }```
17:39 < bridge> <cellegenrih> 
17:39 < bridge> <cellegenrih> A friend sent me this
17:39 < bridge> <cellegenrih> this one uses pow() directly, as well as ceil()
17:40 < bridge> <melon> does it even evaluate at compile time then?
17:40 < bridge> <cellegenrih> idk the limitations of constant functions, so I assume that for simple math operations, it's needed
17:40 < bridge> <cellegenrih> Mine should
17:41 < bridge> <cellegenrih> if I get the missing if condition right and have the entire function be fast enough, then it's worth it
17:44 < bridge> <cellegenrih> Altho Ryo might look at my code and would list me either a whole paragraph or a workaround xd
17:44 < bridge> <melon> most basic operations are constexpr `+ - / *` and `> < >= <=` checks
17:44 < bridge> <melon> 
17:44 < bridge> <melon> rusts math ops are pretty optimized, the actual benefit of computing at compile time doesnt account for the effort needed to reimplement basic functions IMO
17:45 < bridge> <melon> i think the benefit of your approach would only really come in clutch at millions of values per second
17:46 < bridge> <h1dr4x> how can i add custom sounds like fng to my server?
17:46 < bridge> <melon> sounds are client-side
17:46 < bridge> <melon> apart from sound elements within the map
17:46 < bridge> <h1dr4x> can i use in game sounds if there are
17:46 < bridge> <h1dr4x> or everything related to them are client-side?
17:47 < bridge> <cellegenrih> then what are constant functions useful for?
17:48 < bridge> <melon> embedded, real-time systems, hot loops getting called hundreds of thousands of time per second
17:49 < bridge> <cellegenrih> in Rust, normal loops cannot be evaluated at compile time
17:49 < bridge> <melon> yes because you cant have mutable values in a const ocntext
17:49 < bridge> <melon> yes because you cant have mutable values in a const context
17:50 < bridge> <melon> your approach is correct, dont get me wrong - but i dont think whatever you're attempting requires the necessary compile-time optimization
17:50 < bridge> <melon> your approach is correct, dont get me wrong - but i dont think whatever you're attempting requires the necessary compile-time optimization worth the effort*
17:52 < bridge> <cellegenrih> ngl, I want a guaranteed math solution for each function, so that whoever new comes in and looks at the functions, including the math struct, they'll know exactly how it's being made
17:53 < bridge> <kollpotato> where godot
17:53 < bridge> <cellegenrih> And assuming that this is a math function that maybe used in heavy operations, I might just put it as constant function for the time being
17:53 < bridge> <cellegenrih> no more, burnt to ashes
17:53 < bridge> <kollpotato> really?
17:54 < bridge> <kollpotato> i was looking for that post in the town hall channel
17:54 < bridge> <kollpotato> could not find it
17:54 < bridge> <cellegenrih> I have looked at each and every script in the entire Godot repository and I gave up on it immediately
17:54 < bridge> <cellegenrih> outdated libraries, inconsistent code ordering, inconsistent coding...
17:55 < bridge> <cellegenrih> https://media.discordapp.net/attachments/1290341594301726720/1400866510708277358/image.png?ex=6892269a&is=6890d51a&hm=94bae3080f030d2c03e41f85fd4639207f3ccb03133a4ca6ebaee605c1be5497&=&format=webp&quality=lossless&width=1872&height=693
17:55 < bridge> <cellegenrih> whatever the fuck this is
17:55 < bridge> <cellegenrih> And so many more
17:56 < bridge> <kollpotato> looks like a formatting issue
17:56 < bridge> <kollpotato> not a big deal imo
17:56 < bridge> <cellegenrih> ... this is a float array... with integer values.
17:56 < bridge> <kollpotato> oh
17:56 < bridge> <cellegenrih> ONLY integer values
17:56 < bridge> <melon> i wonder how long 100_000_000_000 loops will take
17:57 < bridge> <melon> wanted to benchmark precomputed and runtime
17:57 < bridge> <melon> xd
17:57 < bridge> <melon> been waiting for a minute
17:57 < bridge> <cellegenrih> assuming a loop would take around 2ns at max, eh
17:57 < bridge> <cellegenrih> depends on other things, but at min, 20ms?
17:57 < bridge> <cellegenrih> idk
17:57 < bridge> <cellegenrih> I'm bad at math anyway :troll:
17:58 < bridge> <melon> well.. it'd be `100B* 20ns`
17:58 < bridge> <kollpotato> in what language
17:58 < bridge> <melon> so like - half an hour?
17:58 < bridge> <melon> rust
17:58 < bridge> <melon> i'l strip it to 1B xd
17:58 < bridge> <kollpotato> https://benjdd.com/languages/
17:58 < bridge> <cellegenrih> singlethreaded looping probably
17:59 < bridge> <cellegenrih> I wouldn't wanna imagine how an SIMD driven loop unroll would look like
18:00 < bridge> <kollpotato> i like your funny words magic man
18:00 < bridge> <kollpotato> is unrolling 1 billion loop iterations worth it
18:01 < bridge> <kollpotato> melon there is another one with zig btw https://benjdd.com/languages2/
18:01 < bridge> <cellegenrih> idk, but it will look horrendous
18:02 < bridge> <kollpotato> dont look just run
18:02 < bridge> <cellegenrih> basically, instead of making a for loop, you do the same operation command.... x amount of times
18:02 < bridge> <kollpotato> only works if x is known at compile time
18:02 < bridge> <melon> hmm i expected worse
18:03 < bridge> <melon> anyway:
18:03 < bridge> <melon> 5.3657617s 17.8027185s
18:03 < bridge> <cellegenrih> a while loop doesn't need x to be known, all it needs is a true / false condition
18:03 < bridge> <melon> precomputed vs runtime
18:03 < bridge> <cellegenrih> hmmm
18:04 < bridge> <cellegenrih> so for your 1 billion loop, precomputed is king?
18:04 < bridge> <melon> oh holup i calculated it wrong
18:04 < bridge> <cellegenrih> missed one black_box()? :troll:
18:05 < bridge> <melon> nah just my usage of Instant::now()
18:05 < bridge> <melon> PS U:\Projects\dd-modtools> .\test.exe
18:05 < bridge> <melon> 1.9¬µs 0ns 0ns
18:05 < bridge> <melon> 
18:05 < bridge> <melon> much better
18:05 < bridge> <melon> precomputed takes longer
18:05 < bridge> <melon> bad
18:06 < bridge> <melon> :KEKW:
18:06 < bridge> <melon> PS U:\Projects\dd-modtools> .\test.exe
18:06 < bridge> <melon> 1.9¬µs 0ns
18:06 < bridge> <melon> 
18:06 < bridge> <melon> much better
18:06 < bridge> <cellegenrih> https://tenor.com/view/waltergotme-gif-18867690
18:06 < bridge> <melon> ```rust
18:06 < bridge> <melon>  let v: f64 = 5.34691;
18:06 < bridge> <melon>     let d = 2;
18:06 < bridge> <melon>     const N: usize = 1_000_000_000;
18:06 < bridge> <melon>     let m = [1.0, 10.0, 100.0, 1000.0];
18:07 < bridge> <melon> 
18:07 < bridge> <melon>     let s = Instant::now();
18:07 < bridge> <melon>     for _ in 0..N {
18:07 < bridge> <melon>         let x = m[d];
18:07 < bridge> <melon>         let _ = (v * x).round() / x;
18:07 < bridge> <melon>     }
18:07 < bridge> <melon>     let t1 = s.elapsed();
18:07 < bridge> <melon> 
18:07 < bridge> <melon>     let s = Instant::now();
18:07 < bridge> <melon>     for _ in 0..N {
18:07 < bridge> <melon>         let x = 10f64.powi(d as i32);
18:07 < bridge> <melon>         let _ = (v * x).round() / x;
18:07 < bridge> <melon>     }
18:07 < bridge> <melon>     let t2 = s.elapsed();
18:07 < bridge> <melon> ```
18:07 < ws-client> **<ChillerDragon>** @h1dr4x you can use this ancient 0.6 protocol for sounds ``GameServer()->CreateSoundGlobal(SOUND_CTF_DROP);``
18:08 < ws-client> **<ChillerDragon>** BIG DISCLAIMER! does not work in 0.7
18:08 < bridge> <melon> actually i should probably use black_box
18:08 < bridge> <cellegenrih> :troll: maybe
18:08 < bridge> <melon> with black_box precomputed is worse
18:08 < bridge> <melon> xd
18:08 < ws-client> **<ChillerDragon>** or this ``GameServer()->CreateSound(pChr->m_Pos, SOUND_GRENADE_EXPLODE);``
18:09 < bridge> <melon> PS U:\Projects\dd-modtools> .\test.exe
18:09 < bridge> <melon> 197.9402ms 182.5706ms
18:09 < bridge> <melon> PS U:\Projects\~~~~> .\test.exe
18:09 < bridge> <melon> 197.9402ms 182.5706ms
18:09 < bridge> <cellegenrih> this one looks reasonable
18:09 < bridge> <melon> PS U:\Projects\~~~~~> .\test.exe
18:09 < bridge> <melon> 1.9¬µs 0ns
18:09 < bridge> <melon> 
18:09 < bridge> <melon> much better
18:09 < bridge> <h1dr4x> Thanks
18:09 < bridge> <cellegenrih> perhaps the slowdown is due to the lookup table?
18:10 < bridge> <cellegenrih> cuz if so, then imma abandon that shit like wildfire
18:10 < bridge> <melon> i wish i could read assembly like some other chads in here
18:10 < bridge> <melon> i wonder what happens with opt-level=3
18:10 < bridge> <kollpotato> on my machine they are almost identical
18:10 < bridge> <kollpotato> https://cdn.discordapp.com/attachments/293493549758939136/1401960559057965096/image.png?ex=68922d04&is=6890db84&hm=9f829d5cdf64321e7dcfc66ea0a328d6b75ff67760f532d429f54c4ece2bde37&
18:11 < bridge> <kollpotato> what is the point of benchmarking this anyway
18:11 < bridge> <melon> 1.9264877s 1.9556894s
18:11 < bridge> <melon> 
18:11 < bridge> <melon> they start to meet the higher N is
18:11 < bridge> <melon> fun!
18:12 < bridge> <kollpotato> i tested with N=1_000 and the difference is 15ns
18:13 < bridge> <kollpotato> so it does not matter at all which one to use
18:13 < bridge> <kollpotato> right
18:13 < bridge> <melon> i dont even know if my math is correct
18:13 < bridge> <melon> 
18:13 < bridge> <melon> lets just wait for Ryozuki to pop up to benchmark
18:13 < bridge> <cellegenrih> to figure out what would cause a slowdown in my function
18:14 < bridge> <cellegenrih> I use a lookup table to round up and round down float values
18:14 < bridge> <cellegenrih> :gigachad: @ryozuki
18:14 < bridge> <cellegenrih> teach me the ways
18:16 < bridge> <kollpotato> he is definitely busy writing his own kernel
18:16 < bridge> <kollpotato> in rust
18:17 < bridge> <cellegenrih> If it's tl:dr
18:22 < bridge> <teero777> Sounds are not client aide
18:22 < bridge> <teero777> Sounds are not client side
18:24 < bridge> <cellegenrih> Sounds can be triggered server side
18:24 < bridge> <cellegenrih> playing those sound requests however, is client side
18:25 < bridge> <ryozuki> what is this
18:25 < bridge> <cellegenrih> :troll: le benchmark
18:27 < bridge> <ryozuki> u know constexpr is only if all is const right
18:27 < bridge> <melon> yeah i referred to his message of const limitations
18:28 < bridge> <melon> and that basic math operations are const, so they fit in a constexpr context
18:28 < bridge> <melon> i cant word right today, hope you know what i mean
18:28 < bridge> <melon> i go sleep
18:28 < bridge> <ryozuki> why u care, are ur inputs const too? if not there is no const
18:28 < bridge> <ryozuki> and if they are, and even if the func is not const, the optimizer may const fold it
18:29 < bridge> <cellegenrih> Well, what option do you prefer?
18:29 < bridge> <ryozuki> use round from stdlib
18:29 < bridge> <ryozuki> dont complicate ur life
18:29 < bridge> <ryozuki> did u benchmark, did u  find that rounding floats is ur bottleneck? i highly doubt it
18:29 < bridge> <ryozuki> so u move on with more useful stuff
18:29 < bridge> <cellegenrih> Not yet, since melon wanted to do it, so I let him do it xd
18:30 < bridge> <ryozuki> first, move to linux
18:30 < bridge> <ryozuki> then use https://github.com/mstange/samply
18:30 < bridge> <cellegenrih> I should benchmark it myself and see where it lags behind
18:30 < bridge> <ryozuki> to know what to optimize
18:30 < bridge> <cellegenrih> linux mint user here
18:31 < bridge> <ryozuki> this bench is retarded
18:31 < bridge> <kollpotato> yes it is
18:31 < bridge> <kollpotato> but it exists
18:31 < bridge> <cellegenrih> I would rather choose a good benchmark xd
18:31 < bridge> <cellegenrih> oki :owo:
18:32 < bridge> <ryozuki> it opens the profile in firefox
18:32 < bridge> <ryozuki> and u can see what functions use most of the time etc
18:32 < bridge> <ryozuki> @cellegenrih  https://share.firefox.dev/44eQFfa
18:32 < bridge> <ryozuki> this is an example profile of ddnet
18:33 < bridge> <kollpotato> it was also just a normal loop benchmark
18:33 < bridge> <kollpotato> i did not realize the context was about rounding
18:33 < bridge> <cellegenrih> neat
18:50 < bridge> <Solly (bun bun)> Wow this is so much better than the prisoner I was using
18:59 < bridge> <ryozuki> what prisoner
19:09 < ws-client> **<ChillerDragon>** xxxxd
19:09 < ws-client> **<ChillerDragon>** maybe autocorrect of profiler
19:24 < bridge> <robyt3> First all envelope related changes I'd say, so the envelope related functions from `CRenderTools` should also be moved
20:12 < bridge> <Solly (bun bun)> I imprisoned a profiler
20:41 < AssaIRC> discord down here :(
21:22 < bridge> <chillerdragon> <@749222324980416602>: hop on https://chat.zillyhuhn.com then hehe with sign up token nimrocks
21:25 < ws-client> **<Melon>** Ok
21:38 < bridge> <Ewan> these functions are not constexpr because they depend on errno <https://man7.org/linux/man-pages/man3/errno.3.html>
21:39 < bridge> <Ewan> u mean it sounds efficient :justatest:
21:39 < bridge> <Ewan> you should take every single compile time optimization you can
21:39 < bridge> <Ewan> should that cost happen once at compile time or countless times at runtime by every user?
21:39 < bridge> <Ewan> the planet says the former
21:40 < bridge> <melon> Well yes, as mentioned it is efficient. But it's annoying to implement
21:40 < bridge> <louis> rounding a float doesnt sound that expensive for runtime
21:40 < bridge> <louis> if thats what we're still talking abt
21:41 < bridge> <Ewan> floats aren't stored as integral + post-decimal, their representation is complex enough that it's probably more expensive than you'd think
21:41 < bridge> <melon> Having to reimplement basic crates to be `const` for something as seemingly trivial as float rounding
21:41 < bridge> <melon> But as mentioned, it only really matters if we talk thousands of calls a second
21:42 < bridge> <Ewan> it matters for habit building
21:42 < bridge> <Ewan> lol
21:42 < bridge> <Ewan> it'd obviously be better if the crates were originally const
21:42 < bridge> <Ewan> it's an oversight
21:42 < AssaIRC> one channel message probably costs more than everything you save from optimizing this
21:42 < bridge> <Ewan> yeah
21:42 < bridge> <Ewan> so what
21:43 < bridge> <melon> Looks to me like it's by design
21:43 < bridge> <melon> 
21:43 < bridge> <melon> It would overcomplicate the entire crate with external relations to lookup tables etc
21:43 < bridge> <louis> ye but u can still do operations decently fast
21:44 < bridge> <Ewan> i dont understand making a case for runtime calculation when doing it at compile-time is possible
21:44 < bridge> <Ewan> in a perfect world it'd be completely opaque and work ootb
21:44 < bridge> <Ewan> it is conceptually better
21:44 < bridge> <Ewan> maybe there are hangups to using it in some situations
21:45 < bridge> <Ewan> flops aint free...
21:47 < AssaIRC> compile time neither, but people are already complaining about long map loading times
21:48 < AssaIRC> I guess for a lot of users this complaint is actually valid, when they hit the fps max constantly and they don't benefit from all of the optimizations
21:49 < bridge> <Ewan> i kinda want to profile map loading now
21:50 < AssaIRC> go ahead, you will hit right into the render layers. You'll notice that I put a lot of code into setup in order to make rendering faster
21:50 < bridge> <Ewan> ok i'll back off
21:51 < AssaIRC> there is actually a lot of potential in optimization, no need to back off ^^ especially quad clipping and grouping can be optimized, I had an (expert) issue about it
21:52 < AssaIRC> do #10580, the planet will thank you :)
21:52 < chillerbot> https://github.com/ddnet/ddnet/issues/10580
21:53 < bridge> <Ewan> thanks chillerbot
21:54 < bridge> <Ewan> genuinely helpful
21:54 < bridge> <Ewan> does @DDNet only do it if a discord user posts it or something? #10580
21:54 < bridge> <DDNet> https://github.com/ddnet/ddnet/issues/10580
21:54 < AssaIRC> bad bot
21:54 < bridge> <Ewan> seems chillerbot didnt, i guess so
21:54 < bridge> <Assa> discord finally back
21:55 < bridge> <melon> xd
21:57 < bridge> <Assa> I guess when cities burn, the internet struggles and discord dies in an explosion, the irc channel will still be there and fine
22:09 < bridge> <cellegenrih> for me that ain't the difficult part, since I work with simple math instructions now
22:12 < bridge> <cellegenrih> it's all cuz discord didn't have constant functions :troll:
22:13 < bridge> <Ewan> they don't even know what a constant is
22:13 < bridge> <Ewan> electron moment
22:13 < bridge> <Ewan> https://www.humblebundle.com/books/ultimate-c-developer-masterclass-packt-books
22:14 < bridge> <Assa> discord feels like a tractor, more features then you'd expect, very bulky, gets the job done, needs fuel
22:14 < bridge> <Assa> IRC feels like a chariot, will still work in a 1000 years
22:14 < bridge> <Ewan> very true
23:06 < bridge> <Solly (bun bun)> @essigautomat you're assasin tee righ?
23:06 < bridge> <Solly (bun bun)> 
23:07 < bridge> <Solly (bun bun)> ```
23:07 < bridge> <Solly (bun bun)> As I already stated in #9994 , I don't believe small emergency bugfixes or refactorings need their own issue. This would be an instance of the later.
23:07 < bridge> <Solly (bun bun)> ```
23:07 < bridge> <Solly (bun bun)> 
23:07 < bridge> <Solly (bun bun)> I read emergency [bufxies or refactorings] and i was a bit confused because if you give a nullptr youd just get a simple segfault which isn't as dangerous as it could be. Almost all cursors pointed in are created and used once on the stack and since its pretty confusing what the paramter is even meant to be you'd instantly see from examples from elsewhere in code
23:12 < bridge> <robyt3> It's can still be a good idea to open an issue unless you are sure that the refactoring would be accepted, but I don't think we need an issue for every small style problem
23:19 < bridge> <Solly (bun bun)> i guess u could assuem the param is not needed since * and pass in nullptr and thats a bit annoying but not detreminetal
23:30 < bridge> <Assa> I mean [emergency bugfixes] and small refactorings, like renaming stuff or making stuff just follow the style guide without changeing logic
23:30 < bridge> <Solly (bun bun)> I am aware I misread it, it's just what I first read
23:31 < bridge> <Assa> _bugxies_ lmao
23:31 < bridge> <Assa> _bufxies_ lmao
23:32 < bridge> <Solly (bun bun)> They're little fairies that that put bugs in programs and feed on your pain
23:32 < bridge> <Solly (bun bun)> :catuwu:
23:32 < bridge> <Solly (bun bun)> https://cdn.discordapp.com/attachments/293493549758939136/1402041609369026682/image0.gif?ex=68927880&is=68912700&hm=2b3cb72619985fe2202a7fc344e837d1840521802b76130391e3fdff58c5f2a7&
