00:01 < bridge> <xyknz> ```diff
00:01 < bridge> <xyknz> + hello everybody, i just wanna say ty for playing this
00:01 < bridge> <xyknz> ```
00:02 < bridge> <ryozuki> ```diff
00:02 < bridge> <ryozuki> - ok
00:02 < bridge> <ryozuki> ```
00:12 < bridge> <murpi> Any javascript experts?
00:12 < bridge> <murpi> ```<body>
00:12 < bridge> <murpi>     <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
00:12 < bridge> <murpi>     <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
00:12 < bridge> <murpi>     <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
00:12 < bridge> <murpi>     <script>
00:12 < bridge> <murpi>         document.addEventListener('DOMContentLoaded', () => {
00:12 < bridge> <murpi>             const addr = new URLSearchParams(window.location.search).get('addr');
00:12 < bridge> <murpi> 
00:12 < bridge> <murpi>             if (addr) {
00:12 < bridge> <murpi>                 confirmDialog("Would you like to join via Steam or standalone?", (choice) => {
00:12 < bridge> <murpi>                     if (choice) {
00:12 < bridge> <murpi>                         window.location.href = `steam://${addr}`;
00:12 < bridge> <murpi>                     } else {
00:12 < bridge> <murpi>                         window.location.href = `ddnet://${addr}`;
00:12 < bridge> <murpi>                     }
00:13 < bridge> <murpi>                     setTimeout(() => {
00:13 < bridge> <murpi>                         window.close();
00:13 < bridge> <murpi>                 }, 10000);
00:13 < bridge> <murpi>                 });
00:13 < bridge> <murpi>             }
00:13 < bridge> <murpi>         });```
00:13 < bridge> <murpi> I'm trying to close the window once the user selects one of the options. Without the timeout, the code never reaches the stage of actually opening the app. 
00:13 < bridge> <murpi> Any idea how to do this in a more elegant manner?
00:13 < bridge> <murpi> Any javascript experts?
00:13 < bridge> <murpi> ```js
00:13 < bridge> <murpi> <body>
00:13 < bridge> <murpi>     <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
00:13 < bridge> <murpi>     <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
00:13 < bridge> <murpi>     <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
00:13 < bridge> <murpi>     <script>
00:13 < bridge> <murpi>         document.addEventListener('DOMContentLoaded', () => {
00:13 < bridge> <murpi>             const addr = new URLSearchParams(window.location.search).get('addr');
00:13 < bridge> <murpi> 
00:13 < bridge> <murpi>             if (addr) {
00:13 < bridge> <murpi>                 confirmDialog("Would you like to join via Steam or standalone?", (choice) => {
00:13 < bridge> <murpi>                     if (choice) {
00:13 < bridge> <murpi>                         window.location.href = `steam://${addr}`;
00:13 < bridge> <murpi>                     } else {
00:13 < bridge> <murpi>                         window.location.href = `ddnet://${addr}`;
01:30 < bridge> <blaiszephyr> might not be the fix - but isnt window.close restricted to only close windows opened by window.open ?
01:31 < bridge> <blaiszephyr> isnt window.close restricted to only close windows opened by window.open ?
01:35 < bridge> <murpi> Yup, and clicking on a link here on discord calls this function in order to open the link on a new tab
01:35 < bridge> <murpi> ..in your browser
01:36 < bridge> <archimede67> What's the goal of what you are trying to do?
01:37 < bridge> <murpi> Not having to manually close the tab after deciding to open ddnet via steam or standalone.
01:38 < bridge> <archimede67> And where is this decision made and how? You told us something about a link here on discord calling a function?
01:52 < bridge> <murpi> When you click a link on Discord, their JavaScript implementation involves using window.open() to open the designated link. The code I provided is the source code of said link. It redirects the user based on user's choice: standalone, which would be ddnet://${addr} or to Steam, which would be steam://run/412220//${addr}. Essentially, the link runs the application based on the user's selection, and connect the user directly to the server, specified in
01:52 < bridge> <murpi> Does that make sense? 🙂
01:56 < bridge> <blaiszephyr> `window.open('', '_self').close();` ?
01:56 < bridge> <blaiszephyr> `window.open('', '_self').close();`  instead of `window.close()`
01:57 < bridge> <archimede67> Um I don't think so, I believe `window.close()` works, right @murpi ?
01:58 < bridge> <blaiszephyr> aw did i understand the issue wrong again
01:58 < bridge> <murpi> It does, but like I said he code never reaches the stage of actually opening the app because the tab is closed immediately
01:58 < bridge> <murpi> The only way to I found is to set a timeout, but that's not very elegant 😅
01:59 < bridge> <murpi> The only way I found is to set a timeout, but that's not very elegant 😅
01:59 < bridge> <archimede67> Yeah, so I don't think there is really a solution to this other than having to wait for a little bit.
01:59 < bridge> <archimede67> You could try to detect when the window loses focus and then close it, but that might not work reliably enough
02:01 < bridge> <murpi> I'll give it a try
02:04 < bridge> <murpi> That does seem to work quite well 😮  @archimede67 thanks!
02:06 < bridge> <archimede67> Oh that's nice 😄 I'm glad it works!
02:51 < bridge> <heinrich5991> I did. it's pretty neat, considered it for ddnet. it advertises rust support, but barely has any (doesn't work with any project using cargo). doesn't have native integration into msvc unfortunately. also depends on python
02:54 < bridge> <heinrich5991> learned about it
02:55 < bridge> <heinrich5991> sounds like rust might also fit
02:55 < bridge> <heinrich5991> yea, that's actually going under the hood 🙂
02:57 < bridge> <heinrich5991> tokio is standard, yes
03:06 < bridge> <heinrich5991> not sure. I guess haskell is the best you'll get?
03:08 < bridge> <heinrich5991> I like that idea, but deen was opposed to shipping third-party developer's code
03:09 < bridge> <heinrich5991> we do. I see none of the core developers focusing on 0.7
03:09 < bridge> <heinrich5991> I'd wager >80% of our player base is not on linux
03:14 < bridge> <heinrich5991> the hard fork was already done by teeworlds
03:19 < bridge> <heinrich5991> honestly, maybe start by trying teeworlds 0.7 better. if that's impossible, then not much of a point of staying compatible with it
03:31 < bridge> <heinrich5991> are they? only if the tunes are sent while the demo is recorded, no?
03:33 < bridge> <heinrich5991> oof, took a long time to read the backlog
09:08 < bridge> <teero777> Hello 👋
09:19 < bridge> <Jupstar ✪> Good morning
09:21 < bridge> <Jupstar ✪> It was heinrich rewind time again 😬
09:47 < bridge> <ryozuki> :poggers2:
10:20 < bridge> <learath2> I'm also not the biggest fan. Especially for the steam version. If we ever have that sort of launcher you download whatever third party binary you want yourself and put it in there. We should not be involved in that part
10:24 < bridge> <Jupstar ✪> To be clear i didn't mean compiled by tater. I meant a side project by ddnet
10:25 < bridge> <Jupstar ✪> I'd never allow third party binaries
10:26 < bridge> <Jupstar ✪> That's also why i wrote, they'd need to take maintaining more serious
10:38 < bridge> <ryozuki> @learath2 when u continue aoc
10:38 < bridge> <ryozuki> today is interesting
10:38 < bridge> <learath2> Idk why but after the first couple days I always suddenly get bored
10:38 < bridge> <learath2> I'll give it a go today
10:39 < bridge> <ryozuki> thats why im here
10:39 < bridge> <ryozuki> to make u do it
10:39 < bridge> <ryozuki> ill post rust numbers
10:39 < bridge> <ryozuki> my solutions are regex-less btw
10:39 < bridge> <ryozuki> rust having range types in std is epic
10:40 < bridge> <ryozuki> ```rust
10:40 < bridge> <ryozuki>  let src_range = src..(src + len);
10:40 < bridge> <ryozuki>  let dst_range = dst..(dst + len);
10:40 < bridge> <ryozuki> ```
10:40 < bridge> <learath2> Also as we keep getting more and more complex questions I won't be able to beat rust anymore 😄
10:40 < bridge> <ryozuki> xd
10:41 < bridge> <ryozuki> ohh
10:41 < bridge> <ryozuki> the second part of today needs to be done optimized
10:41 < bridge> <ryozuki> xd
10:41 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1181530892208971877/image.png?ex=65816564&is=656ef064&hm=dc616e16861419348669b44a3da1fa30c7f6ecdda0c856ce6c9c2b3e057ffc97&
10:42 < bridge> <ryozuki> i guess its why the 2 randoms havent  solved it yet
10:42 < bridge> <ryozuki> ima beat em
10:42 < bridge> <Jupstar ✪> :brownbear: 
10:42 < bridge> <Jupstar ✪> 5000fps
11:14 < bridge> <reitw> oh lol this creates an array
11:14 < bridge> <reitw> oh lol this creates an array ?
11:14 < bridge> <ryozuki> a Range<T>
11:14 < bridge> <reitw> ah i'm dumb, for loop example
11:14 < bridge> <reitw> for i in 0..10
11:14 < bridge> <reitw> for i in 0..10, same concept
11:14 < bridge> <ryozuki> today second part is more complex lol
11:14 < bridge> <ryozuki> ranges everywhere
11:15 < bridge> <reitw> tbh I didn't have time to do anything, rip
11:15 < bridge> <ryozuki> :justatest: need to fix bugs
11:15 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1181539260071956490/SPOILER_image.png?ex=65816d2f&is=656ef82f&hm=97315eed1251852c1d228e2f93cb2133b8225694c4a5db2ffac36cfb443ba280&
11:26 < bridge> <ryozuki> oh noes
11:26 < bridge> <ryozuki> when the example works but input doesnt
11:26 < bridge> <ryozuki> maybe i should simply bruteforce
11:44 < bridge> <dragere> my bruteforce approach ate all my ram instantly xD
11:44 < bridge> <ryozuki> xd
11:44 < bridge> <ryozuki> i solve the example
11:45 < bridge> <ryozuki> and the input solves instantly but its not correct
11:45 < bridge> <dragere> idk for me it worked both, wanna see the code? (py)
11:46 < bridge> <ryozuki> r u bruteforcing
11:46 < bridge> <ryozuki> im not
11:46 < bridge> <ryozuki> im splitting ranges
11:46 < bridge> <dragere> no
11:46 < bridge> <dragere> same
11:46 < bridge> <ryozuki> i guess im missing some split
11:46 < bridge> <ryozuki> https://gist.github.com/edg-l/bbb089b14a3013f24e6d5427a8257774
11:46 < bridge> <ryozuki> maybe u can find it
11:46 < bridge> <ryozuki> xd
11:46 < bridge> <ryozuki> note its not pretty
11:49 < bridge> <ryozuki> the example doesnt go into the branch where a seed range contains a whole map range
11:49 < bridge> <ryozuki> the input does
11:50 < bridge> <ryozuki> but i checked and looks correct
11:50 < bridge> <ryozuki> the example doesnt go into the branch where a seed range contains more than a whole map range
11:50 < bridge> <ryozuki> actually
11:50 < bridge> <ryozuki> maybe a seed range is so big it encompasses 2 map ranges?
11:50 < bridge> <ryozuki> omg
11:51 < bridge> <ryozuki> i think i know
11:52 < bridge> <ryozuki> lucky im using a deque
11:52 < bridge> <ryozuki> i simply can push front the ranges outside
11:52 < bridge> <ryozuki> and i+1
11:52 < bridge> <ryozuki> ok nothing changed
11:52 < bridge> <ryozuki> gg
11:53 < bridge> <ryozuki> oh
11:53 < bridge> <ryozuki> im dum
11:56 < bridge> <ryozuki> YAY
11:56 < bridge> <ryozuki> i did it
11:56 < bridge> <ryozuki> no bruteforcing
11:56 < bridge> <dragere> gj, what was the problem?
11:56 < bridge> <ryozuki> what i just described
11:57 < bridge> <ryozuki> i wasnt processing again the split ranges outside the mapping
11:57 < bridge> <ryozuki> xd
11:57 < bridge> <dragere> ah
11:57 < bridge> <ryozuki> <https://gist.github.com/edg-l/bbb089b14a3013f24e6d5427a8257774>
11:57 < bridge> <ryozuki> here the working
11:58 < bridge> <ryozuki> 320.6 µs
11:58 < bridge> <ryozuki> ez
12:00 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1181550632553947229/image.png?ex=658177c6&is=656f02c6&hm=e4f33dd1d29b54e2bf5edac34fb8ad65789a038bdb8b6c9a1fd0966240f83a84&
12:00 < bridge> <ryozuki> im first
12:00 < bridge> <ryozuki> :gigachad:
12:13 < bridge> <heinrich5991> yea, was also talking about "compiled by us"
12:14 < bridge> <heinrich5991> the range types don't implement `Copy` which is *very* annoying
12:14 < bridge> <heinrich5991> it infects every struct/enum containing these
12:17 < bridge> <ryozuki> thats true i noticed that xd
12:17 < bridge> <ryozuki> @heinrich5991 do u know why?
12:17 < bridge> <ryozuki> if T is copy
12:18 < bridge> <heinrich5991> because it's implementing iterator and people didn't want it `Copy` for iterators
12:18 < bridge> <heinrich5991> the idea would be to add a lint for it
12:18 < bridge> <heinrich5991> but that issue has been open since 2015, I bet
12:21 < bridge> <Jupstar ✪> well i also mean maintained by ddnet. just with other restrictions.
12:21 < bridge> <Jupstar ✪> 
12:22 < bridge> <Jupstar ✪> Maybe by different people than the current code base.
12:22 < bridge> <Jupstar ✪> 
12:22 < bridge> <Jupstar ✪> By members of the ddnet org.
12:22 < bridge> <Jupstar ✪> 
12:22 < bridge> <Jupstar ✪> But anyway, my point is not so much about who exactly does it anyway.
12:22 < bridge> <Jupstar ✪> I'd just like to see different answers to the same question xd
12:26 < bridge> <learath2> This I'm 100% against. People will offload their forks onto us then we'll be pressured into maintaining it forever when the original author gets bored of maintaining it
12:28 < bridge> <Jupstar ✪> 1. as said, maintaining must be taken more serious
12:28 < bridge> <Jupstar ✪> 2. no, if physics are compatible it can just vanish
12:28 < bridge> <Jupstar ✪> 3. rn we do exactly that. we maintain old versions bcs exactly 1 person in our team wants it
12:29 < bridge> <heinrich5991> we don't maintain old versions
12:29 < bridge> <Jupstar ✪> we maintain the backward compability to old versions
12:29 < bridge> <Jupstar ✪> so we maintain it
12:29 < bridge> <heinrich5991> yes
12:30 < bridge> <Jupstar ✪> so the coder has to make additional thinking,coding etc. in worst case even start a old client
12:30 < bridge> <Jupstar ✪> => we maintain old versions
12:31 < bridge> <learath2> Maintaining 4 entire clients is much different than maintaining 1 spaghetti that supports 4 versions
12:31 < bridge> <Jupstar ✪> no
12:32 < bridge> <Jupstar ✪> ok its different, but not worse
12:32 < bridge> <heinrich5991> I'd also think it's different. maintaining one code base seems a lot easier to me
12:33 < bridge> <Jupstar ✪> but only because you think __you__ have to maintain the other code base too
12:33 < bridge> <Jupstar ✪> i'd say, i'd not maintain ddnet if there is an alternative that is more flexible
12:33 < bridge> <learath2> I'd argue it's worse since the spaghetti usually doesn't need touching. Yes it makes reading the code awful, but as long as you aren't directly touching that part it's fine.
12:33 < bridge> <learath2> 
12:33 < bridge> <learath2> An entire fork offloaded to us needs to be kept up to date forever
12:34 < bridge> <Jupstar ✪> the problem is. ppl touch it. we often merge half finished stuff (IMHO)
12:34 < bridge> <Jupstar ✪> 
12:34 < bridge> <Jupstar ✪> which just makes the code even worse
12:35 < bridge> <learath2> Hm, could you remind me of some?
12:35 < bridge> <learath2> The recent changes I remember are all either refactors or bugfixes that don't touch any of the backwards compat
12:37 < bridge> <Jupstar ✪> killmsgs for finishes
12:37 < bridge> <Jupstar ✪> streamer mode (the way it's done)
12:37 < bridge> <Jupstar ✪> we often have prediction conflicts between mods
12:37 < bridge> <Jupstar ✪> 
12:37 < bridge> <Jupstar ✪> i dunno there are so many i can't even list all
12:37 < bridge> <Jupstar ✪> pretty much every new feature is a if branch with 2 ways
12:37 < bridge> <Jupstar ✪> put directly into the code
12:38 < bridge> <Jupstar ✪> it's not designed, it's just coded to work
12:38 < bridge> <ryozuki> i personally dont start old clients, i dont even test if old clients work i just test the current
12:39 < bridge> <Jupstar ✪> i basically never touched network code, bcs i feel very uncomfortable touching it
12:39 < bridge> <learath2> Streamer mode I didn't like either ngl. I wouldn't have merged it 😄
12:39 < bridge> <Jupstar ✪> btw i am not saying the features suck. for me it's about for it interacts with the code base
12:39 < bridge> <Jupstar ✪> just to be clear about that
12:39 < bridge> <learath2> Killmsgs are implemented like this not because of very long backwards compatibility though. Implemented naively they would break even the last version
12:40 < bridge> <Jupstar ✪> but in 2 versions we could remove such code then
12:40 < bridge> <learath2> I think even you don't support breaking every version that isn't the latest
12:40 < bridge> <ryozuki> well atleast it looks like we got some new devs (?) or it seemed like we got 1 or 2
12:40 < bridge> <Jupstar ✪> my point isnt about NO backward compability. it's about keeping it for ever
12:40 < bridge> <ryozuki> cuz it feels like we are all same for years xd
12:40 < bridge> <ryozuki> thats what may truly kill ddnet
12:41 < bridge> <learath2> It'll only take one controversial change for them to disappear 😄
12:41 < bridge> <ryozuki> time to make a monthly pr
12:41 < bridge> <ryozuki> so i feel like i havent abandoned this xd
12:41 < bridge> <ryozuki> meh, but u gotta go through that kinda
12:41 < bridge> <learath2> Tbh, I do agree. We keep way too compatible with ANCIENT versions
12:42 < bridge> <ryozuki> the problem is new devs usually make features that are BIG CHANGES, or NEW TILES
12:42 < bridge> <ryozuki> and not a simple subtle change
12:42 < bridge> <ryozuki> so obviously they will get lot of talk
12:42 < bridge> <learath2> We support a serverinfo packet that was developed by fstd, for one implementation of ddrace64 that no one has used in 7 years
12:43 < bridge> <ryozuki> true
12:43 < bridge> <ryozuki> drop it
12:43 < bridge> <Ewan> howdy fellas
12:43 < bridge> <ryozuki> hi fellow american
12:43 < bridge> <ryozuki> among europeans
12:43 < bridge> <Ewan> midl is making me want to pull my hair out
12:43 < bridge> <ryozuki> what midl
12:43 < bridge> <ryozuki> lidl?
12:43 < bridge> <Ewan> oop was a mistake
12:43 < bridge> <Ewan> no
12:43 < bridge> <learath2> Or that one hack with "crashmeplx"
12:43 < bridge> <Ewan> Microsoft interface design language
12:43 < bridge> <ryozuki> we dont do that here
12:43 < bridge> <ryozuki> gentoo make language
12:44 < bridge> <Ewan> teeworlds kernel actually implement rly similar ideas
12:44 < bridge> <ryozuki> @learath2 do u have master track upstream master instead of origin?
12:44 < bridge> <ryozuki> i wanna do that, but im afraid of mistakenly pushing, idk if i can push to main tho
12:44 < bridge> <ryozuki> rn i just git reset with upstream master
12:44 < bridge> <ryozuki> ❯ git remote -v
12:44 < bridge> <ryozuki> origin    git@github.com:edg-l/ddnet.git (fetch)
12:44 < bridge> <ryozuki> origin    git@github.com:edg-l/ddnet.git (push)
12:44 < bridge> <ryozuki> upstream    git@github.com:ddnet/ddnet.git (fetch)
12:44 < bridge> <ryozuki> upstream    git@github.com:ddnet/ddnet.git (push)
12:45 < bridge> <Ewan> difference between upstream/master and origin?
12:45 < bridge> <Ewan> they represent the same remote
12:45 < bridge> <heinrich5991> ddnet/ vs edg-l/
12:45 < bridge> <Ewan> oh yea
12:45 < bridge> <Ewan> fork moment
12:46 < bridge> <heinrich5991> `git merge upstream/master --ff-only`
12:46 < bridge> <Jupstar ✪> anyway, i'd like to see an alternative on how we handle things anyway.
12:46 < bridge> <Jupstar ✪> 
12:46 < bridge> <Jupstar ✪> it seems like heinrich and i disagree on pretty much everything sadly.
12:46 < bridge> <Jupstar ✪> 
12:46 < bridge> <Jupstar ✪> deen said to me, if database is compatible he allows breaking compability. he even gave me a branch in steam to test it out at some point
12:46 < bridge> <heinrich5991> sounds safe than `git reset` to me
12:46 < bridge> <learath2> This is what I do too
12:46 < bridge> <heinrich5991> sounds safer than `git reset` to me
12:46 < ChillerDragon> fixed the perma link in an edit btw heinrich
12:46 < bridge> <Ewan> git reset --hard upstream/master is a major crutch
12:46 < bridge> <ryozuki> nono, i want to set my master to track upstream/master, so i just do git pull and it does git pull upstream master
12:46 < bridge> <learath2> I never have my master tracking upstream master, it's just unnecessary risk
12:46 < bridge> <Jupstar ✪> i hope that i finish my first very basic version within the next 4 months.
12:46 < bridge> <Jupstar ✪> 
12:46 < bridge> <Jupstar ✪> so you'll hear of this idea more often sooner or later from me anyway
12:46 < bridge> <ryozuki> thought so
12:47 < bridge> <ryozuki> btw any of u uses ccache
12:47 < bridge> <heinrich5991> I never use bare `git pull` or bare `git push`
12:47 < bridge> <Ewan> anyone here use nuget with cmake
12:47 < bridge> <Jupstar ✪> and if the community/moders whatever dislikes it. i am also ok with rq xdd
12:47 < bridge> <Jupstar ✪> 
12:47 < bridge> <Jupstar ✪> but at least test it out
12:47 < bridge> <ryozuki> ```
12:47 < bridge> <ryozuki> ❯ ccache -s
12:47 < bridge> <ryozuki> Cacheable calls:   26205 / 31963 (81.99%)
12:47 < bridge> <ryozuki>   Hits:             4479 / 26205 (17.09%)
12:47 < bridge> <ryozuki>     Direct:         4129 /  4479 (92.19%)
12:47 < bridge> <ryozuki>     Preprocessed:    350 /  4479 ( 7.81%)
12:47 < bridge> <ryozuki>   Misses:          21726 / 26205 (82.91%)
12:48 < bridge> <ryozuki> Uncacheable calls:  5758 / 31963 (18.01%)
12:48 < bridge> <ryozuki> Local storage:
12:48 < bridge> <ryozuki>   Cache size (GB):   8.2 /  50.0 (16.43%)
12:48 < bridge> <ryozuki>   Hits:             4479 / 26205 (17.09%)
12:48 < bridge> <ryozuki>   Misses:          21726 / 26205 (82.91%)
12:48 < bridge> <ryozuki> ```
12:48 < bridge> <ryozuki> this after compiling llvm several times after making my pr
12:48 < bridge> <ryozuki> im just bad at caches right
12:48 < bridge> <learath2> I prefer `fetch`+`merge`/`reset` to `pull`
12:48 < bridge> <heinrich5991> yea, me too
12:49 < bridge> <learath2> Idk what you'd replace with `push` tho. What do you do?
12:49 < bridge> <heinrich5991> just mean the bare version without any parameters
12:49 < bridge> <learath2> `push` with*
12:49 < bridge> <Ewan> i love that cmake is able to interface with package managers but i do not love how vague it is... i get absolutely no word from the nuget cmake logic but obviously something is going wrong. my project is not finding a header explicitly included in one of my dependency nuget pkgs i set in cmake
12:49 < bridge> <learath2> Ah, yep, never touch those
12:49 < bridge> <heinrich5991> @chillerdragon code review
12:49 < bridge> <heinrich5991> https://github.com/chillerbot/chillerbot-ux/blob/aa36a7e0d434151ce90d44efed86133fe70e0ef0/src/chillerbot-rs/unicode.rs#L40
12:50 < bridge> <heinrich5991> should not fall back to empty string on invalid utf-8, it should probably rather crash
12:50 < bridge> <heinrich5991> https://github.com/chillerbot/chillerbot-ux/blob/aa36a7e0d434151ce90d44efed86133fe70e0ef0/src/chillerbot-rs/unicode.rs#L43
12:50 < bridge> <heinrich5991> should not truncate the variable, should rather crash
12:50 < bridge> <heinrich5991> i.e. `.try_into().unwrap()`
12:50 < bridge> <ryozuki> CStr doesnt do anything on drop right
12:50 < bridge> <heinrich5991> correct
12:50 < bridge> <ryozuki> unsafe needs to take care of panic safety
12:51 < bridge> <ryozuki> well just return a result
12:51 < bridge> <ryozuki> or option
12:51 < bridge> <heinrich5991> can't, across FFI boundary
12:51 < bridge> <Ewan> why not
12:51 < bridge> <ryozuki> ah true
12:51 < bridge> <ryozuki> @mpft option is not ffi safe
12:51 < bridge> <ryozuki> enums itself do quite lot of magic
12:52 < bridge> <heinrich5991> try taking a `StrRef` instead of a `*const c_char`
12:52 < bridge> <heinrich5991> I explicitly added the type for easy interoparability with C++
12:52 < bridge> <ryozuki> @heinrich5991 btw do u know how to make a value that cant be initialized in rust
12:52 < bridge> <learath2> Is there no wrapper for it in terms of `std::optional`?
12:52 < bridge> <Ewan> that is what i am thinking
12:52 < bridge> <ryozuki> i learnt this looking at lot of ffi crates
12:52 < bridge> <heinrich5991> https://cxx.rs/bindings.html
12:52 < bridge> <ryozuki> i would say c++ std::optional is not ffi safe
12:52 < bridge> <ryozuki> xd
12:52 < bridge> <heinrich5991> doesn't seem so
12:52 < bridge> <Ewan> weird
12:53 < bridge> <ryozuki> why weird?
12:53 < bridge> <heinrich5991> wdym, can't be initialized?
12:53 < bridge> <ryozuki> @heinrich5991
12:53 < bridge> <ryozuki> ```rust
12:53 < bridge> <ryozuki> pub enum MyFFIOpaqueStruct {}
12:53 < bridge> <ryozuki> ```
12:53 < bridge> <ryozuki> llvm-sys does this
12:53 < bridge> <ryozuki> u cant initialize this in rust
12:53 < bridge> <heinrich5991> that's probably* bad
12:53 < bridge> <ryozuki> why
12:53 < bridge> <heinrich5991> that's *probably* bad
12:53 < bridge> <ryozuki> i think cbindgen does it
12:54 < bridge> <ryozuki> llvm-sys is autogenerated
12:54 < bridge> <heinrich5991> because you're telling the compiler that this type cannot be instantiated by anyone
12:54 < bridge> <heinrich5991> i.e. if you have an instance, it's instant UB
12:54 < bridge> <ryozuki> it exists
12:54 < bridge> <ryozuki> i saw some docs
12:54 < bridge> <ryozuki> empty type or smth
12:54 < bridge> <ryozuki> let me search
12:54 < bridge> <heinrich5991> yes
12:54 < bridge> <heinrich5991> it's like !
12:54 < bridge> <heinrich5991> but you should probably not use it
12:55 < bridge> <ryozuki> https://doc.rust-lang.org/nomicon/exotic-sizes.html#empty-types
12:55 < bridge> <ryozuki> > Rust also enables types to be declared that cannot even be instantiated. These types can only be talked about at the type level, and never at the value level. Empty types can be declared by specifying an enum with no variants:
12:55 < bridge> <ryozuki> > 
12:55 < bridge> <ryozuki> > enum Void {} // No variants = EMPTY
12:55 < bridge> <ryozuki> > 
12:55 < bridge> <ryozuki> > Empty types are even more marginal than ZSTs. The primary motivating example for an empty type is type-level unreachability. For instance, suppose an API needs to return a Result in general, but a specific case actually is infallible. It's actually possible to communicate this at the type level by returning a Result<T, Void>. Consumers of the API can confidently unwrap such a Result knowing that it's statically impossible for this value to be an 
12:55 < bridge> <ryozuki> > 
12:55 < bridge> <ryozuki> > In principle, Rust can do some interesting analyses and optimizations based on this fact. For instance, Result<T, Void> is represented as just T, because the Err case doesn't actually exist (strictly speaking, this is only an optimization that is not guaranteed, so for example transmuting one into the other is still Undefined Behavior).
12:56 < bridge> <ryozuki> @heinrich5991 
12:56 < bridge> <ryozuki> > One final subtle detail about empty types is that raw pointers to them are actually valid to construct, but dereferencing them is Undefined Behavior because that wouldn't make sense.
12:56 < bridge> <ryozuki> > 
12:56 < bridge> <ryozuki> > We recommend against modelling C's void* type with *const Void. A lot of people started doing that but quickly ran into trouble because Rust doesn't really have any safety guards against trying to instantiate empty types with unsafe code, and if you do it, it's Undefined Behavior. This was especially problematic because developers had a habit of converting raw pointers to references and &Void is also Undefined Behavior to construct.
12:56 < bridge> <heinrich5991> read on to see the comments I gave against using it like that
12:56 < bridge> <ryozuki> this is the important part
12:56 < bridge> <ryozuki> raw pointers to them are actually valid to construct
12:56 < bridge> <heinrich5991> yes, because raw pointers don't do anything
12:56 < bridge> <heinrich5991> try to use a struct with private fields instead, I guess
12:56 < bridge> <learath2> Well the cxx crate allows stuff like unique_ptr and shared_ptr to make it through. I thought one could similarly translate an Option
12:56 < bridge> <heinrich5991> it's also non-constructible from the outside
12:57 < bridge> <ryozuki> https://docs.rs/llvm-sys/latest/llvm_sys/target_machine/enum.LLVMTarget.html
12:57 < bridge> <Ewan> why would you want this
12:57 < bridge> <ryozuki> ```
12:57 < bridge> <ryozuki> #[derive(Debug)]
12:57 < bridge> <ryozuki> pub enum LLVMTarget {}
12:57 < bridge> <ryozuki> 
12:57 < bridge> <ryozuki> pub type LLVMTargetRef = *mut LLVMTarget;
12:57 < bridge> <ryozuki> ```
12:57 < bridge> <ryozuki> they do this
12:57 < bridge> <heinrich5991> sounds like a bad idea
12:57 < bridge> <Ewan> it's literally ub
12:57 < bridge> <heinrich5991> see above ^^
12:57 < bridge> <ryozuki> its not, because the pointer is returned from c++
12:57 < bridge> <heinrich5991> > We recommend against modelling C's void* type with *const Void. A lot of people started doing that but quickly ran into trouble because Rust doesn't really have any safety guards against trying to instantiate empty types with unsafe code, and if you do it, it's Undefined Behavior. This was especially problematic because developers had a habit of converting raw pointers to references and &Void is also Undefined Behavior to construct.
12:57 < bridge> <ryozuki> this is about rust ffi
12:57 < bridge> <heinrich5991> the same applies to your case
12:58 < bridge> <ryozuki> its meant to represent a opaque structure
12:58 < bridge> <heinrich5991> yes, and it's a bad idea
12:58 < bridge> <ryozuki> then why do they do it xd
12:58 < bridge> <heinrich5991> I don't know. legacy reasons?
12:58 < bridge> <Ewan> well what's the alternative
12:58 < bridge> <heinrich5991> .
12:58 < bridge> <Ewan> well it seems wasteful
12:58 < bridge> <Ewan> those fields will never be used. it's the point
12:59 < bridge> <heinrich5991> why is it wasteful to have a field at compile time?
12:59 < bridge> <ryozuki> ok it doesnt use cbindgen
12:59 < bridge> <ryozuki> idk
12:59 < bridge> <ryozuki> rust has zero sized types
12:59 < bridge> <Ewan> oh
13:00 < bridge> <Ewan> nvm then
13:00 < bridge> <ryozuki> ```rust
13:00 < bridge> <ryozuki> struct A {
13:00 < bridge> <ryozuki>   b: ()
13:00 < bridge> <ryozuki> }
13:00 < bridge> <ryozuki> ```
13:00 < bridge> <ryozuki> https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts
13:00 < bridge> <learath2> Honestly this looks much sillier to me even if it might be better practice
13:00 < bridge> <ryozuki> > On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless. However as with many curious layout choices in Rust, their potential is realized in a generic context: Rust largely understands that any operation that produces or stores a ZST can be reduced to a no-op. First off, storing it doesn't even make sense -- it doesn't occupy any space. Also there's only one value of that type, so anything that loads it can just produce it 
13:00 < bridge> <ryozuki> > 
13:00 < bridge> <ryozuki> > One of the most extreme examples of this is Sets and Maps. Given a Map<Key, Value>, it is common to implement a Set<Key> as just a thin wrapper around Map<Key, UselessJunk>. In many languages, this would necessitate allocating space for UselessJunk and doing work to store and load UselessJunk only to discard it. Proving this unnecessary would be a difficult analysis for the compiler.
13:00 < bridge> <ryozuki> > 
13:00 < bridge> <ryozuki> > However in Rust, we can just say that Set<Key> = Map<Key, ()>. Now Rust statically knows that every load and store is useless, and no allocation has any size. The result is that the monomorphized code is basically a custom implementation of a HashSet with none of the overhead that HashMap would have to support values.
13:00 < bridge> <ryozuki> > 
13:00 < bridge> <ryozuki> > Safe code need not worry about ZSTs, but unsafe code must be careful about the consequence of types with no size. In particular, pointer offsets are no-ops, and allocators typically require a non-zero size.
13:01 < bridge> <ryozuki> > 
13:01 < bridge> <ryozuki> > Note that references to ZSTs (including empty slices), just like all other references, must be non-null and suitably aligned. Dereferencing a null or unaligned pointer to a ZST is undefined behavior, just like for any other type.
13:01 < bridge> <ryozuki> idk the actual best practice rn
13:01 < bridge> <ryozuki> i need to investigate
13:01 < bridge> <heinrich5991> `_non_constructible: ()` seems about right to me
13:01 < bridge> <heinrich5991> you can also do `#[non_exhaustive]` these days IIRC
13:01 < bridge> <heinrich5991> on a struct
13:01 < bridge> <ryozuki> what does it do
13:01 < bridge> <ryozuki> i guess best practices is whathever cxx generates
13:01 < bridge> <heinrich5991> it's like pretending there's another field you can't name
13:01 < bridge> <ryozuki> or cbindgen
13:01 < bridge> <heinrich5991> generally, no
13:01 < bridge> <learath2> `*const Void` is such an intuitive way to model it except for the facy that you can instantiate empty types with unsafe
13:02 < bridge> <heinrich5991> because code generators can change in the future if there's a problem
13:02 < bridge> <heinrich5991> your code won't
13:02 < bridge> <heinrich5991> so you shouldn't rely on dodgy tricks
13:02 < bridge> <heinrich5991> that work with one compiler version but not with another
13:02 < bridge> <learath2> fact*
13:03 < bridge> <heinrich5991> I think `c_void` is actually modeled as an empty struct these days
13:03 < bridge> <heinrich5991> https://doc.rust-lang.org/src/core/ffi/mod.rs.html#209
13:03 < bridge> <heinrich5991> https://doc.rust-lang.org/std/ffi/enum.c_void.html
13:03 < bridge> <heinrich5991> hmm, seems to be modeled as a two-value enum
13:03 < bridge> <heinrich5991> that sounds super strange ^^
13:04 < bridge> <heinrich5991> I guess it could be updated to use the struct variant
13:04 < bridge> <ryozuki> u can(tm) but its UB
13:04 < bridge> <ryozuki> nvm
13:04 < bridge> <ryozuki> i didnt read correctly
13:04 < bridge> <heinrich5991> but it's easy to get UB
13:04 < bridge> <ryozuki> XD
13:04 < bridge> <heinrich5991> it isn't instant UB
13:04 < bridge> <Ewan> im wondering why you can't just have some sort of annotation for an explicitly empty structure to represent an opaque struct, where dereferencing results in a panic or smth. unless, that sort of infrastructure is not in place?
13:04 < bridge> <ryozuki> ```rust
13:04 < bridge> <ryozuki> pub enum c_void {
13:04 < bridge> <ryozuki>     #[unstable(
13:04 < bridge> <ryozuki>         feature = "c_void_variant",
13:04 < bridge> <ryozuki>         reason = "temporary implementation detail",
13:04 < bridge> <ryozuki>         issue = "none"
13:04 < bridge> <ryozuki>     )]
13:05 < bridge> <ryozuki>     #[doc(hidden)]
13:05 < bridge> <ryozuki>     __variant1,
13:05 < bridge> <ryozuki>     #[unstable(
13:05 < bridge> <ryozuki>         feature = "c_void_variant",
13:05 < bridge> <ryozuki>         reason = "temporary implementation detail",
13:05 < bridge> <ryozuki>         issue = "none"
13:05 < bridge> <ryozuki>     )]
13:05 < bridge> <ryozuki>     #[doc(hidden)]
13:05 < bridge> <ryozuki>     __variant2,
13:05 < bridge> <ryozuki> }
13:05 < bridge> <ryozuki> 
13:05 < bridge> <ryozuki> ```
13:05 < bridge> <learath2> Bizarre
13:05 < bridge> <learath2> I wonder why the 2 variants
13:05 < bridge> <heinrich5991> `#[non_exhaustive]` pretty much does this, except for the panicking
13:05 < bridge> <ryozuki> ```rust
13:05 < bridge> <ryozuki> #[doc = include_str!("c_void.md")]
13:05 < bridge> <ryozuki> #[lang = "c_void"]
13:05 < bridge> <ryozuki> #[cfg_attr(not(doc), repr(u8))] // work around https://github.com/rust-lang/rust/issues/90435
13:05 < bridge> <ryozuki> #[stable(feature = "core_c_void", since = "1.30.0")]
13:05 < bridge> <ryozuki> pub enum c_void {
13:05 < bridge> <ryozuki>     #[unstable(
13:05 < bridge> <ryozuki>         feature = "c_void_variant",
13:05 < bridge> <ryozuki>         reason = "temporary implementation detail",
13:05 < bridge> <ryozuki>         issue = "none"
13:05 < bridge> <ryozuki>     )]
13:05 < bridge> <ryozuki>     #[doc(hidden)]
13:05 < bridge> <ryozuki>     __variant1,
13:05 < bridge> <ryozuki>     #[unstable(
13:05 < bridge> <ryozuki>         feature = "c_void_variant",
13:05 < bridge> <ryozuki>         reason = "temporary implementation detail",
13:06 < bridge> <ryozuki>         issue = "none"
13:06 < bridge> <ryozuki>     )]
13:06 < bridge> <ryozuki>     #[doc(hidden)]
13:06 < bridge> <ryozuki>     __variant2,
13:06 < bridge> <ryozuki> }
13:06 < bridge> <ryozuki> 
13:06 < bridge> <ryozuki> ```
13:06 < bridge> <heinrich5991> otherwise it'd be a zero-sized type
13:06 < bridge> <heinrich5991> with its own warts
13:06 < bridge> <ryozuki> ```rust
13:06 < bridge> <ryozuki> #[lang = "va_list"]
13:06 < bridge> <ryozuki> pub struct VaListImpl<'f> {
13:06 < bridge> <ryozuki>     ptr: *mut c_void,
13:06 < bridge> <ryozuki> 
13:06 < bridge> <ryozuki>     // Invariant over `'f`, so each `VaListImpl<'f>` object is tied to
13:06 < bridge> <ryozuki>     // the region of the function it's defined in
13:06 < bridge> <ryozuki>     _marker: PhantomData<&'f mut &'f c_void>,
13:06 < bridge> <ryozuki> }
13:06 < bridge> <ryozuki> ```
13:06 < bridge> <ryozuki> interesting xd
13:06 < bridge> <ryozuki> ah cuz with 1 its optimized right
13:07 < bridge> <heinrich5991> yes
13:07 < bridge> <heinrich5991> note the `#[lang = "…"]`
13:07 < bridge> <heinrich5991> it means you can't trust what's in there at all
13:07 < bridge> <heinrich5991> it's a lang item
13:10 < bridge> <Ewan> midl still not cooperating :feelsbadman:
13:10 < bridge> <Ewan> this is a microsoft moment
13:10 < bridge> <Ewan> i leave my app alone and icome back to it the next day and it has some insane build error that i have no idea the origin of
13:11 < bridge> <Ewan> i hate to generalize so much but this is actually what it's like working anywhere in the ms software sphere
13:11 < bridge> <Ewan> things just breaking all the time
13:12 < bridge> <heinrich5991> @ryozuki about best practice btw:
13:12 < bridge> <heinrich5991> > To model pointers to opaque types in FFI, until extern type is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the Nomicon for details.
13:12 < bridge> <ryozuki> i see
13:12 < bridge> <heinrich5991> https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs
13:12 < bridge> <heinrich5991> > Notice that it is a really bad idea to use an empty enum as FFI type. The compiler relies on empty enums being uninhabited, so handling values of type &Empty is a huge footgun and can lead to buggy program behavior (by triggering undefined behavior).
13:13 < bridge> <ryozuki> llvm-sys is on gitlab
13:13 < bridge> <ryozuki> too lazy to tell them
13:16 < bridge> <ryozuki> @jupeyy_keks when c++200
13:16 < bridge> <ryozuki> 20
13:17 < ChillerDragon> @heinrich5991 i rather have a misaligned menu than a crashed client. Not crashing is nice.
13:18 < bridge> <Ewan> well you shouldn't crash xd. you should handle the fault in another way
13:18 < bridge> <Ewan> in a perfect world
13:19 < bridge> <heinrich5991> ChillerDragon: the idea is that it shouldn't crash. but you should notice when invariants are violated
13:19 < bridge> <Jupstar ✪> i'm done being a cpp enthusiast. now i ask "when rust nightly"
13:19 < bridge> <Jupstar ✪> 
13:19 < bridge> <Jupstar ✪> 😬
13:19 < bridge> <ryozuki> xd
13:19 < bridge> <heinrich5991> because otherwise you'll hide bugs
13:20 < bridge> <heinrich5991> your idea is like stripping out all `dbg_assert`s in code
13:21 < bridge> <Ewan> yes but what does dbg_assert do at the end of the day
13:21 < bridge> <Jupstar ✪> but yeah, dunno.
13:21 < bridge> <Jupstar ✪> i think deen gave up for now. which is understandable. ubuntu has other release schedules than debian
13:21 < bridge> <Jupstar ✪> 
13:21 < bridge> <Jupstar ✪> so his debian distro is newer than the min. ubuntu we target.
13:21 < bridge> <Jupstar ✪> 
13:21 < bridge> <Jupstar ✪> That's why he tried all the libc hacks, which apparently didnt work out
13:22 < bridge> <ryozuki> was looking at some small component in ddnet to port to rust
13:22 < bridge> <Jupstar ✪> => when old ubuntu drops
13:22 < bridge> <ryozuki> but idk what to tbh
13:22 < ChillerDragon> i think dbg assert is nice if otherwise you run into bad logic issues. But misaligning a menu is not a bad logic issue. I prefer a stable client in that case.
13:22 < bridge> <heinrich5991> this is how you accumulate bugs
13:22 < bridge> <Ewan> could u  port jobs
13:22 < bridge> <heinrich5991> without noticing
13:22 < ChillerDragon> yea
13:23 < bridge> <ryozuki> i can try
13:23 < bridge> <ryozuki> gotta learn how the bridge works xd
13:23 < bridge> <Ewan> yea
13:23 < bridge> <Ewan> idk if the bridge even supports that api rn tho
13:23 < bridge> <heinrich5991> shoud probably not port jobs rn
13:24 < bridge> <heinrich5991> Learath2 is working on that with the async http PR
13:24 < bridge> <heinrich5991> Learath2 is working on that part of the code with the async http PR
13:24 < bridge> <Ewan> nice
13:24 < bridge> <Jupstar ✪> u could do the http async in rust 😂
13:24 < bridge> <ryozuki> ```
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_GETINFO[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'g', 'i', 'e', '3'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'n', 'f', '3'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_GETINFO_64_LEGACY[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'f', 's', 't', 'd'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_64_LEGACY[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'd', 't', 's', 'f'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_EXTENDED[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'e', 'x', 't'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_EXTENDED_MORE[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'e', 'x', '+'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_CHALLENGE[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'c', 'h', 'a', 'l'};
13:25 < bridge> <ryozuki> ```
13:25 < bridge> <ryozuki> we should remove legacy
13:25 < bridge> <Jupstar ✪> would save you lot of trouble
13:25 < bridge> <ryozuki> ```cpp
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_GETINFO[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'g', 'i', 'e', '3'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'n', 'f', '3'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_GETINFO_64_LEGACY[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'f', 's', 't', 'd'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_64_LEGACY[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'd', 't', 's', 'f'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_EXTENDED[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'e', 'x', 't'};
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_INFO_EXTENDED_MORE[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'i', 'e', 'x', '+'};
13:25 < bridge> <ryozuki> 
13:25 < bridge> <ryozuki> const unsigned char SERVERBROWSE_CHALLENGE[SERVERBROWSE_SIZE] = {255, 255, 255, 255, 'c', 'h', 'a', 'l'};
13:25 < bridge> <ryozuki> ```
13:25 < bridge> <ryozuki> ye its perfect fit xd
13:27 < bridge> <Ewan> i think that would mostly come with jobs
13:27 < bridge> <Ewan> just have to integrate with libcurl
13:27 < bridge> <learath2> Jobs in rust is a bad bad bad idea. Most of the code is in C++ it'd be so annoying to interface
13:27 < bridge> <Ewan> i suppose
13:27 < bridge> <ryozuki> yeah
13:27 < bridge> <ryozuki> its why its simply annoying / rly bothersome to use rust anywhere :7
13:28 < bridge> <ryozuki> which is why we havent done anything in rust
13:28 < bridge> <Jupstar ✪> but jobs are blocking
13:28 < bridge> <ryozuki> as much as im a pro rust, if we dont do anything with it its better to remove it
13:28 < bridge> <learath2> The http thing could be in rust actually. But someone else should do it. If I rewrite this part of the code once more I'll go insane
13:28 < bridge> <ryozuki> mastersrv is nice in rust tho
13:28 < bridge> <Ewan> yes but job scheduler puts them on their own thread i thought?
13:28 < bridge> <Jupstar ✪> yep, but it cannot await, yield them
13:29 < bridge> <Jupstar ✪> so u end up blocking a full thread
13:29 < bridge> <Jupstar ✪> c++ has future concept, but we dont use it
13:29 < bridge> <Ewan> yea lol
13:29 < bridge> <Ewan> cpp has many many async features
13:30 < bridge> <learath2> Actually not all that awful. There is much discussion on whether running many threads and letting the cpu scheduler/kernel take care of it vs having a userspace scheduler
13:30 < bridge> <Ewan> that you could make great use of
13:30 < bridge> <Jupstar ✪> that's true, i also read about this very often.
13:31 < bridge> <Jupstar ✪> but it still means we have to make our jobs different. e.g. by spawning threads or smth
13:31 < bridge> <Ewan> it certainly depends on what you’re doing
13:31 < bridge> <learath2> Biggest issue is our jobs api imo. It's not great to use currently
13:31 < bridge> <Jupstar ✪> bcs they will devs block a thread regardless xD
13:31 < bridge> <Jupstar ✪> bcs they will defs block a thread regardless xD
13:32 < bridge> <learath2> It'd be nice if we had futures like in folly. With chaining possible on both the same thread or on the calling thread or on a new thread with a nice simple interface powered by templates
13:32 < bridge> <Ewan> having to implement a whole class for a new job isn’t awesome. i envision an api where you just give it a function pointer and maybe it has some native thread safe interop. but then i realize this is closer to the c way that we want to avoid
13:33 < bridge> <ryozuki> imagine having rust send and sync traits
13:33 < bridge> <Ewan> embracing cpp features tho u could easily transparently wrap the thread apis so you just pass it a lambda and it’s all inlined. vastly simpler
13:33 < bridge> <learath2> I had a `CGenericJob` that was a template that could take any function, for a bit, but then I rewrote without it
13:33 < bridge> <Jupstar ✪> xdd
13:34 < bridge> <Jupstar ✪> no normal discussions anymore without mentioning rust
13:34 < bridge> <Jupstar ✪> i like that
13:34 < bridge> <ryozuki> well thats just me being me xd
13:34 < bridge> <Ewan> :feelsbadman:
13:34 < bridge> <Ewan> sleepy just kicked in
13:34 < bridge> <Ewan> but i cannot sleep until i tame the midl compiler
13:34 < bridge> <Ewan> and by extension the xaml compiler
13:34 < bridge> <Ewan> and then my thing will compile
13:35 < bridge> <learath2> I actually have the http thing done but it needs some debugging for a couple things
13:36 < bridge> <Ewan> memo: winui is very hard to use with C++ alone, even harder when you leave the bounds of Microsoft’s build system and use cmake. it would genuinely be easier to use C# and a VS solution and just use p/invoke for what im doing. its not worth it
13:36 < bridge> <learath2> I didn't end up touching jobs at all and made http jobs completely separate because noone seemed to like my runners 😄
13:36 < bridge> <Ewan> damn
13:36 < bridge> <ryozuki> anyone has a easy bug i can fix
13:36 < bridge> <ryozuki> idk what to do
13:37 < bridge> <ryozuki> got 1 hour and half before i go
13:37 < bridge> <ryozuki> :sadboi:
13:37 < bridge> <Ewan> fix my .idl
13:37 < bridge> <learath2> Check editor bugs those are usually trivial
13:37 < bridge> <Jupstar ✪> add some test code
13:37 < bridge> <ryozuki> if code needs testing it means code is bad 😬
13:38 < bridge> <ryozuki> ok i wanted to make a joke
13:38 < bridge> <Jupstar ✪> based
13:38 < bridge> <ryozuki> like ppl who say if code needs comments its bad or smth
13:38 < bridge> <Jupstar ✪> real coders would not add bugs
13:38 < bridge> <ryozuki> true
13:38 < bridge> <ryozuki> real coders also dont add UB
13:38 < bridge> <learath2> Me
13:38 < bridge> <ryozuki> or memory safety issues
13:38 < bridge> <ryozuki> ever
13:38 < bridge> <ryozuki> in their life
13:38 < bridge> <ryozuki> career
13:38 < bridge> <learath2> Also me
13:39 < bridge> <ryozuki> btw
13:39 < bridge> <learath2> Last time I invoked UB I was 10yo
13:39 < bridge> <ryozuki> i added a leak in test code when making the pr on llvm XD
13:39 < bridge> <ryozuki> i forgot to add a LLVMContextDispose at end of test code
13:39 < bridge> <ryozuki> the worst is
13:39 < bridge> <ryozuki> their github CI didnt pick it up
13:40 < bridge> <ryozuki> but their buildbot CI did after it merged
13:40 < bridge> <ryozuki> so they did a reverse
13:40 < bridge> <ryozuki> and then fixed
13:40 < bridge> <ryozuki> and back
13:40 < bridge> <ryozuki> xd
13:40 < bridge> <Jupstar ✪> uff
13:40 < bridge> <ryozuki> c++ in a nutshell
13:40 < bridge> <Jupstar ✪> that's why i like RAII
13:40 < bridge> <Ewan> so true
13:40 < bridge> <ryozuki> yeah i was working with the C api
13:40 < bridge> <ryozuki> not c++
13:40 < bridge> <ryozuki> so i needed to call all those disposes
13:40 < bridge> <Jupstar ✪> in this case tbf it's not really c++
13:40 < bridge> <Jupstar ✪> u can also leak in rust
13:40 < bridge> <ryozuki> yeah
13:40 < bridge> <ryozuki> but not as easily
13:41 < bridge> <ryozuki> u kinda leak intentionally or due to using cells wrongly
13:41 < bridge> <Jupstar ✪> or to give others some work to do
13:41 < bridge> <ryozuki> true
13:41 < bridge> <ryozuki> c++ devs use a lang with lot of ub to give each other more work
13:41 < bridge> <ryozuki> so they can keep working
13:41 < bridge> <ryozuki> and getting their salary
13:42 < bridge> <ryozuki> we solved the mistery
13:42 < bridge> <Ewan> stimulate the economy
13:42 < bridge> <ryozuki> now it makes sense why its mostly old grumpy c++ coders who are against rust holyness
13:42 < bridge> <Ewan> im going to lose my mind
13:42 < bridge> <ryozuki> https://tenor.com/view/inquisition-monty-python-spanish-inquisition-walk-in-gif-17117394
13:42 < bridge> <Ewan> microwave the hard drive visual studio is installed on rn
13:43 < bridge> <_voxeldoesart> intentionally?
13:43 < bridge> <ryozuki> not at all lol, i wanted my pr merged and to work since i use that for work
13:43 < bridge> <Ewan> why would he sabotage one of the most important open source endeavors :owo:
13:43 < bridge> <ryozuki> ^ this
13:44 < bridge> <Jupstar ✪> ryo is imposter
13:44 < bridge> <ryozuki> im a llvm developer
13:44 < bridge> <Jupstar ✪> virus in linux kernel next
13:44 < bridge> <ryozuki> and a rust-lang developer
13:44 < bridge> <ryozuki> :owo:
13:44 < bridge> <_voxeldoesart> probably to test how good code management it had
13:44 < bridge> <Ewan> wtf
13:44 < bridge> <Ewan> why
13:44 < bridge> <Jupstar ✪> i'm ddnet dev
13:44 < bridge> <ryozuki> @jupeyy_keks i once looked into contributing to the linux kernel
13:44 < bridge> <ryozuki> but
13:44 < bridge> <Jupstar ✪> :brownbear:
13:44 < bridge> <ryozuki> it looks scary
13:44 < bridge> <Ewan> this is what Tests are for
13:44 < bridge> <ryozuki> im sure they would shout at me
13:44 < bridge> <ryozuki> xd
13:44 < bridge> <Jupstar ✪> it is
13:44 < bridge> <_voxeldoesart> @mpft
13:45 < bridge> <ryozuki> they detected the leak with tooling, but it was more late in the infrastructure than expected
13:45 < bridge> <Jupstar ✪> but i still think that if you really understand the underlaying concepts used in the kernel, c would be the smaller problem
13:45 < bridge> <ryozuki> llvm is: PR -> CI -> MERGE -> BUILDBOT wiht lot of merges
13:45 < bridge> <ryozuki> the buildbot runs the sanitizers
13:45 < bridge> <ryozuki> idk why CI didnt pick it
13:47 < bridge> <_voxeldoesart> ngl i wonder how many people tried to sneak in malware when doing a pr but not realizing the code could be seen
13:47 < bridge> <Ewan> This is technically true but it’s satire
13:47 < bridge> <Jupstar ✪> i don't think it is very common, bcs the success rate is simply extremly low
13:48 < bridge> <Jupstar ✪> who does crime if the chance of fail is almost 0
13:48 < bridge> <Jupstar ✪> only trolls
13:48 < bridge> <_voxeldoesart> ik but the pr page is probably rly funny to look at
13:48 < bridge> <Jupstar ✪> the chance of success*
13:49 < bridge> <Ewan> who wants to play fortnite
13:49 < bridge> <Jupstar ✪> r u 12?
13:49 < bridge> <Jupstar ✪> who wants to code fortnite
13:49 < bridge> <_voxeldoesart> peter griffin:
13:49 < bridge> <Ewan> voxel do u fortnite
13:49 < bridge> <_voxeldoesart> no but i think the new update is rly funny
13:50 < bridge> <Ewan> i can't believe they made him jacked
13:50 < bridge> <Ewan> all the appeal is gone
13:50 < bridge> <Ewan> i want to see peter's fat ass waddle across the map cranking 90s
13:50 < bridge> <_voxeldoesart> they had to shrink his hitbox somehow
13:50 < bridge> <Ewan> yeah
13:50 < bridge> <Ewan> should have just made bullets bounce off his regions that aren't in a normal player hitbox or something
13:50 < bridge> <Ewan> this is such a copout
13:51 < bridge> <Ewan> none of the weapons on the map in this season are hit scan and it's super jarring compared to last season where all OG weapons sans snipers are
13:52 < bridge> <Ewan> i have to actually use my brain and guess where the target will be and account for projectile travel time
13:55 < bridge> <Ewan> i was a fortnite hater for a long time but tbh fortnite gets a seriously bad rep for no reason other than it's funny to hate on
13:55 < bridge> <Ewan> it's probably one of the most well rounded, fleshed out video game experiences out there
14:02 < bridge> <learath2> I can't pick a language for day 3, help me pick one
14:02 < bridge> <learath2> I have the urge to go C ofc, but I also want to do sth different
14:02 < bridge> <_voxeldoesart> he already chose one for you
14:03 < bridge> <Ewan> sbcl
14:03 < bridge> <learath2> Well yeah it's ryo, he'll say rust
14:03 < bridge> <learath2> Maybe I'll do rust for a change eventhough it's extremely annoying to work with strings in rust
14:05 < bridge> <ryozuki> u want a weird lang?
14:06 < bridge> <learath2> Nah already picked Rust
14:06 < bridge> <Ewan> why not sbcl
14:06 < bridge> <ryozuki> https://www.uiua.org/
14:06 < bridge> <ryozuki> try this
14:06 < bridge> <learath2> LOL that is absurd
14:06 < bridge> <ryozuki> xd
14:07 < bridge> <ryozuki> someone at work is using it
14:07 < bridge> <ryozuki> for aoc
14:09 < bridge> <ryozuki> good, ur converting
14:11 < bridge> <learath2> Honestly awful to work with ascii strings in Rust
14:11 < bridge> <ryozuki> no
14:11 < bridge> <ryozuki> just use .chars
14:11 < bridge> <ryozuki> chars indices
14:12 < bridge> <ryozuki> it also has many utilities
14:12 < bridge> <ryozuki> split_ascii_whitespace
14:12 < bridge> <ryozuki> etc
14:12 < bridge> <ryozuki> split_once
14:12 < bridge> <learath2> When I know I have ascii strings I just want my nice indexes, no iterators no magic tokenizers
14:12 < bridge> <ryozuki> mimimimi
14:13 < bridge> <learath2> I know you like your cool space age iterators and functions but I'm a simple man
14:13 < bridge> <learath2> I like my state machines and indexes
14:13 < bridge> <ryozuki> u can use this https://crates.io/crates/ascii
14:13 < bridge> <ryozuki> but i prefer if u use chars()
14:14 < bridge> <ryozuki> u can index too
14:14 < bridge> <ryozuki> char indexes
14:15 < bridge> <ryozuki> ok not index like indexing a array
14:15 < bridge> <ryozuki> because utf8
14:15 < bridge> <ryozuki> u could work with bytes but u lose the nice methods
14:15 < bridge> <ryozuki> anyway use .lines() for a iter on lines
14:15 < bridge> <ryozuki> it parses them
14:15 < bridge> <ryozuki> correctly
14:15 < bridge> <ryozuki> unlike u splitting just  \n
14:16 < bridge> <ryozuki> > An iterator over the lines of a string, as string slices.
14:16 < bridge> <ryozuki> > 
14:16 < bridge> <ryozuki> > Lines are split at line endings that are either newlines (\n) or sequences of a carriage return followed by a line feed (\r\n).
14:16 < bridge> <ryozuki> > 
14:16 < bridge> <ryozuki> > Line terminators are not included in the lines returned by the iterator.
14:16 < bridge> <ryozuki> > 
14:16 < bridge> <ryozuki> > Note that any carriage return (\r) not immediately followed by a line feed (\n) does not split a line. These carriage returns are thereby included in the produced lines.
14:16 < bridge> <ryozuki> > 
14:16 < bridge> <ryozuki> > The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.
14:17 < bridge> <ryozuki> ```rust
14:17 < bridge> <ryozuki> let numbers = lines
14:17 < bridge> <ryozuki>         .next()
14:17 < bridge> <ryozuki>         .unwrap()
14:17 < bridge> <ryozuki>         .split_once(": ")
14:17 < bridge> <ryozuki>         .unwrap()
14:17 < bridge> <ryozuki>         .1
14:17 < bridge> <ryozuki>         .split_ascii_whitespace()
14:17 < bridge> <ryozuki>         .map(|x| x.parse::<u64>().unwrap())
14:17 < bridge> <ryozuki>         .collect_vec();
14:17 < bridge> <ryozuki> 
14:17 < bridge> <ryozuki>     lines.nth(1);
14:17 < bridge> <ryozuki> ```
14:17 < bridge> <learath2> Splitting on `\n` is completely fine for C
14:17 < bridge> <ryozuki> this is how i parsed the input on last day
14:17 < bridge> <ryozuki> well its t he first line
14:17 < bridge> <ryozuki> yeah but there are subteities
14:17 < bridge> <ryozuki> like empty last line, carriage shit etc
14:18 < bridge> <learath2> In text mode libc handles the CRLF/LF
14:18 < bridge> <learath2> I hate that CRLF is still a thing btw
14:18 < bridge> <ryozuki> ye
14:18 < bridge> <ryozuki> winshit
14:18 < bridge> <learath2> Why can't microsoft just be normal?
14:18 < bridge> <learath2> It's over this isn't 1856, we don't have carriages that require return anymore
14:19 < bridge> <ryozuki> xd
14:19 < bridge> <learath2> Bro still computing like we have teletypes
14:19 < bridge> <_voxeldoesart> tell them that
14:20 < bridge> <learath2> If only they'd listen to me
14:20 < bridge> <zogtib> If Microsoft wanted an OS built on sane principles they could just use UNIX. Most probably they don't.
14:22 < bridge> <Ewan> maybe the execution is bad but the principles are solid… no pun intend even though i was just pulling my hair out over midl
14:23 < bridge> <Ewan> most of their issues stem from lack of attention imo
14:23 < bridge> <learath2> What principles? Principle of cornering the market with a monopoly?
14:23 < bridge> <Ewan> lately in win 11 most of the issues have been corporate side or in the shell where there are 20 different teams all with different goals trying to exist in parallel
14:23 < bridge> <Ewan> at a low level it seems like their tooling suffers from lack of clarity when something goes wrong
14:23 < bridge> <Ewan> and it's a little convoluted
14:24 < bridge> <learath2> There is only one nice thing I can say about how windows/nt kernel is built and it's their extremely well made forwards/backwards compatibility
14:24 < bridge> <Ewan> holy shit this update is so unstable
14:24 < bridge> <Ewan> https://cdn.discordapp.com/attachments/293493549758939136/1181586872019992636/image.png?ex=65819987&is=656f2487&hm=ef76cbe41037c88f59bd31135d760a01073516053708e560478fa64a4ea4ea58&
14:24 < bridge> <Ewan> this is like the fifth crash
14:24 < bridge> <Ewan> all top10 games
14:24 < bridge> <Ewan> :feelsbadman:
14:25 < bridge> <zogtib> A Windows 10 install requires 30GB of disk space, that's not a bug it's a feature if you wanna sell stuff
14:25 < bridge> <zogtib> But that makes the OS bad as an OS.
14:26 < bridge> <_voxeldoesart> linux update: they add clippy but instead of clippy its that smug ass penguin and they always give you snarky comments
14:26 < bridge> <_voxeldoesart> what other games do u play that isnt ddnet
14:26 < bridge> <learath2> It's insane what people will tolerate nowadays from companies just because it looks cool
14:28 < bridge> <Ewan> it’s still more functional in more ways
14:28 < bridge> <zogtib> Saying that it "looks cool" might be because of ignorance but practically "normal" ppl, simple people need to actually use Windows.
14:28 < bridge> <ryozuki> my gentoo server uses like 200mb ram on idle
14:28 < bridge> <ryozuki> and it has 32gb
14:29 < bridge> <ryozuki> what ways? linux kernel ships way more drivers than windows
14:29 < bridge> <ryozuki> windows downloads them from virus store
14:30 < bridge> <ryozuki> does winshit has stuff like tempfs
14:30 < bridge> <ryozuki> tmpfe
14:30 < bridge> <ryozuki> cant type
14:30 < bridge> <learath2> The only reason windows is more functional imo is software vendors not caring about linux and it's relatively small market share enough to port to it
14:30 < bridge> <zogtib> Wine is very nice but it can't run all the games, so having a Windows installation is required if you wanna play some games.
14:31 < bridge> <learath2> If it wasn't for Adobe and some games Windows would have nothing over Linux really
14:31 < bridge> <_voxeldoesart> im taking that as "i dont have any big games on my pf:
14:31 < bridge> <ryozuki> some being the ones using kernel level spy
14:31 < bridge> <_voxeldoesart> adobe my beloved 🤑🤑🤑🤑🤑🏴‍☠️
14:31 < bridge> <learath2> I exclusively boot to windows just for Lightroom and a handful of games
14:32 < bridge> <_voxeldoesart> im taking that as "i dont have any big games on my pc"
14:32 < bridge> <ryozuki> i play ffxiv and it runs perfect
14:32 < bridge> <ryozuki> wine has come a long way
14:32 < bridge> <ryozuki> the more vulkan adoption the easier too
14:32 < bridge> <ryozuki> i no longer have a winshit partition
14:32 < bridge> <learath2> Issues are usually with the very latest games
14:32 < bridge> <ryozuki> elden ring ran better
14:32 < bridge> <ryozuki> on Linux
14:32 < bridge> <ryozuki> no stutters
14:33 < bridge> <zogtib> I tried to get this game running with wine https://en.wikipedia.org/wiki/Bugs_Bunny_%26_Taz%3A_Time_Busters (released around 2000) but it wouldn't work, but worked on Windows
14:33 < bridge> <learath2> BG3 and ER ran great for me too but I had massive issues with RDR2 e.g.
14:33 < bridge> <_voxeldoesart> me when i am a gamer and i have to play 100gb games
14:34 < bridge> <learath2> Hm, these ancient games usually run just fine on wine. I've had to occasionally use winecfg to get to win98 though
14:35 < bridge> <zogtib> I tried everything I could, but it failed with a "requires 16 bit desktop" error, even though I used Xephyr ...
14:35 < bridge> <zogtib> Also I'm not too experienced with debuging wine
14:36 < bridge> <learath2> Debugging wine is an art in and of itself too
14:36 < bridge> <zogtib> Actually there was a patch fixing it for a similar game but wouldn't work at current wine versions
14:37 < bridge> <zogtib> so I just used Windows to play the game at that point
15:08 < bridge> <Jupstar ✪> 16bit sounds like dos box
15:08 < bridge> <Iza> i have a feeling some windows update or some nvidia driver update causes all my unreal engine games to frequently crash
15:09 < bridge> <Ewan> could be
15:09 < bridge> <Ewan> mine was perfect before yesterday
15:09 < bridge> <Ewan> which was when the massive update dropped
15:09 < bridge> <Ewan> so i think its that lol
15:09 < bridge> <learath2> I think I might not be built for the Rust thinking
15:09 < bridge> <Jupstar ✪> wtf when did nvidia drivers got bad again
15:09 < bridge> <Jupstar ✪> they were by far the best in past
15:10 < bridge> <Jupstar ✪> back when i was young. 2000 years ago
15:10 < bridge> <Jupstar ✪> unlucky you
15:10 < bridge> <learath2> How hard can it be to just have atoi? Gimme the integer until you get the first bad character, it's not rocket surgery, but no I have to find the first bad character myself then give rust only the valid slice which is O(2n) unnecessarily
15:13 < bridge> <ryozuki> u just need to split at whitespaces
15:14 < bridge> <learath2> Again an extra scan that isn't really required
15:14 < bridge> <Jupstar ✪> what even is your use case
15:14 < bridge> <Jupstar ✪> i sounds like you actually want serialization
15:14 < bridge> <fokkonaut> nice lie
15:15 < bridge> <ryozuki> u can use nom
15:15 < bridge> <ryozuki> or libc atoi
15:15 < bridge> <ryozuki> nom is fun
15:15 < bridge> <learath2> `let s = "231231...312";` I want `s.parse::<i32>()` to give me `231231`, it's not that difficult, we've been doing it since 1990 no problem
15:15 < bridge> <learath2> nom actually looks very cool, I should give it a try sometime
15:15 < bridge> <Jupstar ✪> but why should this string ever happen in first place
15:15 < bridge> <fokkonaut> leraro can i send something
15:16 < bridge> <ryozuki> its more oriented for byte than str but works for both niceky
15:16 < bridge> <learath2> It's part of the AOC input for day 3
15:16 < bridge> <ryozuki> u can also go overboard and so a LR parser with lalrpop
15:16 < bridge> <Jupstar ✪> ah ok, so a puzzle
15:17 < bridge> <learath2> It's not extremely unusual in non puzzle cases too. There is a reason `strtol` is defined the way it is
15:17 < bridge> <ryozuki> i would show u but im at gym
15:18 < bridge> <Jupstar ✪> i'd say it's very bad to use such strings. in these cases u probably want serialization
15:18 < bridge> <learath2> ```c
15:18 < bridge> <learath2> for(;;) {
15:18 < bridge> <learath2>   int k = strtol(s, &s, 10);
15:18 < bridge> <learath2>   while(*s++ != ',');
15:18 < bridge> <learath2>   // do sth with k
15:18 < bridge> <learath2> }
15:18 < bridge> <learath2> ```
15:18 < bridge> <ryozuki> :owo:
15:18 < bridge> <Jupstar ✪> why would one work with this
15:18 < bridge> <learath2> ```c
15:18 < bridge> <learath2> for(;;) {
15:18 < bridge> <learath2>   int k = strtol(s, &s, 10);
15:18 < bridge> <learath2>   while(*s++ == ',' || s == ' ');
15:18 < bridge> <learath2>   // do sth with k
15:18 < bridge> <learath2> }
15:18 < bridge> <learath2> ```
15:19 < bridge> <learath2> CSV is extremely common, there you go a very trivial way to parse csv
15:19 < bridge> <Jupstar ✪> i'd split by comma and maybe trim
15:19 < bridge> <ryozuki> i hate mobile
15:19 < bridge> <Jupstar ✪> but why should it have strings mixed with numerics
15:19 < bridge> <ryozuki> xd
15:20 < bridge> <learath2> I mean if you never write a parser ever, yes it's not the most useful thing ever, but when writing parsers you commonly want to `nom` parts of the input, which is why an entire rust crate exists around the usecase
15:21 < bridge> <learath2> LR parsers also work on the same idea, go left to right, accept the most you can
15:21 < bridge> <ryozuki> https://docs.rs/atoi_simd/latest/atoi_simd/
15:21 < bridge> <Jupstar ✪> this is simply not true.
15:21 < bridge> <Jupstar ✪> 
15:22 < bridge> <Jupstar ✪> the reason it exists is bcs someone thought it's so clever to mix chars and ints and call it a good awesome parsable data structure xDD
15:22 < bridge> <Jupstar ✪> a parser is also for serialized data, and there it should, if your serializer works right, never happen
15:22 < bridge> <learath2> Ok, you are the smartest, decades of computer science and no one thought of it
15:22 < bridge> <Jupstar ✪> thanks
15:22 < bridge> <ryozuki> there is a idiom common in rust, unrelated maybe but i remembered
15:22 < bridge> <ryozuki> parse, dont validate
15:23 < bridge> <ryozuki> or smth like that
15:23 < bridge> <Ewan> this is a rust thing ?
15:24 < bridge> <ryozuki> nah
15:24 < bridge> <ryozuki> its a common idiom
15:24 < bridge> <ryozuki> but easier or only able to do in strongly typed langs
15:25 < bridge> <Jupstar ✪> @learath2 i even bet that, e.g. using a space can be faster, because you can split the work more easily, since you only have to look out for spaces
15:25 < bridge> <ryozuki> https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/
15:25 < bridge> <learath2> It's not even just numeric and alphanumeric btw, this is literally how most parsers for context free languages are built, build tokens by accepting from the left until you can't
15:27 < bridge> <Jupstar ✪> i dunno, i'd say most of these probably use a binary format
15:27 < bridge> <Jupstar ✪> 
15:27 < bridge> <Jupstar ✪> but if not. i'd still not recommend it. what would be the use case over a structured format, or any delimeter or whatever
15:27 < bridge> <learath2> How do you think `split` works?
15:27 < bridge> <learath2> It's not rocket science, it accepts stuff until your delimeter
15:27 < bridge> <Jupstar ✪> yeah but just that this splitter exists, makes it 10000 times better
15:28 < bridge> <learath2> If you first split, then parse the integer you are just wasting cycles
15:28 < bridge> <Jupstar ✪> than just "2121hiwazzupbroParseMe231"
15:29 < bridge> <Jupstar ✪> depends on the split. if it's part of the iterator then not
15:29 < bridge> <learath2> (and not only the case with integers, anything you can parse LR with a scan, if you split first you are wasting time)
15:29 < bridge> <learath2> Yeah, if it has iterator magic it's fine
15:31 < bridge> <learath2> And even then only in the case of the correct kind of iterator magic, in Java iirc it'll end up building strings and passing it on, double scanning
15:31 < bridge> <learath2> `Spliterator` iirc it was called
15:33 < bridge> <Jupstar ✪> but in theory it can still make sense.. but tbf it depends on context.
15:33 < bridge> <Jupstar ✪> 
15:33 < bridge> <Jupstar ✪> 
15:33 < bridge> <Jupstar ✪> if u have a huge string u could easily split tasks.
15:33 < bridge> <Jupstar ✪> u have one extra scan, but therefore the substrings can directly be pushed to a thread or whatever.
15:33 < bridge> <Jupstar ✪> 
15:33 < bridge> <Jupstar ✪> Depends on the complexity of your struct, but could have use cases
15:33 < bridge> <learath2> I missed this, what did you want to share?
15:34 < bridge> <fokkonaut> https://tenor.com/view/rick-roll-rick-ashley-never-gonna-give-you-up-gif-22113173
15:34 < bridge> <Jupstar ✪> why did i knew this happens
15:35 < bridge> <fokkonaut> probably because you are smart
15:35 < bridge> <Jupstar ✪> ah right. i am the smartest dev alive
15:35 < bridge> <fokkonaut> Arguably
15:35 < bridge> <Jupstar ✪> learath gave me this honor
15:36 < bridge> <fokkonaut> o.o
15:39 < bridge> <learath2> Knuth has nothing on you
15:45 < bridge> <ryozuki> i think with iterators its optimized
15:45 < bridge> <ryozuki> the power of lazy
15:45 < bridge> <ryozuki> or maybe not
15:45 < bridge> <ryozuki> idk
15:46 < bridge> <learath2> It could be in Rust, idk how split works under the hood in rust
15:46 < bridge> <ryozuki> it returns a iterator ofc
15:46 < bridge> <learath2> How would it know how much to pass on to parse if it doesn't pre-scan though?
15:46 < bridge> <ryozuki> true
15:46 < bridge> <ryozuki> thats my doubt
15:46 < bridge> <learath2> And parse has to scan again when building the integer, idk
15:46 < bridge> <_voxeldoesart> funniest fokko post
15:47 < bridge> <learath2> Maybe LLVM can see through it?
15:47 < bridge> <learath2> Don't make me call heinrich on you
15:47 < bridge> <ryozuki> maybe it could if parse didnt do error checking
15:47 < bridge> <ryozuki> i think its not optimized
15:48 < bridge> <ryozuki> anyway use the itoa simd crate
15:48 < bridge> <learath2> Anyway, the real CS nerds will point out that O(n) + O(n) = O(n) so it doesn't REALLY matter if you have infinite data
15:48 < bridge> <fokkonaut> https://tenor.com/view/see-it-like-final-hamster-scared-gif-14498643
15:48 < bridge> <learath2> Eh, I don't need it to be that optimal for now. I just used a find to find the first non numeric to implement my own atoi
15:49 < bridge> <ryozuki> a find?
15:49 < bridge> <Jupstar ✪> he wants to parse it during finding
15:49 < bridge> <ryozuki> yeye
15:50 < bridge> <Jupstar ✪> does atoi guarantee that btw?
15:50 < bridge> <Jupstar ✪> just wondering
15:50 < bridge> <ryozuki> @learath2 are u doing the non reverse technique
15:50 < bridge> <ryozuki> ah wait
15:50 < bridge> <ryozuki> its itoa
15:50 < bridge> <ryozuki> no atoi
15:50 < bridge> <ryozuki> xd
15:51 < bridge> <learath2> No guarantee ofc, but why would it ever go through the string twice?
15:51 < bridge> <learath2> I know at the very least that glibc goes through it only once
15:51 < bridge> <Jupstar ✪> dunno, not so smart devs? xdd
15:52 < bridge> <learath2> I took a look at musl and it also goes thru once
15:53 < bridge> <_voxeldoesart> :troll:
15:55 < bridge> <learath2> uclibc, freebsd and XNU too, I won't check any others 😛
15:56 < bridge> <Jupstar ✪> yeah i doubt anyone does not
15:56 < bridge> <Jupstar ✪> 
15:56 < bridge> <Jupstar ✪> i was just wondering if it has such a guarantee
15:57 < bridge> <learath2> No, as far as the standard is concerned they could be using a cloud service with workers in southeast asia decoding the ascii strings
15:58 < bridge> <Jupstar ✪> that's why i'm asking. i wonder if i can use some super computer that just takes every character as single instance and then checks if it's digit or not
15:58 < bridge> <Jupstar ✪> and ofc go into a python call
16:00 < bridge> <Ewan> lmfao
16:00 < bridge> <Ewan> Yes
16:01 < bridge> <Jupstar ✪> oups silent overflow
16:08 < bridge> <heinrich5991> not really. win11 notepad supports LF. CRLF can finally die
16:09 < bridge> <heinrich5991> that leads to bad parsing code, usually
16:11 < bridge> <heinrich5991> because you don't fail on invalid input
16:11 < bridge> <heinrich5991> see e.g. all of the teeworlds code parsing ints
16:11 < bridge> <Jupstar ✪> And integer overflow xd
16:11 < bridge> <Jupstar ✪> Which kinda is invalid input tbf
16:11 < bridge> <heinrich5991> and errors in rust
16:11 < bridge> <ryozuki> heinrich always has logical arguments
16:11 < bridge> <Jupstar ✪> Nani
16:11 < bridge> <ryozuki> has anyone ever won heinrich in arguments
16:11 < bridge> <ryozuki> @jupeyy_keks well atleast it feels like he is right by logic usually xd
16:12 < bridge> <learath2> If you don't fail on invalid input that's your mistake, not the function that does exactly what it says it'll do
16:12 < bridge> <Jupstar ✪> I don't write anything xd
16:13 < bridge> <learath2> If you expect a whitespace after your integer, you confirm the whitespace
16:13 < bridge> <learath2> ```c
16:13 < bridge> <learath2> int k = strtol(s, &s, 10);
16:13 < bridge> <learath2> if(*s != ' ')
16:13 < bridge> <learath2>   abort()
16:13 < bridge> <learath2> ```
16:15 < bridge> <ryozuki> @learath2 thats wrong!
16:15 < bridge> <ryozuki> u should use goto
16:15 < bridge> <ryozuki> not abort
16:15 < bridge> <ryozuki> goto to exit
16:15 < bridge> <ryozuki> long jumps
16:15 < bridge> <Ewan> what
16:15 < bridge> <ryozuki> im joking cuz he loves goto
16:15 < bridge> <ryozuki> xd
16:15 < bridge> <Ewan> :justatest:
16:15 < bridge> <ryozuki> :justatest:
16:15 < bridge> <Ewan> goto sympathizer
16:16 < bridge> <learath2> I would but that immediately triggers the "bad code" receptors in heinrich and Jupstar because they read that one article by Knuth in 1453 right after the Ottoman invasion of Constantinople
16:16 < bridge> <ryozuki> @learath2 do u use goto that go across function calls?
16:16 < bridge> <learath2> So I save that for my own personal code where other people can't judge me
16:16 < bridge> <ryozuki> function bodies*
16:16 < bridge> <ryozuki> or calls
16:16 < bridge> <ryozuki> idk
16:16 < bridge> <teero777> Hahaha
16:16 < bridge> <teero777> 😂👍
16:17 < bridge> <learath2> setjmp/longjmp? I only used it once when implementing coroutines in C
16:17 < bridge> <ryozuki> r u ok
16:17 < bridge> <learath2> Oh, I lie, it wasn't coroutines, it was exceptions
16:18 < bridge> <learath2> I gave up on my coroutine implementation, it was far too complex for my level at the time
16:18 < bridge> <learath2> and you are also supposed to check errno after before someone mentions it, I just omitted it for clarity
16:19 < bridge> <ryozuki> rust error handling is better
16:19 < bridge> <ryozuki> than errno
16:19 < bridge> <ryozuki> but c doesnt have sum types
16:19 < bridge> <learath2> In an ideal world C would have `Result` and `?` like Rust and we wouldn't need errno and that line would just need a `?` instead
16:19 < bridge> <ryozuki> hehe so u agree
16:19 < bridge> <ryozuki> <a:ferrisBongoHyper:797313593133236224>
16:19 < bridge> <learath2> Maybe I should make a subset of rust that is just a better C :yae_think:
16:20 < bridge> <ryozuki> but in kernel maybe C way is better
16:20 < bridge> <ryozuki> cuz in kernel they need to make sure lot of stuff
16:20 < bridge> <ryozuki> i read some blogs
16:20 < bridge> <ryozuki> its wizardry
16:20 < bridge> <ryozuki> im talking about error handling
16:20 < bridge> <learath2> Eeeeeh, I doubt anyone really enjoys errno
16:20 < bridge> <ryozuki> well maybe in kernel they would use Result
16:20 < bridge> <ryozuki> but without ?
16:20 < bridge> <ReiTW> What if linux server was 100% rust, how much time would it need to compile
16:20 < bridge> <ryozuki> they would take care of errs
16:20 < bridge> <learath2> Yep, that would probably be the case
16:20 < bridge> <ryozuki> at the call site
16:20 < bridge> <ReiTW> Linux kernel\*
16:21 < bridge> <ryozuki> probs not much more
16:21 < bridge> <learath2> You have to recover from stuff in the kernel, you can't just pass it upwards, there is nothing upwards
16:21 < bridge> <teero777> Who needs error handling? Just write good  code???
16:21 < bridge> <ryozuki> did u know linus now compiles his kernel with clang
16:21 < bridge> <ryozuki> instead of gcc
16:22 < bridge> <learath2> Does it even compile nowadays?
16:22 < bridge> <ryozuki> ? xd
16:22 < bridge> <learath2> clang lacked a couple compiler specific stuff that was blocking
16:22 < bridge> <ryozuki> @learath2 btw its me or gentoo stabilizes kernels rly slowly
16:22 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1181616628593606687/image.png?ex=6581b53d&is=656f403d&hm=21e8a3cbc9c112042c3cd8f9dc2d92831f6bb1ba51029960adaf1cf7286d7ff9&
16:22 < bridge> <ryozuki> i want SHINY NEW KERNELS
16:22 < bridge> <ryozuki> but i dont want to use testing
16:22 < bridge> <ryozuki> for kernels
16:22 < bridge> <learath2> Yep, they take a bit, you should unmask if you want to be at the bleeding edge
16:23 < bridge> <ryozuki> i think arch is faster
16:23 < bridge> <ryozuki> at updating kernel
16:23 < bridge> <learath2> Arch just puts it out there without much testing or anything really, if it compiles and the test vm boots they ship
16:23 < bridge> <ryozuki> xd
16:23 < bridge> <ryozuki> make oldconfig will show  lot of new options
16:23 < bridge> <learath2> That's the unmasked ebuild for gentoo, if it compiles it's there
16:37 < ChillerDragon> shit i spent 2 minutes debugging a fizzbuzz issue -.-
16:43 < bridge> <learath2> @ryozuki do you have any clue why `as_ptr` isn't a method for `Rc`?
16:43 < bridge> <learath2> Just curious
16:52 < bridge> <Jupstar ✪> U mean why to call it efficiently?
16:52 < bridge> <Jupstar ✪> Explicit
16:52 < bridge> <Jupstar ✪> Rc::asptr
16:53 < bridge> <Jupstar ✪> Bcs deref
16:53 < bridge> <Jupstar ✪> It can't evaluate it
16:53 < bridge> <Jupstar ✪> At least not always
16:53 < bridge> <Jupstar ✪> I guess
16:53 < bridge> <learath2> I actually don't follow any of that :/
16:53 < bridge> <Jupstar ✪> U mean why to call it explicitly?
16:54 < bridge> <learath2> Currently it's an associated function instead of a method, I was just wondering why that is a better choice than just a normal method
16:55 < bridge> <Jupstar ✪> Bcs deref
16:55 < bridge> <Jupstar ✪> What if u have vec as type
16:55 < bridge> <Jupstar ✪> Asptr conflicts then
16:55 < bridge> <Jupstar ✪> Vec vs rc
16:55 < bridge> <Jupstar ✪> Rc<vec> i mean
16:58 < bridge> <learath2> Ah, that makes sense, I wonder what the rule is in that case to resolve the issue
17:03 < bridge> <learath2> @ryozuki do you have your aoc solutions up somewhere? I'm curious how you did day 3
17:05 < bridge> <Jupstar ✪> Can someone suggest a good file recovery tool for Windows. For permanent deleted files?
17:05 < bridge> <Jupstar ✪> Or for ntfs
17:05 < bridge> <Ewan> lol what did you do
17:06 < bridge> <Jupstar ✪> A friend lost his saves because steam cloud was full xD
17:06 < bridge> <Ewan> testdisk/photorec works on ntfs
17:06 < bridge> <learath2> photorec is usually your best bet yeah
17:06 < bridge> <Ewan> i would recommend the former for that kind of thing tho
17:06 < bridge> <Jupstar ✪> I read about them but sounded like they can only recover partitions
17:06 < bridge> <Ewan> No
17:06 < bridge> <learath2> I recovered dozens of photos with photorec on an accidentally formatted sd card
17:06 < bridge> <Jupstar ✪> And some closed source tool from cclraner did not work
17:07 < bridge> <Ewan> photorec just patches files together based on data it sees on a partition
17:07 < bridge> <Jupstar ✪> Ok
17:07 < bridge> <Jupstar ✪> I never used them so no experience
17:07 < bridge> <Ewan> so if it’s game data then it’s gonna make a bunch of weird arbitrary files
17:07 < bridge> <Ewan> when i did it on my disk i had hundreds of awesome wavs that were not supposed to be wavs
17:07 < bridge> <Ewan> it’s good for… photos
17:07 < bridge> <Ewan> testdisk just tries to recover fs journal data afaik
17:09 < bridge> <learath2> It's good for structured data*
17:09 < bridge> <Ewan> I guess
17:09 < bridge> <learath2> It finds wavs everywhere because wavs are just byte arrays that have no structure
17:09 < bridge> <Ewan> Yes
17:10 < bridge> <Ewan> They do technically have structure tho
17:10 < bridge> <Ewan> Images have headers describing dimensions, chunk type and depth
17:10 < bridge> <learath2> `TryInto::<usize>::try_into(p.1).unwrap()` this might be the ugliest thing I've ever written 😄
17:10 < bridge> <Ewan> Wavs have a p descriptive header
17:10 < bridge> <Ewan> Depth and length
17:10 < bridge> <ryozuki> sry i was cleaning up my apartment
17:10 < bridge> <ryozuki> i was close to being a hobo
17:11 < bridge> <Ewan> Enough to hopefully discern the actual boundaries of the file, you’d think. At least the pcm chunk. But no
17:11 < bridge> <learath2> you should become hobo, you already own anime sword
17:11 < bridge> <ryozuki> doesnt it defeat the purpose
17:11 < bridge> <ryozuki> or u mean as unsafe
17:11 < bridge> <ryozuki> @learath2 why u using rc on day 3 tho
17:12 < bridge> <learath2> I just misread the task at the start, then patched up something that sort of works, don't worry about it 😄
17:12 < bridge> <ryozuki> <https://github.com/edg-l/aoc2023/blob/b0de1e16f26f50dbcb75bfc88ed6f63e1dc8c612/src/main.rs>
17:12 < bridge> <ryozuki> day 3
17:13 < bridge> <ryozuki> erm i dont own only 1
17:13 < bridge> <ryozuki> i also have the bleach sword and cloud sword, but those are woden
17:13 < bridge> <ryozuki> wooden
17:13 < bridge> <ryozuki> the one i showed is metal
17:13 < bridge> <learath2> https://paste.pr0.tips/fGY?rust here if you want to lose your eyesight, this is only part 1 though
17:14 < bridge> <Ewan> ded link ?
17:14 < bridge> <learath2> It loads just fine for me
17:14 < bridge> <ryozuki> @learath2 xd a for loop worked
17:14 < bridge> <ryozuki> no need for points
17:14 < bridge> <Ewan> rip
17:15 < bridge> <Ewan> https://cdn.discordapp.com/attachments/293493549758939136/1181629804219469914/IMG_4526.png?ex=6581c182&is=656f4c82&hm=ba041cfcd1374d452c2520c46d0395b47c42b4951378b5700528942617c78cef&
17:15 < bridge> <ryozuki> ```rust
17:15 < bridge> <ryozuki>  for dy in -1i64..2 {
17:15 < bridge> <ryozuki>                 for dx in -1i64..2 {
17:15 < bridge> <ryozuki>                     // check bounds
17:15 < bridge> <ryozuki>                     if (y == 0 && dy < 0)
17:15 < bridge> <ryozuki>                         || (y == (height - 1) && dy > 0)
17:15 < bridge> <ryozuki>                         || (x == 0 && dx < 0)
17:15 < bridge> <ryozuki>                         || (x == (width - 1) && dx > 0)
17:15 < bridge> <ryozuki>                     {
17:15 < bridge> <ryozuki>                         continue;
17:15 < bridge> <ryozuki>                     }
17:15 < bridge> <ryozuki>                     let coordy = ((y as i64) + dy) as usize;
17:15 < bridge> <ryozuki>                     let coordx = ((x as i64) + dx) as usize;
17:15 < bridge> <ryozuki>                     let v = input.get(coordy).and_then(|a| a.get(coordx)).unwrap();
17:15 < bridge> <ryozuki> 
17:15 < bridge> <ryozuki>                     if !v.is_ascii_digit() && *v == '*' && !current_num.is_empty() {
17:15 < bridge> <ryozuki>                         is_part_num = Some((coordx, coordy));
17:15 < bridge> <ryozuki>                     }
17:15 < bridge> <ryozuki>                 }
17:15 < bridge> <ryozuki>             }
17:15 < bridge> <ryozuki> ```
17:15 < bridge> <learath2> Yeah you can just scan through aswell,
17:15 < bridge> <learath2> I would have scanned through in C, but in Rust I get brain worms telling me to use weird features
17:15 < bridge> <ryozuki> @learath2 a perf tip
17:16 < bridge> <ryozuki> but sometimes it gives trouble with borroows
17:16 < bridge> <ryozuki> let mut row: Vec<Tile> = vec![];
17:16 < bridge> <ryozuki> u can put this outer
17:16 < bridge> <ryozuki> and use .clear
17:16 < bridge> <ryozuki> this way u avoid some allocations
17:16 < bridge> <ryozuki> if u know length too u can with Vec::with_capacity
17:16 < bridge> <ryozuki> to avoid initial allocatiosn
17:16 < bridge> <ryozuki> i think vec grows 4->8->16
17:17 < bridge> <ryozuki> new doesnt allocate tho
17:17 < bridge> <learath2> Thank
17:17 < bridge> <Ewan> just ate some pizza
17:17 < bridge> <ryozuki> let mut nums: HashSet<*const i32> = HashSet::new();
17:17 < bridge> <ryozuki> what in the world
17:17 < bridge> <learath2> 😄
17:17 < bridge> <ryozuki> why u using pointers
17:18 < bridge> <Ewan> isn’t it safe if it’s ref ptr
17:18 < bridge> <learath2> It's safe, that's not the issue, it's not needed technically
17:18 < bridge> <Ewan> yea i dont see issue
17:18 < bridge> <ryozuki> ok ok
17:18 < bridge> <ryozuki> but i am Mr. Idiomatic Rust
17:18 < bridge> <ryozuki> first, does ur code pass clippy cleanly
17:18 < bridge> <learath2> ```
17:18 < bridge> <learath2> 2 . 2
17:18 < bridge> <learath2> . * .
17:18 < bridge> <learath2> 2 . 2
17:18 < bridge> <learath2> ```
17:18 < bridge> <ryozuki> then does it pass clippy with pedantic
17:18 < bridge> <ryozuki> :justatest:
17:18 < bridge> <Ewan> croissant
17:19 < bridge> <ryozuki> `let br = Point(map[0].len().try_into().unwrap(), map.len().try_into().unwrap());`
17:19 < bridge> <Ewan> Lord
17:19 < bridge> <ryozuki> xddd
17:19 < bridge> <learath2> This is the issue I was trying to fix, initially skimming through the problem I hadn't thought about numbers being the same nor the issue with
17:19 < bridge> <learath2> ```
17:19 < bridge> <learath2> 222
17:19 < bridge> <learath2> .*.
17:19 < bridge> <learath2> ...
17:19 < bridge> <learath2> ```
17:20 < bridge> <Ewan> what is the goal
17:20 < bridge> <learath2> Do you enjoy it? 😄
17:20 < bridge> <ryozuki> @learath2 a bug i had was that i checked around the number after i encountered the current number finish
17:20 < bridge> <ryozuki> 222.
17:20 < bridge> <ryozuki> i scanned also in the .
17:20 < bridge> <ryozuki> as if i was the number
17:20 < bridge> <ryozuki> so i moved a check to the next if its a .
17:20 < bridge> <Ewan> this is me 90% of the time i go to do some leetcode
17:20 < bridge> <ryozuki> @learath2 btw i recommend u eagerly implement From and TryFrom for ur types
17:20 < bridge> <ryozuki> it makes code cleaner!
17:21 < bridge> <ryozuki> for example TryFrom<(usize, usize)> For Point
17:21 < bridge> <learath2> Then I'd coded most of it, so I shoved some unsafe and Rc in there to patch it up
17:21 < bridge> <ryozuki> then u do
17:21 < bridge> <learath2> AHA, yes I knew there was a way to do that
17:21 < bridge> <learath2> I just forgor
17:21 < bridge> <Ewan> :brownbear:
17:21 < bridge> <Ewan> i forgor
17:21 < bridge> <Ewan> feeling like sleep or fortnite
17:21 < bridge> <ryozuki> let a:Point = (map[0].len(), map.len())).try_into().unwrap()
17:21 < ChillerDragon> speaking about rust is only allowed on fridays!
17:22 < bridge> <ryozuki> nein
17:22 < bridge> <Ewan> chiller do u have Fortnite
17:22 < ChillerDragon> nein
17:22 < bridge> <Ewan> waa
17:22 < ChillerDragon> woo
17:22 < ChillerDragon> i only have minecraft and cs2
17:22 < bridge> <ryozuki> <https://github.com/edg-l/aoc2023>
17:22 < bridge> <ryozuki> my solutions are here but
17:22 < bridge> <ryozuki> within commits
17:22 < bridge> <ryozuki> cuz i was lazy
17:22 < bridge> <ryozuki> to do folders
17:23 < bridge> <ryozuki> i dont have  all too xd
17:23 < bridge> <ryozuki> oh i found a way to make it nice
17:24 < bridge> <ryozuki> i just put it in src/bin/day5.rs
17:27 < bridge> <learath2> @ryozuki any protips for l89? that one also looks nasty
17:30 < bridge> <learath2> For some reason type inference doesn't work there so couldn't do `p.1.try_into().unwrap()`
17:35 < bridge> <learath2> Another thing I miss when doing rust is the ability to just have a source file on it's own when I don't need any cargo
17:44 < bridge> <ryozuki> back
17:44 < bridge> <ryozuki> was cleaning more
17:45 < bridge> <ryozuki> @learath2 clippy tells u about that line
17:46 < bridge> <ryozuki> ```rust
17:46 < bridge> <ryozuki> if let Tile::Num(n) = &map[TryInto::<usize>::try_into(p.1).unwrap()]
17:46 < bridge> <ryozuki>                 [TryInto::<usize>::try_into(p.0).unwrap()]
17:46 < bridge> <ryozuki>             {
17:46 < bridge> <ryozuki>                 nums.insert(Rc::as_ptr(n));
17:46 < bridge> <ryozuki>             }
17:46 < bridge> <ryozuki> ```
17:46 < bridge> <learath2> It only tells me to use an `if let` which sure
17:46 < bridge> <ryozuki> first
17:46 < bridge> <learath2> but I was talking more about the nasty TryInto mess
17:47 < bridge> <ryozuki> first
17:47 < bridge> <ryozuki> all unwraps
17:47 < bridge> <ryozuki> add to main
17:47 < bridge> <ryozuki> -> Result<(), Box<dyn Error>>
17:47 < bridge> <ryozuki> so u can use ?
17:47 < bridge> <ryozuki> on any error
17:50 < bridge> <learath2> That's a good idea
17:50 < bridge> <ryozuki> do u want to panic on index error
17:51 < bridge> <learath2> Yes, it should be impossible anyway
17:51 < bridge> <ryozuki> btw why u do as_ptr
17:51 < bridge> <ryozuki> u can simply clone the rc
17:51 < bridge> <ryozuki> rc are meant to be cloned
17:51 < bridge> <ryozuki> they are a pointer itself
17:52 < bridge> <learath2> Are two clones of an Rc pointing to one thing equal?
17:52 < bridge> <ryozuki> ofc!
17:52 < bridge> <ryozuki> its the point of Rc
17:52 < bridge> <ryozuki> xd
17:52 < bridge> <learath2> Are you sure?
17:53 < bridge> <ryozuki> A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.
17:53 < bridge> <ryozuki> its the definition of Rc
17:53 < bridge> <ryozuki> Rc, Arc, are pointers
17:53 < bridge> <ryozuki> smart ones
17:53 < bridge> <ryozuki> Box is a pointer too
17:53 < bridge> <learath2> Two `std::shared_ptr`s to one thing won't compare equal
17:53 < bridge> <ryozuki> unique ownership
17:53 < bridge> <ryozuki> who caress about c++
17:54 < bridge> <ryozuki> ```rust
17:54 < bridge> <ryozuki> #[stable(feature = "rust1", since = "1.0.0")]
17:54 < bridge> <ryozuki> trait RcEqIdent<T: ?Sized + PartialEq, A: Allocator> {
17:54 < bridge> <ryozuki>     fn eq(&self, other: &Rc<T, A>) -> bool;
17:54 < bridge> <ryozuki>     fn ne(&self, other: &Rc<T, A>) -> bool;
17:54 < bridge> <ryozuki> }
17:54 < bridge> <ryozuki> 
17:54 < bridge> <ryozuki> #[stable(feature = "rust1", since = "1.0.0")]
17:54 < bridge> <ryozuki> impl<T: ?Sized + PartialEq, A: Allocator> RcEqIdent<T, A> for Rc<T, A> {
17:54 < bridge> <ryozuki>     #[inline]
17:54 < bridge> <ryozuki>     default fn eq(&self, other: &Rc<T, A>) -> bool {
17:54 < bridge> <ryozuki>         **self == **other
17:54 < bridge> <ryozuki>     }
17:54 < bridge> <ryozuki> 
17:54 < bridge> <ryozuki>     #[inline]
17:54 < bridge> <ryozuki>     default fn ne(&self, other: &Rc<T, A>) -> bool {
17:55 < bridge> <ryozuki>         **self != **other
17:55 < bridge> <ryozuki>     }
17:55 < bridge> <ryozuki> }
17:55 < bridge> <ryozuki> ```
17:55 < bridge> <learath2> It's far from the point of an Rc is what I'm trying to say, `std::shared_ptr` implements the exact same thing yet won't behave the same
17:55 < bridge> <ryozuki> no
17:55 < bridge> <ryozuki> the partialeq of rc makes sense
17:55 < bridge> <ryozuki> what doesnt  make sense is shared ptr
17:55 < bridge> <ryozuki> u want to check the contents equal
17:55 < bridge> <ryozuki> not the pointer itself
17:55 < bridge> <learath2> I don't want to check if the contents are equal
17:55 < bridge> <learath2> I want to check if the Rcs point to the same exact object
17:55 < bridge> <ryozuki> ah
17:55 < bridge> <ryozuki> u and ur weird stuff
17:56 < bridge> <learath2> Each number should be accounted for once or you fail with
17:56 < bridge> <learath2> ```
17:56 < bridge> <learath2> 2 . 2
17:56 < bridge> <learath2> . * .
17:56 < bridge> <learath2> 2 . 2
17:56 < bridge> <learath2> ```
17:56 < bridge> <ryozuki> i dont see how to remove the TryInto btw, since the index method is generic it isnt smart enough to know the into is usize
17:56 < bridge> <ryozuki> but the unwrap cleanup should make things clearer
17:56 < bridge> <learath2> Yeah with the ? it looks better
17:57 < bridge> <ryozuki> yeah
17:57 < bridge> <reitw> I use now helix since two weeks, love it
17:57 < bridge> <learath2> Anyway, I'm sure yours looks better I just fixed what I had in hand quickly after I forgot about the edge case that there could be the same number around the symbol more than once
17:57 < bridge> <ryozuki> ahh
17:58 < bridge> <ryozuki> i stored the coords
17:58 < bridge> <ryozuki> so i didnt have  such problem
17:58 < bridge> <ryozuki> xd
17:58 < bridge> <learath2> Did you use the start of the number? I considered that aswell but then I'd have to rewrite my code to keep track of the start of numbers at each tile
17:58 < bridge> <ryozuki> i only have part 2
17:58 < bridge> <teero777> https://www.youtube.com/watch?v=NSS6yAMZF78
17:58 < bridge> <teero777> woah this is cool
17:59 < bridge> <ryozuki> @learath2 no, but i abuse the fact u only read numbers left to right
17:59 < bridge> <ryozuki> i store the current number as a string
17:59 < bridge> <ryozuki> i add it a temp buffer
17:59 < bridge> <ryozuki> let mut current_num = String::with_capacity(16);
17:59 < bridge> <ryozuki> let c = input[y][x];
17:59 < bridge> <ryozuki> 
17:59 < bridge> <ryozuki>             if c.is_ascii_digit() {
17:59 < bridge> <ryozuki>                 current_num.push(c);
17:59 < bridge> <ryozuki>             }
18:00 < bridge> <ryozuki> @learath2 i think ur error is mixing coords with vectors/directions
18:00 < bridge> <ryozuki> me making the coords usize makes my code cleaner
18:00 < bridge> <ryozuki> btw usize has fn overflowing_sub(self, rhs: usize) -> (usize, bool)
18:01 < bridge> <ryozuki> Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.
18:01 < bridge> <ryozuki> anyway with the bound checks i do i ensure i dont overflow
18:01 < bridge> <ryozuki> <https://github.com/edg-l/aoc2023/blob/master/src/bin/day3.rs>
18:05 < bridge> <learath2> I could make coords usize, but then instead of just adding 8 vectors I need to make sure I don't underflow
18:09 < bridge> <learath2> idk, this entire thing ended up very nasty and I don't like how I have to keep 2 folders for part 1 and part 2 to keep rust-analyzer happy
18:14 < bridge> <learath2> Maybe I should learn rust properly so I can just not use autocomplete
18:15 < bridge> <learath2> Then I can just have `a.rs` and do a nice `rustc --edition 2021 a.rs`
18:16 < bridge> <Jupstar ✪> wat?
18:17 < bridge> <Jupstar ✪> "Notes
18:17 < bridge> <Jupstar ✪> In all cases, it is the stored pointer (the one returned by get()) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). "
18:17 < bridge> <Jupstar ✪> https://en.cppreference.com/w/cpp/memory/shared_ptr/operator_cmp
18:18 < bridge> <learath2> Oh, that's cool
18:19 < bridge> <learath2> Though also annoying, are you supposed to memcmp if you want to actually compare two shared_ptrs?
18:20 < bridge> <Jupstar ✪> well or dereference it first
18:20 < bridge> <learath2> I guess they made it ergonomic for the more used case
18:21 < bridge> <Jupstar ✪> btw Rc has ptr_eq
18:22 < bridge> <Jupstar ✪> but again only a method without self
18:22 < bridge> <learath2> I doubt I can make HashSet use the ptr as key anyway
18:22 < bridge> <learath2> Even if Rc has ptr_eq
18:23 < bridge> <Jupstar ✪> oh yeah
18:35 < bridge> <Jupstar ✪> mh thinking about it again, i wonder if c++ std _would_ implement it like rust if they _could_ break backward compability and use c++20's concepts/constraints 😄
18:35 < bridge> <learath2> We don't really do the Deref thing in C++ at all though, it would be a massive paradigm shift
18:35 < bridge> <Jupstar ✪> i dunno if i like the rust behavior more, but it's probably more intuitive since u rarely cmp two Rcs
18:36 < bridge> <Jupstar ✪> there is a operator T()
18:36 < bridge> <Jupstar ✪> which is basically deref I'd say
18:37 < bridge> <learath2> I mean in Rust you can pretty much treat `Rc<T>` as `T` syntactically, which is why the comparison behaviour isn't too too unexpected
18:37 < bridge> <learath2> In C++ a level of indirection disappearing without you using a `*` is pretty much non existant
18:38 < bridge> <Jupstar ✪> i mean u do -> too on a shared_ptr
18:38 < bridge> <learath2> But `->` not `.`
18:38 < bridge> <Jupstar ✪> but you could overload it like that i think
18:38 < bridge> <Jupstar ✪> it's simply not done bcs of the naming
18:38 < bridge> <Jupstar ✪> shared_ptr not shared_ref
18:38 < bridge> <Jupstar ✪> xd
18:38 < bridge> <learath2> You could definitely, but it doesn't happen anywhere else in C++, it might feel wrong
18:38 < bridge> <Jupstar ✪> yeah
18:38 < bridge> <Jupstar ✪> probably
18:38 < bridge> <Jupstar ✪> i also dunno which one i like more tbh
18:39 < bridge> <learath2> In Rust I think what they did does make sense, the rust way is pretending indirection just doesn't exist
18:40 < bridge> <learath2> It's also hard for me to think of what is best, I guess the most used being the most ergonomic is what is important
18:41 < bridge> <learath2> There are like 3-4 things that could be compared there, bit equality of the smart pointer objects themselves, whether the smart pointer objects are the same object, whether they point to the same object, whether their contents compare equal
18:43 < bridge> <Jupstar ✪> yeah xD
18:53 < bridge> <heinrich5991> yes, I'm just saying that this leads to people writing more bad parsing code
18:55 < bridge> <heinrich5991> would sound like a weird choice
18:56 < bridge> <heinrich5991> the rule which method gets chosen? the one with the fewest dereferences (it's a little more complicated, check the rust quiz for edge cases)
18:57 < bridge> <heinrich5991> `p.1.try_into().unwrap()` didn't work?
18:57 < bridge> <learath2> So if `as_ptr()` was a method instead, and we had an `Rc<Vec<_>>` and called `.as_ptr()` would it resolve to `Rc::as_ptr()`?
18:58 < bridge> <learath2> Nope since it was indexing a vec and somewhy couldn't infer it needs to be usize
18:58 < bridge> <heinrich5991> you can do that. `rustc`
18:58 < bridge> <learath2> Sadly all the tooling around rust assumes a `Cargo.toml` exists somewhere
18:58 < bridge> <learath2> So I need to give up autocomplete for that
18:58 < bridge> <heinrich5991> compare the pointers then
18:59 < bridge> <learath2> Exactly what I ended up doing 😄
19:00 < bridge> <heinrich5991> yes
19:00 < bridge> <heinrich5991> ah yeah
19:01 < bridge> <heinrich5991> ah
19:54 < bridge> <_voxeldoesart> > This adds no backwards compatibility for old clients
19:54 < bridge> <_voxeldoesart> :justatest:
20:05 < bridge> <ryozuki> based
20:05 < bridge> <ryozuki> lets accept it
20:07 < bridge> <robyt3> The voteset message should be redesigned to be honest. It should specify the tick when the vote ends and not the seconds remaining
20:08 < bridge> <heinrich5991> makes sense
20:09 < bridge> <robyt3> So should I just limit `sv_vote_time` to 60 again? That doesn't really solve murpi's issue for now I guess.
20:16 < bridge> <heinrich5991> the issue was that votes don't appear. that's fixed by setting `sv_vote_time`'s maximum to 60
20:16 < bridge> <heinrich5991> for both old and new clients
20:16 < bridge> <heinrich5991> also removing that limit in the client sounds nice for the future
