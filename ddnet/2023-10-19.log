04:08 < bridge> <TsFreddie> https://cdn.discordapp.com/attachments/293493549758939136/1164384627838959646/image.png?ex=654304b0&is=65308fb0&hm=348be039fd8c808751faebf9b36721a18934ba90292700993810481f610fc6ce&
05:18 < bridge> <cellegenrih> https://tenor.com/view/thats-okay-larry-david-bernie-sanders-saturday-night-live-handshake-gif-16694855
05:20 < bridge> <cellegenrih> almost a perfect meme if the bottom right actually wrote SSL instead of SNL lmao
08:03 < bridge> <teero777> Gm:feelsbadman:
08:28 < bridge> <ryozuki> ‚òï
08:31 < bridge> <MilkeeyCat> Morning üçµ
09:58 < bridge> <teero777> @jupeyy_keks have any controversial or interesting topics crossed your mind today?
10:01 < bridge> <teero777> https://youtu.be/sHzdsFiBbFc?si=izInuKUPozRlt3ki
10:01 < bridge> <teero777> This for example?
10:01 < bridge> <teero777> very interesting web development
10:05 < bridge> <Ewan> GM
12:07 < bridge> <Jupstar ‚ú™> Yes. When do robots finally replace my boring useless work
12:37 < bridge> <teero777> Interesting. A war could help
12:39 < bridge> <teero777> In times of need people will be forced to innovate.
12:39 < bridge> <teero777> Let's start a war
12:39 < bridge> <Jupstar ‚ú™> No
12:39 < bridge> <Jupstar ‚ú™> This is a common miss thinking
12:40 < bridge> <Jupstar ‚ú™> The golden ages for humans were in longer peace times
12:40 < bridge> <ryozuki> what do u do at work
12:40 < bridge> <Jupstar ‚ú™> Coding xd
12:41 < bridge> <teero777> Welp I mean if everything is at peace and everyone is happy then it's good and people have free time.
12:41 < bridge> <teero777> to think of new things
12:41 < bridge> <Jupstar ‚ú™> Yes. In fact most innovative ppl are not poor
12:41 < bridge> <Ewan> the world is ending
12:41 < bridge> <Jupstar ‚ú™> So pressure is not a motivator
12:42 < bridge> <teero777> So ideas come from boredom ig
12:42 < bridge> <teero777> Mb
12:42 < bridge> <Jupstar ‚ú™> I think they come only from motivation
12:43 < bridge> <Jupstar ‚ú™> But having to think about, if u can manage life, does not help
12:43 < bridge> <Jupstar ‚ú™> E.g. being poor and forced to work
12:43 < bridge> <teero777> Hmm true
12:45 < bridge> <teero777> My classmate says necessities makes inventions
12:46 < bridge> <Jupstar ‚ú™> I'm really not sure about it. We have enough knowledge to print houses etc. But we don't do it
12:46 < bridge> <Jupstar ‚ú™> Because rich society and/or politics doesnt seem interested
12:47 < bridge> <teero777> It isn't necessary to print houses
12:47 < bridge> <teero777> Doesn't have enough gains
12:47 < bridge> <Jupstar ‚ú™> Rich Africans dont built wells
12:48 < bridge> <Jupstar ‚ú™> I'd say it's a matter of motivation to see the problems and actually wanting to solve them. And it's a societally effort
12:49 < bridge> <Jupstar ‚ú™> Some problems are simply complex and need lot of workers etc
12:50 < bridge> <Jupstar ‚ú™> But yes i could imagine that this could at least be a starting factor to talk about it more
12:50 < bridge> <Jupstar ‚ú™> Like if climate crisis hits harder. We will think about it more. But if we unlucky it will actually even demotivate ppl
12:50 < bridge> <Jupstar ‚ú™> We'll see
12:51 < bridge> <Jupstar ‚ú™> I guess there is no definite answer^^
12:51 < bridge> <teero777> thx for convo school is boring ^^
12:52 < bridge> <teero777> I might just invent something new
12:52 < bridge> <Jupstar ‚ú™> Creating something is also a matter of discipline
12:53 < bridge> <Jupstar ‚ú™> Sometimes it's hard and annoying and boring
12:53 < bridge> <Jupstar ‚ú™> And if u give up because of that.. rip
12:58 < bridge> <learath2> There are a couple things that were greatly accelerated by war and insane war budgets. The jet engine and radar technology both come to mind. Also the tiny vacuum tube transistors the US got made.
13:00 < bridge> <learath2> Isn't it just less efficient than the precast concrete buildings we make nowadays?
13:04 < bridge> <Jupstar ‚ú™> I bet the science behind these technologies were invented long before and probably not even by the military
13:04 < bridge> <Jupstar ‚ú™> So the missing piece was cheap labor force or whatever was expensive about these processes
13:05 < bridge> <learath2> That's true. Most was already discovered. Just needed the stupid levels of war budget
13:06 < bridge> <Jupstar ‚ú™> Depends on the size of the buildings i guess. But in the end it probably also doesn't matter how high the price is.. at least in European countries u are probably low on humans rather than money xd
13:08 < bridge> <learath2> I'd actually argue it's neither money nor labour. It's just not good for the old people in charge to build more. If they build more their own homes lose value
13:09 < bridge> <Jupstar ‚ú™> Xd
13:09 < bridge> <learath2> If they needed workers they would import them from wherever. When germany needed workers turkey was happy to oblige
13:09 < bridge> <Jupstar ‚ú™> True
13:26 < bridge> <Mr.Gh0s7> As @gotroyb / (@gotroyb) would say C99 is the best language to build upon. But it still has problems. :tee_thinking:. So if the best things have problems why do invent new things which are easier to grasp at first but got more problems? Maybe it's because we want ppl to use smt that will not inovate things. (btw do not take this serious I just typed a word which would make sense after the previous with the context.)
13:27 < bridge> <Mr.Gh0s7> As @gotroyb / (gotroyb) would say C99 is the best language to build upon. But it still has problems. :tee_thinking:. So if the best things have problems why do invent new things which are easier to grasp at first but got more problems? Maybe it's because we want ppl to use smt that will not inovate things. (btw do not take this serious I just typed a word which would make sense after the previous with the context.)
13:28 < bridge> <teero777> I read the msg and I can't remember a single word
13:28 < bridge> <teero777> C best language tho
13:28 < bridge> <Mr.Gh0s7> See this ```I just typed a word which would make sense after the previous with the context.``` worked
13:28 < bridge> <teero777> ghostGPT
13:28 < bridge> <Mr.Gh0s7> It was I.
13:34 < bridge> <teero777> https://cdn.discordapp.com/attachments/293493549758939136/1164526893073170442/RDT_20231019_1333546757833912248675785.jpg?ex=6543892f&is=6531142f&hm=a945eb2105ce21256ecb29d9f07d9b08a7ab1160916fd348d80a7a44fdc44caa&
13:35 < bridge> <zogtib> Most annoying thing (my opinion) with not C programming languages is that they don't actually fix the many problems C has but instead add many other and very annoying problems. So, in the end, C is still a very good option, which is sad, because something with less problems would worth it (if it actually has less problems).
13:36 < bridge> <ryozuki> wrong opinion
13:37 < bridge> <ryozuki> rust fixes the biggest issue with C, it prevents memory unsafety (not totally, but an improvement is better than nothing), it also helps preventing data races
13:37 < bridge> <ryozuki> u just dont want to accept progress
13:38 < bridge> <ryozuki> the only place where rust is less right now is: support for obscure platforms (which is not a problem of the language itself, but a problem of the compiler backend implementation), and compile times (atleast vs C which compiles fast iirc)
13:38 < bridge> <reitw> many lagn
13:38 < bridge> <reitw> many lang does fix lol
13:38 < bridge> <ryozuki> rust is as fast as C
13:39 < bridge> <reitw> just you'll loose stuff such as performance
13:39 < bridge> <reitw> (gc etc...), but rust does fix C issues without loosing perf
13:42 < bridge> <zogtib> Rust doesn't have the simplicity and the clarity C code can have (as I understand Rust by now) and that has great value by me. I'd better debug clearly-written programms instead of a big complicated stuff that its (only?) good is that is does not do invalid memory accesses and runs fast.
13:42 < bridge> <zogtib> Rust doesn't have the simplicity and the clarity C code can have (as I understand Rust by now) and that has great value for me. I'd better debug clearly-written programms instead of a big complicated stuff that its (only?) good is that is does not do invalid memory accesses and runs fast.
13:42 < bridge> <ryozuki> the clarity of C is a double edge
13:42 < bridge> <ryozuki> it hurts you more than not
13:42 < bridge> <Jupstar ‚ú™> @gotroyb be honest, did u code rust for at least 6 months? xd
13:43 < bridge> <ryozuki> but by what ur saying it shows u rly havent tried rust
13:43 < bridge> <ryozuki> jupstar was the same
13:43 < bridge> <ryozuki> :justatest:
13:43 < bridge> <reitw> tbh Rust is hard when you start
13:43 < bridge> <ryozuki> i think
13:43 < bridge> <reitw> but after it's pure enjoyment
13:43 < bridge> <ryozuki> C is hard too if u dont know C like langs
13:43 < bridge> <Jupstar ‚ú™> i was always pro rust. and tbf i still think some things are annoying xd
13:43 < bridge> <ryozuki> no u werent, i remember u not knowing rust
13:43 < bridge> <Jupstar ‚ú™> i'm less of a fanboy than u xd
13:43 < bridge> <ryozuki> xd
13:44 < bridge> <ryozuki> i also acknowledge annoying things in rust
13:44 < bridge> <ryozuki> and whish to be fixed
13:44 < bridge> <teero777> @ryozuki send good rust books
13:44 < bridge> <Jupstar ‚ú™> yes but i learned it, because i accepted that i should learn it xd
13:44 < bridge> <reitw> yes but C is very small  and "easy", like there's ,ot much stuff to learn tho. Only the way devs will write their code will make things harder
13:44 < bridge> <ryozuki> the oficial rust book
13:44 < bridge> <ryozuki> 
13:44 < bridge> <ryozuki> https://doc.rust-lang.org/book/
13:44 < bridge> <ryozuki> atomics
13:44 < bridge> <ryozuki> https://marabos.nl/atomics/
13:44 < bridge> <ryozuki> and https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/
13:44 < bridge> <learath2> C is hot asf. Best language ever conceived
13:45 < bridge> <heinrich5991> wdym by that?
13:45 < bridge> <learath2> It's proof of intelligent creation
13:45 < bridge> <Jupstar ‚ú™> @ryozuki xddd
13:45 < bridge> <ryozuki> rust is, its proof of improvement without a sacrificy thought to be needed (runtime speed with gained safety)
13:45 < bridge> <reitw> ho lol the atomics book is definetly smth I need to read lmao
13:45 < bridge> <ryozuki> read it, its one of the best books
13:45 < bridge> <reitw> ty
13:45 < bridge> <ryozuki> its online btw
13:46 < bridge> <reitw> yeah saw
13:46 < bridge> <heinrich5991> windows is largely written in C++ afaik
13:46 < bridge> <Jupstar ‚ú™> if you have a living standard that allows you to not care too much about money.. u can concentrate more about being innovative
13:46 < bridge> <learath2> You meant C, right?
13:46 < bridge> <reitw> scratch :giga_chad:
13:46 < bridge> <zogtib> I remember that I was learning OpenGL using C, but then learned about Rust and that felt that it could do things better and "clearer", like "match" etc, but I got annoyed by its pursue to hide complexity by introducing more complexity.
13:46 < bridge> <learath2> It's the pursuit of every modern language. Extreme abstraction
13:47 < bridge> <Jupstar ‚ú™> i think rust's enums are one of the coolest things. they are a clean way to represent variants
13:47 < bridge> <Jupstar ‚ú™> match is at least as clean as a switch
13:48 < bridge> <learath2> True. Rust enums are probably the best thing about rust after the way errors are handled
13:48 < bridge> <zogtib> I mean I'd better write `if (a > 0) { ... } else if (a < 0)`  instead of `use std::signs; match signs::of(num) signs::Positive: ... signs::Negative: ...`
13:48 < bridge> <Jupstar ‚ú™> in the context of enums actually cleaner, bcs you can only handle the data if you match the enum
13:48 < bridge> <Jupstar ‚ú™> 
13:48 < bridge> <Jupstar ‚ú™> 
13:48 < bridge> <Jupstar ‚ú™> not like switch a.type {...}
13:48 < bridge> <heinrich5991> C code is not "simple" for me. e.g. any addition can invoke UB
13:48 < bridge> <learath2> There isn't a single thing I hate more than exceptions in programming I think
13:49 < bridge> <Jupstar ‚ú™> but u can do that
13:49 < bridge> <Jupstar ‚ú™> i'd also not write the sign stuff xD
13:50 < bridge> <ryozuki> C is not simple if u know its  a minefield
13:50 < bridge> <ryozuki> im never too sure about anything
13:50 < bridge> <teero777> so that's why we have -wno-exceptions in ddnet xdd
13:50 < bridge> <ryozuki> whereas i  rust i am
13:50 < bridge> <heinrich5991> wdym by exceptions? automatically propagated errors? errors not appearing the type signature?
13:50 < bridge> <learath2> When use is_odd and is_even crate?
13:50 < bridge> <Jupstar ‚ú™> xdd
13:50 < bridge> <zogtib> C *does* have its problems and they are not tiny. But alternatives seem worse to me.
13:50 < bridge> <Jupstar ‚ú™> honestly, you can write rust code that is pretty similar to c, u just have to accept using unsafe
13:51 < bridge> <zogtib> Also Ada has safety features etc without overcomplicating everything.
13:51 < bridge> <ryozuki> unsafe still has strong guarantee s
13:51 < bridge> <teero777> Btw what happened to carbon?
13:51 < bridge> <Jupstar ‚ú™> pointers alone can easily destroy most of these (if you really want to).. not saying it is good üòÑ
13:51 < bridge> <ryozuki> but of u dont know what u doing it can be a stronger minefield
13:51 < bridge> <learath2> I hate both aspects. If you HAVE to have an exception system in your language it shouldn't have automatic propagation and you should be forced to enumerate all possible errors from every function
13:52 < bridge> <heinrich5991> it seems to me that rust isn't "overcomplicating" C, to me it's what has to happen inside my brain in order to write C, but it's not chhecked there
13:52 < bridge> <heinrich5991> does ada have protection against dangling pointers? afaik no
13:52 < bridge> <learath2> Exceptions lead to "Unhandled Exception"s. Always
13:52 < bridge> <ryozuki> yes but in unsafe rust code u need to uphold to more stuff than in C, you need to make sure safe code cant do ub
13:52 < bridge> <heinrich5991> just announced so far. creator told us to use rust if we want a usable language right now
13:53 < bridge> <heinrich5991> so java's checked exceptions are actually a step up from C++'s unchecked ones? I tend to agree
13:53 < bridge> <zogtib> So I can sell simplicity for longer compile times? What would that worth it?
13:53 < bridge> <Jupstar ‚ú™> my point is really. if u just wrap everything in unsafe, u can write code similar to c.. with some differences ofc. but it feels similary low level
13:53 < bridge> <zogtib> So I can sell simplicity for longer compile times? What would that worth?
13:53 < bridge> <learath2> Have you tried zig? It's not the worst
13:53 < bridge> <heinrich5991> I don't think you'll get longer compile times if you write a better-C dialect of rust
13:53 < bridge> <heinrich5991> the long compile times come from using the non-C features
13:54 < bridge> <zogtib> what problem of C would that solve?
13:54 < bridge> <learath2> I've also enjoyed D, but haven't used for any significant time
13:54 < bridge> <learath2> Borrow checker might help
13:55 < bridge> <zogtib> haven't actually tried it, but its syntex felt annoying (not a too serious problem tho)
13:55 < bridge> <heinrich5991> the problem that no one seems to be able to write safe, nontrivial C programs
13:55 < bridge> <heinrich5991> inb4 "I can" üòâ
13:55 < bridge> <Jupstar ‚ú™> @gotroyb i generally agree that compile times are a problem of rust.
13:55 < bridge> <Jupstar ‚ú™> 
13:55 < bridge> <Jupstar ‚ú™> But on the other side. since u have a really great ecosystem it's easy to add high quality libraries to your project, it works cross platform.  that alone saves lot of time often
13:55 < bridge> <learath2> I can üòâ
13:55 < bridge> <heinrich5991> x
13:55 < bridge> <Jupstar ‚ú™> in my current rust project i have not a single build script.. yet everything works
13:55 < bridge> <reitw> I can do just a printf("Hello world\n); & consider it safe
13:56 < bridge> <reitw> I can do just a printf("Hello world\n"); & consider it safe
13:56 < bridge> <learath2> Nontrivial
13:56 < bridge> <reitw> ah
13:56 < bridge> <teero777> just think harder lul
13:56 < bridge> <heinrich5991> let's add network interaction so we have a threat model?
13:57 < bridge> <heinrich5991> or do you have an example in mind?
13:57 < bridge> <learath2> It's actually an unfalsifiable statement. If I wrote one it would be an exception rather than the rule
13:57 < bridge> <heinrich5991> why unfalsifiable?
13:57 < bridge> <zogtib> Well, C programs don't just magically work just because I write them, I think that the effort spent making them complete is worth it instead of overcomplicating things by adding a ton of other names etc.
13:58 < bridge> <heinrich5991> but C programs seem to magically have security vulnerabilities üôÇ
13:58 < bridge> <learath2> Well your initial statement would be disproven since you said no one. But you'd quickly update it to "not many people" and everyone will clap and I'll have wasted a couple dozen hours of my life
13:58 < bridge> <Jupstar ‚ú™> @learath2 tbh my biggest problem with exceptions is not using them together with RAII.
13:58 < bridge> <Jupstar ‚ú™> 
13:58 < bridge> <Jupstar ‚ú™> that often leads to weird bugs, even if u handle exceptions.
13:58 < bridge> <Jupstar ‚ú™> 
13:59 < bridge> <Jupstar ‚ú™> Java imo is a good example
13:59 < bridge> <Jupstar ‚ú™> c++ at least in this case is actually better
13:59 < bridge> <Jupstar ‚ú™> (and ofc it's hard to do it right, generally)
14:00 < bridge> <learath2> The way raii and exceptions interact is also quite hard for a new learner. Overall very meh feature
14:00 < bridge> <heinrich5991> you also have that in rust, "panics"
14:00 < bridge> <zogtib> One guy that worked on a Rust-written GNU-coreutils implementation said that GNU-coreutils has had just a few vulerenabilities in so many years and that they are not rewritting them in Rust for security reasons.
14:01 < bridge> <heinrich5991> I think even glibc recently had an exploitable bug
14:01 < bridge> <learath2> The argument is always that some of those vulnerabilities couldn't have happened with rust
14:01 < bridge> <zogtib> Rust also has had many vulerenabilities itself? not necessary memory-related
14:02 < bridge> <learath2> The argument against that one is that Rust doesn't claim to eliminate all errors. It eliminates a couple classes of errors
14:02 < bridge> <heinrich5991> IME the bugs that rust reports are usually things that wouldn't even be classified as bugs in C
14:03 < bridge> <Jupstar ‚ú™> i'd say rust tries to force you to make a better design over your program.
14:03 < bridge> <Jupstar ‚ú™> 
14:03 < bridge> <Jupstar ‚ú™> it e.g. doesn't prevent dead locks, but with a clear hierarchy you could evade most of these problems
14:03 < bridge> <Jupstar ‚ú™> 
14:03 < bridge> <Jupstar ‚ú™> Memory safety is given in safe rust. that eliminates many problems.
14:03 < bridge> <Jupstar ‚ú™> 
14:03 < bridge> <Jupstar ‚ú™> If you use Arc only with the said hierarchy you also should fall into traps like memory leaks
14:03 < bridge> <Jupstar ‚ú™> overall rust at least helps you. it doesnt enforce everything that is needed to say it's the 100% safe alternative, but that's probably also not its goal
14:03 < bridge> <heinrich5991> see e.g.: https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html
14:03 < bridge> <heinrich5991> two links that appear from the ddg search for "rust cve"
14:04 < bridge> <Jupstar ‚ú™> i'd say rust tries to force you to make a better design over your program.
14:04 < bridge> <Jupstar ‚ú™> 
14:04 < bridge> <Jupstar ‚ú™> it e.g. doesn't prevent dead locks, but with a clear hierarchy you could evade most of these problems
14:04 < bridge> <Jupstar ‚ú™> 
14:04 < bridge> <Jupstar ‚ú™> Memory safety is given in safe rust. that eliminates many problems.
14:04 < bridge> <Jupstar ‚ú™> 
14:04 < bridge> <Jupstar ‚ú™> If you use Arc only with the said hierarchy you also should not fall into traps like memory leaks
14:04 < bridge> <heinrich5991> both of these would probably be considered "working just fine" in C/C++
14:04 < bridge> <zogtib> Personally, I'm not ready to sell C's simplicity for Rust's safety. I might be if I got fed up with C unsafety. But doesn't seem very likely to me now.
14:04 < bridge> <heinrich5991> give examples
14:04 < bridge> <heinrich5991> C isn't simple. it only looks simple before you know all the UB stuff
14:05 < bridge> <Jupstar ‚ú™> i don't want to lie. alone the fact that rust has RAII and c not. already makes so much stuff simpler
14:05 < bridge> <Jupstar ‚ú™> i dont see what u mean with simplcity
14:05 < bridge> <Jupstar ‚ú™> in c u code everything, even stuff that i'd call intuitive
14:05 < bridge> <heinrich5991> destructors are actually a thing that C really lacks
14:05 < bridge> <heinrich5991> it'd be really nice if you could just `defer free(a);` in C
14:06 < bridge> <heinrich5991> like in go
14:06 < bridge> <heinrich5991> I think there's a gcc extension for this
14:06 < bridge> <learath2> C is absolutely trivial compared to Rust. The UB stuff is unexpected but C just doesn't have the depth to compare to Rusts complexity
14:06 < bridge> <learath2> You can't have a box pin dyn send sync
14:06 < bridge> <heinrich5991> it's not simple to program in, and it doesn't have a simple model for your mind
14:06 < bridge> <heinrich5991> libtw2 also doesn't have that
14:07 < bridge> <heinrich5991> glib, however, has self-built vtables
14:07 < bridge> <heinrich5991> which I'd consider less simple than compiler support
14:07 < bridge> <zogtib> I prob remember some CVE's like you sent. I remember something about directory recursive deletion but maybe we'd just forget it for the current conversation, not a big deal even if rust had no CVEs
14:08 < bridge> <heinrich5991> the directory deletion thing would be considered "no bug" in C/C++
14:08 < bridge> <heinrich5991> the C++ std says that concurrent access to the filesystem is UB
14:08 < bridge> <heinrich5991> completely insane
14:08 < bridge> <learath2> I mean, is it really? It's less simple when programming but it's actually far more intuitive. Vtables are a very simple thing hidden behind lots of magic
14:09 < bridge> <heinrich5991> yes. just like having functions is more simple than having to invent your own calling conventions in x86 asm, e.g.
14:09 < bridge> <zogtib> It builds generally with a simple way upon what it has. So using C you get access to what C has with a "direct way".
14:10 < bridge> <heinrich5991> or stack variables are easier than manual stack management, structs are easier than only having access to primitive types
14:10 < bridge> <heinrich5991> C's idea of strings is also very bad, and not very performant
14:11 < bridge> <zogtib> for example, C gives you access to the filesystem (with libc let's say) but doesn't actually care what it does on higher level.
14:11 < bridge> <learath2> Actually idk how I let this one sneak by, just because you don't program like that doesn't mean no one does. You'll absolutely see a pin box dyn send sync hashmap box box pin
14:12 < bridge> <heinrich5991> not sure what you mean by this. rust gives you access to the file system in the same way
14:12 < bridge> <heinrich5991> I've been able to avoid it (in non-work related settings) ü§∑‚Äç‚ôÄÔ∏è
14:12 < bridge> <heinrich5991> hmm, maybe not
14:12 < bridge> <heinrich5991> the mastersrv
14:13 < bridge> <learath2> Also this I disagree with. You could say that the abstract machine has very little to do with the modern machines but it is an absolutely trivial machine
14:14 < bridge> <heinrich5991> I disagree. the rules around integer overflow, type promotion, pointer validity rules, all disagree with the simple model
14:14 < bridge> <zogtib> I mean that it's relation to the OS/filesystem is simple and clear, but the programmer has to take care of correctness. I'm not ready to accept much complexity so that I don't fall into incorrect behaviours.
14:14 < bridge> <heinrich5991> note that C's standard library actually buffers your files by default
14:15 < bridge> <heinrich5991> so you're not even close to the OS there
14:15 < bridge> <zogtib> I was thinking about systems calls rather than library calls.
14:15 < bridge> <heinrich5991> system calls have little to do with C
14:16 < bridge> <heinrich5991> you can do system calls from all sorts of languages, including C, rust, ‚Ä¶
14:16 < bridge> <zogtib> I did say libc but i was thinking about making available the `open(2)` function e.g.
14:16 < bridge> <heinrich5991> which is then implemented as `openat`
14:16 < bridge> <learath2> All languages have those available, C's wrappers are just very thin usually
14:16 < bridge> <heinrich5991> doesn't sound very transparent
14:17 < bridge> <heinrich5991> you can absolutely make these syscalls from rust, too. I participated in a rust stdlib rewrite using the syscalls directly
14:17 < bridge> <heinrich5991> was pretty fun üôÇ
14:18 < bridge> <zogtib> Using `open(2)`'s model is enough for many cases. Knowing all the details isn't something very practical.
14:18 < bridge> <zogtib> Using them from C seems more enjoyable.
14:19 < bridge> <learath2> We just seem to disagree about the level of abstraction. I like my wrappers thin. Rust people like them thick and featureful
14:19 < bridge> <heinrich5991> C is a bit preferred here, not because it's a good language, but because it was chosen (maybe implicitly) to be the model for POSIX interactions
14:19 < bridge> <heinrich5991> rust's `File` is less of an abstraction than C's `FILE *`
14:20 < bridge> <heinrich5991> but it actually works well on windows and linux ^^
14:20 < bridge> <zogtib> I prefer C over Rust, it's not that Rust is useless compared to C (Rust solves *many* problems C has) but I don't like Rust's solution to those problems.
14:22 < bridge> <zogtib> I think `open(2)` existed already because of historical reasons?, so even if under the hood things changed, `open(2)` is still useful.
14:22 < bridge> <heinrich5991> `open(2)` still exists
14:22 < bridge> <zogtib> But even if it isn't, `openat(2)` is available.
14:23 < bridge> <heinrich5991> the syscall `open` still exists
14:23 < bridge> <heinrich5991> it's just not called by the glibc function `open` anymore
14:23 < bridge> <learath2> I would be very very very surprised if it's not about the same level given they provide similar features
14:24 < bridge> <learath2> The only way I can imagine it being a lower level abstraction is cheating like msvcrt
14:24 < bridge> <heinrich5991> C's `FILE *` has buffering
14:24 < bridge> <heinrich5991> rust's `File` is just a file descriptor
14:25 < bridge> <zogtib> If what `open(2)`'s manual fit's the programmer needs, then what it does in detail is not important imo.
14:25 < bridge> <heinrich5991> (rust's `File` is literally 4 byte in size on linux)
14:25 < bridge> <heinrich5991> it's not just a thin wrapper over the `open` syscall then, though
14:25 < bridge> <heinrich5991> it's about as thin as the `File::open` function in rust
14:26 < bridge> <learath2> As far as the standard is concerned what is buffering even?
14:26 < bridge> <heinrich5991> idk, you're the standard person üòÑ
14:26 < bridge> <heinrich5991> but it even has functions for adjusting the buffer
14:26 < bridge> <heinrich5991> in the standard
14:27 < bridge> <learath2> FILE could be whatever the implementor wants. Msvcrt uses that to implement it through a fake fileno table
14:27 < bridge> <heinrich5991> fact is, `FILE *` is buffered in all libcs that I know
14:27 < bridge> <heinrich5991> do you know any where it's not?
14:27 < bridge> <heinrich5991> musl, glibc, msvcrt all buffer AFAIK
14:27 < bridge> <Jupstar ‚ú™> wtf r u guys all even doin with filesystems xddd
14:27 < bridge> <Jupstar ‚ú™> 
14:27 < bridge> <Jupstar ‚ú™> i need open file, write file
14:27 < bridge> <Jupstar ‚ú™> maybe some helper functions like list directory
14:27 < bridge> <Jupstar ‚ú™> r u like coding the next sql database xdd
14:28 < bridge> <heinrich5991> list directory is not available in C
14:28 < bridge> <Jupstar ‚ú™> tru
14:28 < bridge> <Jupstar ‚ú™> times before c++17 were hard
14:29 < bridge> <heinrich5991> > Besides the system-specific information necessary to access the device (e.g., a POSIX file descriptor), each FILE object directly or indirectly holds the following:
14:29 < bridge> <heinrich5991> > 
14:29 < bridge> <heinrich5991> > 1. (C95) Character width: unset, narrow, or wide.
14:29 < bridge> <heinrich5991> > 2. (C95) Parse state for conversions between multibyte and wide characters (an object of type mbstate_t)
14:29 < bridge> <heinrich5991> > 3. Buffering state: unbuffered, line-buffered, fully buffered.
14:29 < bridge> <heinrich5991> > 4. The buffer, which may be replaced by an external, user-provided buffer.
14:29 < bridge> <heinrich5991> > 5. I/O mode: input, output, or update (both input and output).
14:29 < bridge> <heinrich5991> > 6. Binary/text mode indicator.
14:29 < bridge> <heinrich5991> > 7. End-of-file status indicator.
14:29 < bridge> <heinrich5991> > 8. Error status indicator.
14:29 < bridge> <heinrich5991> > 9. File position indicator, accessible as an object of type fpos_t, which, for wide streams, includes parse state.
14:29 < bridge> <heinrich5991> > 10. (C11) Reentrant lock used to prevent data races when multiple threads read, write, position, or query the position of a stream.
14:29 < bridge> <heinrich5991> https://en.cppreference.com/w/c/io/FILE
14:29 < bridge> <learath2> Where does rust shove these? I have a feeling we are not comparing equivalent abstractions
14:29 < bridge> <heinrich5991> rust's file has none of 1-10
14:29 < bridge> <heinrich5991> you can wrap a file in a `BufReader`
14:30 < bridge> <Jupstar ‚ú™> i could imagine that, if you code smth where low level filesystem access is important (even in rust) you might just use system related operations anyway (win32 on windows etc.)
14:30 < bridge> <heinrich5991> (you probably should, if you're not just reading the complete file)
14:30 < bridge> <heinrich5991> no need in rust, because it's just a thin wrapper here
14:30 < bridge> <Jupstar ‚ú™> yeah but like permission stuff and so on
14:31 < bridge> <Jupstar ‚ú™> or does all this exist as wrapper?
14:31 < bridge> <learath2> Ok, so these are not the same abstractions. C doesn't have a similar thin wrapper for files
14:31 < bridge> <heinrich5991> it doesn't do 1,2. 3,4: buffering can be done by wrapping it in a `BufReader`, 5,6,7,8,9 is not done in rust, 10 is guaranteed by rust's guarantees
14:31 < bridge> <heinrich5991> correct
14:32 < bridge> <heinrich5991> so rust has a thinner abstraction around files than C does
14:32 < bridge> <zogtib> You mean than C libc does.
14:32 < bridge> <Jupstar ‚ú™> man alone not having unicode support must suck in c
14:32 < bridge> <Jupstar ‚ú™> u HAVE to use win32 api
14:32 < bridge> <Jupstar ‚ú™> xd
14:33 < bridge> <heinrich5991> I mean C. you might be talking about POSIX, linux C or libraries
14:33 < bridge> <heinrich5991> I mean C. you might be talking about POSIX, C on linux or libraries
14:33 < bridge> <learath2> It's a little disingenuous when no one would use those
14:33 < bridge> <heinrich5991> no one uses `FILE *`?
14:34 < bridge> <learath2> No `File` you almost always want a bufreader or bufwriter
14:34 < bridge> <heinrich5991> yes, but that's simpler, no?
14:34 < bridge> <heinrich5991> you don't put all the abstractions into one big file struct
14:34 < bridge> <learath2> It exists but almost everyone will be using the fatter abstraction
14:34 < bridge> <heinrich5991> even with `BufReader`, it's still thinner than C's stuff
14:35 < bridge> <learath2> Through having a fatter abstraction for strings iirc
14:35 < bridge> <heinrich5991> in what way?
14:35 < bridge> <heinrich5991> you mean having one at all?
14:35 < bridge> <Jupstar ‚ú™> fater abstraction = more code?
14:35 < bridge> <Jupstar ‚ú™> 
14:35 < bridge> <Jupstar ‚ú™> or fater abstraction = less performance?
14:36 < bridge> <Jupstar ‚ú™> i kinda have the feeling this isnt clear in this conversation
14:36 < bridge> <heinrich5991> I think we agreed on the fact that C and rust code is in the same league for speed
14:36 < bridge> <learath2> C strings are nothing but a bunch of bytes. That's why we need to keep track of the wchar stuff
14:36 < bridge> <heinrich5991> no, C strings are nul-terminated char arrays
14:36 < bridge> <ryozuki> rust strings can be faster, null terminator was a bad decision
14:36 < bridge> <Jupstar ‚ú™> ok then
14:36 < bridge> <Jupstar ‚ú™> fat as in more code for the user to write?
14:36 < bridge> <Jupstar ‚ú™> or fat as in the standard is more fat?
14:36 < bridge> <heinrich5991> `char *` can refer to a pointer to a `char` or to such a C string
14:37 < bridge> <heinrich5991> `char *` can refer to a pointer to a `char` or to such a C string, or to a pointer to a `char` array, even
14:37 < bridge> <learath2> Since when are null terminated char arrays are not a bunch of bytes?
14:37 < bridge> <heinrich5991> it just doesn't say
14:37 < bridge> <heinrich5991> because they carry an additional guarantee
14:37 < bridge> <learath2> Ok, done for the day
14:37 < bridge> <ryozuki> pack it up we done
14:38 < bridge> <zogtib> All details are not important all of the time. Also C standards have long history so they can't just appear perfect, so I don't mean "just the standarised C" as C.
14:39 < bridge> <Jupstar ‚ú™> lmao, don't be sad over programming languages. if you like c so much use it. it's your life and your time and if u like it so much do it
14:39 < bridge> <zogtib> Thanks for sharing your opinions and knowledge with me, have nice days. Cheers üôÇ
14:39 < bridge> <ryozuki> ye its just a discussion
14:39 < bridge> <ryozuki> end of the day each uses the lang they want
14:40 < bridge> <Jupstar ‚ú™> no, don't use python üò¨
14:40 < bridge> <heinrich5991> <flamebait>but people writing critical software hopefully don't use C</flamebait>
14:40 < bridge> <heinrich5991> <flamebait>but people writing critical software hopefully don't start their new projects in C</flamebait>
14:40 < bridge> <ryozuki> they use ada
14:41 < bridge> <learath2> I don't care about your opinion of C, nor do I care about @heinrich5991's opinion on C. I'm just annoyed at the disingenuous bad faith discussion techniques employed
14:41 < bridge> <_voxeldoesart> programmer tone tags
14:41 < bridge> <Jupstar ‚ú™> at the end of the day, i don't want to sit in a plane that panics, nor runs on UB
14:41 < bridge> <Jupstar ‚ú™> 
14:41 < bridge> <Jupstar ‚ú™> so just proof the software or smth
14:42 < bridge> <heinrich5991> I'm sorry. maybe we can come together some other time
14:42 < bridge> <ryozuki> i think u call disingenuous any argument not in ur favour tho
14:42 < bridge> <Mr.Gh0s7> UB as in go to your destination. Go to Heaven!
14:42 < bridge> <zogtib> OpenBSD say they are serious about security and they use C, I'm just letting you know.
14:42 < bridge> <ryozuki> ppl use /s for sarcasm btw
14:42 < bridge> <learath2> They don't know shit
14:42 < bridge> <heinrich5991> it wasn't sarcasm
14:43 < bridge> <heinrich5991> it was flamebait
14:43 < bridge> <ryozuki> sarcasm is often used for that
14:43 < bridge> <ryozuki> anyway
14:43 < bridge> <_voxeldoesart> yeah but tonetags suck and most are infantilizing
14:43 < bridge> <Jupstar ‚ú™> but he was serious af about it
14:44 < bridge> <learath2> Yes
14:44 < bridge> <ryozuki> my take is, ill take rust complexity that maintains same speed as C but with improved safety
14:44 < bridge> <ryozuki> and i enjoy it
14:45 < bridge> <Jupstar ‚ú™> i don't have an opinion about it, because i don't use it as a daily driver.
14:45 < bridge> <Jupstar ‚ú™> 
14:45 < bridge> <Jupstar ‚ú™> But i know concepts i use, and that i like that c is missing.
14:46 < bridge> <ryozuki> but C simplicity is often just at face value, digging deeper it becomws complex because you need to be aware and careful of lot of stuff, ur cognitivie load comes later, when u need to fix those bugs, or when ur thinking how to do X safely
14:46 < bridge> <ryozuki> in rust the cognitive load comes at compile time, at ur initial write
14:46 < bridge> <zogtib> You actually need to know how make things right?
14:46 < bridge> <learath2> It's like talking about how calculus is a thin abstraction over zermelo-fraenkel set theory. Just because thin layers exist along the way
14:46 < bridge> <ryozuki> altho u can avoid the load initially by using simpler stuff but less fast
14:46 < bridge> <ryozuki> which is how u protoptype
14:47 < bridge> <Jupstar ‚ú™> in fact sometimes u just accept it, because it would bloat software a lot
14:47 < bridge> <ryozuki> there is a difference between knowimg how to make things and how to make things correctly and safe
14:47 < bridge> <zogtib> You actually need to know how make things, right?
14:47 < bridge> <Jupstar ‚ú™> well remove the "sometimes"
14:47 < bridge> <Jupstar ‚ú™> always
14:47 < bridge> <Jupstar ‚ú™> in the end c is high level compared to asm xD
14:48 < bridge> <_voxeldoesart> i wonder what rust feature will benefit the ddnet code if it ever replaced the server code
14:48 < bridge> <_voxeldoesart> like, i imagine rust has some unique function that c doesnt
14:48 < bridge> <ryozuki> it wont make ddnet faster
14:48 < bridge> <ryozuki> it may avoid segfaults
14:48 < bridge> <ryozuki> altho a rewrite maybe improves perf by encountering optimization oportunities
14:48 < bridge> <Jupstar ‚ú™> i'd say derive macros and struct enums
14:49 < bridge> <_voxeldoesart> i dont care about speed in this arguement LOL
14:49 < bridge> <ryozuki> ?
14:49 < bridge> <_voxeldoesart> oo
14:49 < bridge> <ryozuki> a new lang wont bring new ingame features
14:49 < bridge> <learath2> Saying C has the level of complexity of Rust is like saying  a casio watch calculator is comparable to a modern octocore cpu
14:49 < bridge> <ryozuki> C has delayed complexity
14:49 < bridge> <Jupstar ‚ú™> but it has different answers to the same problem ^^
14:49 < bridge> <ryozuki> u still need to think about what rust solves for u
14:49 < bridge> <Jupstar ‚ú™> and these answers might be more fitting
14:50 < bridge> <ryozuki> maybe iterators improve stuff
14:50 < bridge> <learath2> I'm not saying rust doesnt solve problems. I'm saying it doesnt solve them at no complexity cost
14:50 < bridge> <ryozuki> yeah sure, but complexity is abstract
14:50 < bridge> <Jupstar ‚ú™> the fact that i can easily serialize data types for example is great compared to c (which has no concept of typeids) and even compared to c++, where it's probably still a mess
14:51 < bridge> <ryozuki> for me who i care about writimt correct safe software its hard im C
14:51 < bridge> <ryozuki> because there is lot of unknowns
14:51 < bridge> <ryozuki> the fix is to read the bible
14:51 < bridge> <ryozuki> learn the standard
14:51 < bridge> <ryozuki> fck mobile
14:51 < bridge> <learath2> Now open up serde docs and observe where the complexity is. Just because very smart people manage to hide it well doesnt mean rust is a very complex language
14:52 < bridge> <Jupstar ‚ú™> why do u need serde docs?
14:52 < bridge> <_voxeldoesart> i didnt read the c++ bible when i dived head first into ddnet code LOL
14:52 < bridge> <Jupstar ‚ú™> let's assume u use all fields you serialize (so no skip attribute or smth)
14:52 < bridge> <ryozuki> see thats a bad faith arg
14:52 < bridge> <ryozuki> its solving a complex problem about giving u a simple interface to seriakize stuff
14:53 < bridge> <Jupstar ‚ú™> for network stuff this makes sense for example
14:53 < bridge> <learath2> Using extremely complex language constructs that equivalents of don't even exist in C
14:53 < bridge> <ryozuki> yeah cuz u need to make them urself in c
14:53 < bridge> <Jupstar ‚ú™> but @learath2 what would u do in c?
14:54 < bridge> <learath2> You can't even make them in C, that sort of access to AST through macros don't exist
14:54 < bridge> <Jupstar ‚ú™> u'd need to manually verify every single data chunk is correct size (size > my struct)
14:54 < bridge> <Jupstar ‚ú™> 
14:54 < bridge> <Jupstar ‚ú™> then proof all fields individually etc.
14:54 < bridge> <ryozuki> well too bad
14:54 < bridge> <ryozuki> i prefer that vs textual macros
14:54 < bridge> <Jupstar ‚ú™> that is complex IMHO
14:54 < bridge> <ryozuki> also headers are complex
14:54 < bridge> <learath2> The discussion is about language complexity, not your preferences. I also prefer just automagically having my stuff serialized
14:55 < bridge> <zogtib> From my perspective: Rust's solutions (and Rust itself) are way more complex than a solution should be, and I find that as a big and primary problem.
14:55 < bridge> <ryozuki> i dont agree
14:55 < bridge> <learath2> If that is the measure of complexity then the best language is js
14:55 < bridge> <ryozuki> the problem rust tries to solve is rooy complex
14:55 < bridge> <ryozuki> if u know a simple solution u would get a Nobel prize
14:55 < bridge> <Jupstar ‚ú™> yes in that sense you are right. it's more complex behind the scnenes.. but therefore less complex in the scene itself üòÑ
14:55 < bridge> <_voxeldoesart> ive seen some solutions that are beautiful
14:55 < bridge> <Jupstar ‚ú™> less code = less potential for bugs
14:56 < bridge> <Jupstar ‚ú™> if serde is used widely, it _might_‚Ñ¢Ô∏è be more tested
14:56 < bridge> <ar1gin> wdym guys, rust is not complex at all
14:56 < bridge> <Jupstar ‚ú™> than anthing u ever write by yourself
14:56 < bridge> <_voxeldoesart> rust is complex but not complex
14:57 < bridge> <learath2> I guess I look at complexity of a language very differently than you seem to do. It's almost a linear function of the amount of features for me
14:57 < bridge> <Jupstar ‚ú™> It moves complexity
14:57 < bridge> <Jupstar ‚ú™> Imo intuitively is more important
14:57 < bridge> <Jupstar ‚ú™> And serde is intuitive
14:57 < bridge> <zogtib> What is the complexity it uses to move that complexity though?
14:58 < bridge> <Jupstar ‚ú™> In it's prime form
14:58 < bridge> <Jupstar ‚ú™> Derive macros
14:58 < bridge> <_voxeldoesart> when i inevitably make a file generator ill use rust so my own code doesnt trash my own pc
14:58 < bridge> <Jupstar ‚ú™> Basically a mini compiler
14:59 < bridge> <Jupstar ‚ú™> U know the attributes of the structure etc
14:59 < bridge> <learath2> Even more powerful. Procmacros have access to the compiler itself, not a separate precompiler
14:59 < bridge> <Jupstar ‚ú™> Yes it's a fully working program
14:59 < bridge> <Jupstar ‚ú™> U can do anything u want
15:00 < bridge> <learath2> It's almost like monkeypatching the compiler itself
15:00 < bridge> <Jupstar ‚ú™> But let's be fair. In this case u wouldn't need to do this
15:00 < bridge> <Jupstar ‚ú™> Yep
15:07 < bridge> <learath2> Nothing really except for some hobby projects. I see coding in C as mostly an artistic endeavour. Not much practical value in it
15:13 < bridge> <ryozuki> we all agree in one thing tho
15:13 < bridge> <ryozuki> linux is better than windows
15:13 < bridge> <ryozuki> :poggers2:
15:13 < bridge> <Jupstar ‚ú™> And voxel took that personally
15:14 < bridge> <ryozuki> :owo:
15:14 < bridge> <heinrich5991> better in what way? ^^
15:14 < bridge> <heinrich5991> I like it better to work
15:18 < ws-client> <ChillerDragon> gnome looks nicer than windows ui
15:18 < bridge> <Jupstar ‚ú™> Next explosive opened xd
15:23 < bridge> <ryozuki> being open source is already a killer
15:24 < ws-client> <ChillerDragon> yes that too
15:24 < ws-client> <ChillerDragon> oh and free
15:24 < ws-client> <ChillerDragon> lightweight
15:40 < bridge> <learath2> Can't even use directx12. Weak os
15:43 < bridge> <Jupstar ‚ú™> It can xd
15:46 < bridge> <learath2> Needs translator, not even native. Weak
15:49 < bridge> <Jupstar ‚ú™> Bloat
15:50 < bridge> <Jupstar ‚ú™> The abstraction could do smth similar to dxvk and allow to compile ur program directly to Vulkan using dx headers
15:52 < bridge> <Jupstar ‚ú™> Time to invent royalty free
15:52 < bridge> <Jupstar ‚ú™> Direct 4D 12
15:52 < bridge> <Jupstar ‚ú™> 
15:52 < bridge> <Jupstar ‚ú™> To convince the fan boys xd
15:52 < bridge> <ryozuki> vulkan better
15:52 < bridge> <learath2> Microsoft best ‚ù§Ô∏è
15:54 < bridge> <learath2> @jupeyy_keks when ddnet on dx?
16:06 < bridge> <Jupstar ‚ú™> U can always use it
16:06 < bridge> <Jupstar ‚ú™> Microsoft contributed a Vulkan to dx12 translator to Mesa xd
16:14 < bridge> <Mr.Gh0s7> tfw you stumble upon your own thread about a problem :feelsbadman: :feelsamazingman:
16:23 < bridge> <learath2> Tfw it only has one reply, it's wrong :ohno:
16:54 < bridge> <TsFreddie> https://github.com/darthdeus/comfy
16:56 < bridge> <teero777> @jupeyy_keks didn't think I'd spark a 800 message convo xdd
17:14 < bridge> <Jupstar ‚ú™> ah true, all your fault
17:14 < bridge> <Jupstar ‚ú™> xd
18:07 < bridge> <Jupstar ‚ú™> @ryozuki https://www.phoronix.com/review/amd-ryzen-threadripper-7000
18:08 < bridge> <Jupstar ‚ú™> 96 cores
18:08 < bridge> <Jupstar ‚ú™> can u buy me one
18:09 < bridge> <Jupstar ‚ú™> AMD Ryzen Threadripper PRO 7995WX: $9,999
18:09 < bridge> <Jupstar ‚ú™> wow, really cheap... not xd
18:17 < bridge> <ryozuki> xd
18:24 < bridge> <teero777> mee tooo
18:25 < bridge> <teero777> *cries in Intel Xeon E5420 (8) @ 2.499GHz*
19:48 < bridge> <cyberFighter> @_voxeldoesart
19:57 < bridge> <_voxeldoesart> tf
20:21 < bridge> <chairn> are you red or blue ?
20:21 < bridge> <chairn> https://www.reddit.com/r/ProgrammerHumor/comments/17bhp01/whichsideistheoneyougotusedto/
20:23 < bridge> <Jupstar ‚ú™> depends on the function
20:24 < bridge> <Jupstar ‚ú™> if u have early returns without any logic, u might want to not even call that function at all in first place
20:58 < bridge> <he11owor1d.> how to make a freeze bar was only seen by allies
20:59 < bridge> <he11owor1d.> how to make a freeze bar was only seen by allies on ddnet-skeleton?
20:59 < bridge> <he11owor1d.> how to make a freeze bar was only seen by allies on ddnet-skeleton server?
21:03 < bridge> <he11owor1d.> or replace freeze bar to stars
21:03 < bridge> <comebackplay> we have timeout ppl
21:03 < bridge> <comebackplay> can we fast get code?
21:03 < bridge> <comebackplay> or he will disconnect
21:03 < bridge> <comebackplay> swap
21:03 < bridge> <comebackplay> 2 hours run
21:03 < bridge> <comebackplay> 
21:03 < bridge> <comebackplay> 'viny ·µê·∂¶·µí' would have timed out, but can use timeout protection now
21:04 < bridge> <comebackplay> 45.141.57.22:8332
21:04 < bridge> <DDNet> 45.141.57.22:8332 is an official DDNet server. 
21:04 < bridge> <DDNet> <steam://run/412220//45.141.57.22:8332>/
21:04 < bridge> <he11owor1d.> or replace freeze bar to stars
21:04 < bridge> <he11owor1d.> I'm trying to make a fng mod
21:11 < bridge> <Jupstar ‚ú™> nobody has any code. if u have him in discord ask there
21:11 < bridge> <comebackplay> he timeout
21:11 < bridge> <comebackplay> its mean we cant contact with him
21:12 < bridge> <Jupstar ‚ú™> the only thing mods could potentially do is increase the timeout time
21:12 < bridge> <comebackplay> nobody have taht timeout code?
21:12 < bridge> <comebackplay> admins cant see that?
21:12 < bridge> <comebackplay> server know this code
21:12 < bridge> <Jupstar ‚ú™> i am not aware of that at least
21:12 < bridge> <Jupstar ‚ú™> server knows it yes
21:13 < bridge> <comebackplay> sad
21:13 < bridge> <comebackplay> he dropped
21:13 < bridge> <comebackplay> near finish
21:13 < bridge> <Jupstar ‚ú™> unlucky
21:34 < bridge> <warner6439> what do i need to do with the binary of clang on my debian? I wanna install clang 10 and this seems to be the only way to install it. do I need to unzip it or something?
21:34 < bridge> <warner6439> https://github.com/muttleyxd/clang-tools-static-binaries/releases
21:42 < bridge> <Jupstar ‚ú™> why do u want to use clang 10?
21:42 < bridge> <Jupstar ‚ú™> ddnet compiles just fine with newer ones
21:42 < bridge> <Jupstar ‚ú™> ah u mean clang-format
21:43 < bridge> <Jupstar ‚ú™> well depends:
21:43 < bridge> <Jupstar ‚ú™> - do you use some kind of IDE?
21:43 < bridge> <Jupstar ‚ú™> - do you just want to fix style?
21:44 < bridge> <Jupstar ‚ú™> the easiest is probably to copy it to /usr/local/bin/
21:44 < bridge> <Jupstar ‚ú™> that should be in your path i guess
21:44 < bridge> <warner6439> well yeah I just wanna fix the style
21:44 < bridge> <he11owor1d.> how to make a freeze bar was only seen by allies on ddnet-skeleton server? 
21:44 < bridge> <he11owor1d.> or replace freeze bar to stars
21:44 < bridge> <he11owor1d.> I'm trying to make a fng mod
21:45 < bridge> <warner6439> will try that, I guess I will have to rename it?
21:45 < bridge> <Jupstar ‚ú™> don't send them to the users that should not see them
21:45 < bridge> <Jupstar ‚ú™> i'd call it clang-format-10
21:45 < bridge> <warner6439> alright thank you.
21:46 < bridge> <he11owor1d.> i am dont know how this make
21:46 < bridge> <he11owor1d.> (sorry for my english)
21:46 < bridge> <Jupstar ‚ú™> fix_style.py also tries to find version 10
21:46 < bridge> <Jupstar ‚ú™> mh, maybe start with something easier then üòÑ
21:47 < bridge> <he11owor1d.> why?
21:47 < bridge> <Jupstar ‚ú™> to get a feeling for how the source code works
21:47 < bridge> <warner6439> yeah that's what I noticed, I don't have it installed and it seems that there is no actually package for v10
21:47 < bridge> <warner6439> yeah that's what I noticed, I don't have it installed and it seems that there is no actual package for v10
21:47 < bridge> <he11owor1d.> where do we start?
21:47 < bridge> <Jupstar ‚ú™> yeah sadly :/
21:48 < bridge> <Jupstar ‚ú™> i dunno, try edit some source code you think you understand
21:48 < bridge> <Jupstar ‚ú™> e.g. server messages, or changing player name/skin whatever
21:48 < bridge> <Jupstar ‚ú™> try to place stars into the map
21:49 < bridge> <he11owor1d.> can you give me a hint on how to do this?)
21:49 < bridge> <Jupstar ‚ú™> do you know c++?
21:50 < bridge> <he11owor1d.> on elementary level
21:50 < bridge> <he11owor1d.> or better yet, a hint on how to send the freeze bar only to allies)
21:50 < bridge> <Jupstar ‚ú™> i'd try to read through
21:50 < bridge> <Jupstar ‚ú™> https://github.com/ddnet/ddnet/blob/dad2c14abb3b89385fc2b8d1d1becd43206bad00/src/game/server/gamecontext.cpp
21:50 < bridge> <Jupstar ‚ú™> that is the most important file
21:51 < bridge> <Jupstar ‚ú™> i dunno how that file is called in ddnet-skeleton
21:51 < bridge> <Jupstar ‚ú™> i never used  that
21:51 < bridge> <he11owor1d.> —ç—Ç–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è —Å—Ç–æ–ø-–±–∞—Ä–∞?)
21:51 < bridge> <he11owor1d.> sry
21:51 < bridge> <he11owor1d.> is this a tip for a freeze bar?
21:52 < bridge> <he11owor1d.> or place start into the map?
21:52 < bridge> <Jupstar ‚ú™> CreateDamageInd
21:52 < bridge> <Jupstar ‚ú™> creates stars
21:53 < bridge> <he11owor1d.> ok, but how to send a freeze bar only to allies?
21:54 < bridge> <Jupstar ‚ú™> how should i answer this question without implementing it myself? xD
21:55 < bridge> <Jupstar ‚ú™> i'd try to see what network package contains information about the current freeze time
21:55 < bridge> <Jupstar ‚ú™> and only sent it to allies
21:55 < bridge> <he11owor1d.> Well, I would at least like the name of the function that sends the freeze bar to players)
22:00 < bridge> <Jupstar ‚ú™> https://github.com/ddnet/ddnet/blob/dad2c14abb3b89385fc2b8d1d1becd43206bad00/src/game/server/entities/character.cpp#L1228
22:00 < bridge> <Jupstar ‚ú™> this seems freeze related
22:00 < bridge> <Jupstar ‚ú™> for the other team u could simply set the skin to ninja skin or smth
22:00 < bridge> <Jupstar ‚ú™> i dunno if u can cleanly do what u want for FNG
22:00 < bridge> <Jupstar ‚ú™> the codebase favours ddrace
22:01 < bridge> <robyt3> The freeze bars are not sent to the players directly. The server sends `m_FreezeStart` and `m_FreezeEnd` for each tee (character)
22:01 < bridge> <robyt3> If you don't want the freezebars, only send 0 or -1 for both values I guess
22:02 < bridge> <robyt3> Then send the damage indicator stars manually
22:03 < bridge> <robyt3> Also with regards to ddnet-skeleton: https://discord.com/channels/252358080522747904/293493549758939136/1159155737738621051
22:12 < bridge> <_voxeldoesart> nuh uh dont remove stars from fng
22:17 < bridge> <he11owor1d.> why is TeamMask() the same for both teams? how can this be fixed?
22:23 < bridge> <he11owor1d.> 3 - this TeamMask() player 1
22:24 < bridge> <he11owor1d.> 0 - this Team() player 1
22:24 < bridge> <he11owor1d.> 3 - this TeamMask() player 2
22:24 < bridge> <he11owor1d.> 0  - this Team() palyer 2
22:24 < bridge> <he11owor1d.> 
22:24 < bridge> <he11owor1d.> player1 - Red Team
22:24 < bridge> <he11owor1d.> player2 - Blue Team
22:24 < bridge> <robyt3> I assume because ddnet-skeleton adds back the original red and blue teams without integrating DDNet team system with this properly
22:25 < bridge> <he11owor1d.> how this fix?
22:25 < bridge> <robyt3> Don't know, maybe use separate TeamMask for both teams
22:26 < bridge> <robyt3> Change `TeamMask()` to `TeamMask(int Team)` so you can get the mask for each team separately (and adjust the rest of the code accordingly)
22:27 < bridge> <he11owor1d.> a how to change int Team for blue team?
22:27 < bridge> <robyt3> There are constants in the code for the teams
22:28 < bridge> <robyt3> I'd recommend starting with something easier then trying to fix ddnet-skeleton
23:16 < bridge> <Mr.Gh0s7> I too tried to make a mod with ddnet-skeleton but quickly forgot about it :/
