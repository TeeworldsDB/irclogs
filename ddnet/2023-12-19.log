01:38 < bridge> <Ewan> lerato
04:37 < bridge> <stormaxd> 5 am, im finally done with 1st site in my life
04:37 < bridge> <stormaxd> hope last
04:37 < bridge> <stormaxd> rate pls
04:37 < bridge> <stormaxd> https://stormaxs.github.io/StA-site/
05:33 < bridge> <_voxeldoesart> wait what
05:33 < bridge> <_voxeldoesart> LERP tee animation?
05:33 < bridge> <_voxeldoesart> what does that mea
05:35 < bridge> <_voxeldoesart> also @stormaxd is it alright that i give out thoughts about this client?
05:36 < bridge> <stormaxd> Linear interpolation
05:36 < bridge> <stormaxd> Ofc, go for it
05:37 < bridge> <_voxeldoesart> on 2560x1440 the buttons arent centered LOL
05:37 < bridge> <_voxeldoesart> https://cdn.discordapp.com/attachments/293493549758939136/1186527605508284461/image.png?ex=659392f1&is=65811df1&hm=43cf6054bc6a56f729dfb86d4b6f55dabd3a46b1d1b49d2c92fd176c14724c4e&
05:37 < bridge> <stormaxd> I fixed it already
05:37 < bridge> <stormaxd> Someone reported me when i released it last time
05:38 < bridge> <stormaxd> Cause im planning to done with stat page and only then make a new release
09:06 < bridge> <Jupstar ‚ú™> The logo is missing an "r"
09:07 < bridge> <murpi> STA CLIENTR
09:07 < bridge> <ryozuki> troll
09:09 < bridge> <Jupstar ‚ú™> Trollr
09:09 < bridge> <stormaxd> Star client?:poggers2:
09:10 < bridge> <Jupstar ‚ú™> üòè
09:10 < bridge> <Jupstar ‚ú™> Also add ‚ú™
09:10 < bridge> <stormaxd> I can't
09:11 < bridge> <stormaxd> I haven't sleep almost 2 night
09:11 < bridge> <stormaxd> Let me
09:11 < bridge> <stormaxd> Sleep :pepeLost:
09:11 < bridge> <Jupstar ‚ú™> Ok, you can sleep for 10 minutes
09:12 < bridge> <stormaxd> :Deadge:
09:12 < bridge> <stormaxd> :blushWokege:
09:14 < bridge> <blaiszephyr> how dare he
09:14 < bridge> <blaiszephyr> stop sleeping - go work
09:14 < bridge> <stormaxd> alr alr
09:15 < bridge> <stormaxd> 1 buf fix
10:13 < bridge> <Jupstar ‚ú™> Rust needs a 'inline lifetime, that makes sure a reference is only valid for a single expression. Would be cool and useful
10:15 < bridge> <ryozuki> i mean cant u do that with a block {}
10:16 < bridge> <ryozuki> ```rust
10:16 < bridge> <ryozuki> let b = 2;
10:16 < bridge> <ryozuki> {
10:16 < bridge> <ryozuki>   let b = &b;
10:16 < bridge> <ryozuki> }
10:16 < bridge> <ryozuki> ```
10:16 < bridge> <ryozuki> use shadowing to achieve it
10:16 < bridge> <ryozuki> idk
10:16 < bridge> <Jupstar ‚ú™> I mean e.g. if i return a mut ref from function call
10:16 < bridge> <Jupstar ‚ú™> That you can't truly borrow this result
10:16 < bridge> <ryozuki> @jupeyy_keks there is something called fnonce
10:16 < bridge> <ryozuki> https://doc.rust-lang.org/std/ops/trait.FnOnce.html
10:16 < bridge> <ryozuki> Instances of FnOnce can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements FnOnce, it can only be called once.
10:17 < bridge> <ryozuki> idk how u could achieve that u want xd
10:17 < bridge> <ryozuki> but if u can only use the ref inside a fnonce
10:17 < bridge> <ryozuki> maybe its possible
10:17 < bridge> <Jupstar ‚ú™> Well what i actually want is to return a Ref<'inline, T>
10:17 < bridge> <Jupstar ‚ú™> Xd
10:17 < bridge> <ryozuki> xd
10:18 < bridge> <ryozuki> OnceCell?
10:18 < bridge> <ryozuki> ah no this is to write
10:18 < bridge> <ryozuki> idk
10:18 < bridge> <Jupstar ‚ú™> Yeah dunno. 2024 edition clearly needs a new rfc üò¨
10:18 < bridge> <ryozuki> well u should explain ur use case in depth
10:20 < bridge> <Jupstar ‚ú™> Yeah i want to return a borrow_mut.
10:20 < bridge> <Jupstar ‚ú™> But this is unsafe, in logic sense,  in combination with rc because you could end up borrow twice. But if the borrow would end every line+ i have a strict hierarchy of my types => safe af
10:21 < bridge> <Jupstar ‚ú™> Rn i am emulating with by not allowing public types and rewrite the public interface with a proc macro
10:22 < bridge> <Jupstar ‚ú™> Works well, but more hidden logic xdd
10:23 < bridge> <Jupstar ‚ú™> With some inline lifetime i could use deref trait
10:23 < bridge> <Jupstar ‚ú™> Would be clean af
10:25 < bridge> <ryozuki> deref should only be used by smart pointers btw
10:25 < bridge> <ryozuki> > Implementing Deref for smart pointers makes accessing the data behind them convenient, which is why they implement Deref. On the other hand, the rules regarding Deref and DerefMut were designed specifically to accommodate smart pointers. Because of this, Deref should only be implemented for smart pointers to avoid confusion.
10:25 < bridge> <ryozuki> > 
10:25 < bridge> <ryozuki> > For similar reasons, this trait should never fail. Failure during dereferencing can be extremely confusing when Deref is invoked implicitly.
10:25 < bridge> <ryozuki> > 
10:26 < bridge> <ryozuki> > Violating these requirements is a logic error. The behavior resulting from a logic error is not specified, but users of the trait must ensure that such logic errors do not result in undefined behavior. This means that unsafe code must not rely on the correctness of this method.
10:26 < bridge> <Jupstar ‚ú™> Well mine would be smart wrapper
10:37 < bridge> <Jupstar ‚ú™> the doc was recently updated btw:
10:37 < bridge> <Jupstar ‚ú™> https://github.com/rust-lang/rust/commit/58645e06d9121ae37654b812d14041d0229d49c3
10:39 < bridge> <Jupstar ‚ú™> so no smart-pointer
10:39 < bridge> <Jupstar ‚ú™> 
10:39 < bridge> <Jupstar ‚ú™> it must be fail safe, the wrapper type should not have API collisions
10:39 < bridge> <Jupstar ‚ú™> also should not != must not üòâ
10:42 < bridge> <Jupstar ‚ú™> With some inline lifetime i could use deref trait (the inline lifetime also needs other requirements, but too much to list them)
10:43 < bridge> <Jupstar ‚ú™> With some inline lifetime i could use deref trait (the inline lifetime also needs other requirements, but too much to list them, e.g. no inline lifetimes twice, or specific evaluation order of calls etc. xd)
10:43 < bridge> <learath2> Can't you take the mut borrow out of the rc?
10:44 < bridge> <Jupstar ‚ú™> what do you mean?
10:44 < bridge> <Jupstar ‚ú™> the whole Rc<RefCell>> would be wrapped in a smart wrapper
10:45 < bridge> <Jupstar ‚ú™> so u can never acess the refcell interface directly
10:46 < bridge> <learath2> Yes that's sort of what I meant
10:46 < bridge> <Jupstar ‚ú™> i mean i didnt 100% think though the best solution, but i think it would have potential xdd
10:46 < bridge> <Jupstar ‚ú™> i mean i didnt 100% think through the best solution, but i think it would have potential xdd
10:47 < bridge> <learath2> Or whatever function is returning the mut borrow would take the rc in exchange
10:47 < bridge> <Jupstar ‚ú™> but i can clone Rcs
10:48 < bridge> <learath2> But the refcell wont allow a second mut borrow and enforce it at runtime
10:48 < bridge> <Jupstar ‚ú™> yes that's exactly what i dislike xD
10:48 < bridge> <Jupstar ‚ú™> at runtime xD
10:48 < bridge> <learath2> Ah you want to avoid the refcell?
10:49 < bridge> <Jupstar ‚ú™> i want to avoid lifetime (rc) but also the problem of calling borrow_mut twice (refcell)
10:49 < bridge> <Jupstar ‚ú™> i have a solution for this, it's just not nicest to use, bcs it requires adding proc macros to many types.. so it's also not enforced in that sense anyway
10:50 < bridge> <Jupstar ‚ú™> the 'inline would also not enforce it, but it would make my solution more elegant xD
10:51 < bridge> <Jupstar ‚ú™> e.g. if you never have cycling refs (not even with Weak) ,also not by passing Rcs around, you should‚Ñ¢Ô∏è never have problems and still have the benefits of Rc
10:52 < bridge> <Jupstar ‚ú™> oh and hierarchically it is not allowed to have the same Rc on a child component if the parent has it already
10:52 < bridge> <learath2> Well idk your specifics but there isn't much harm in a refcell if that's the only way to ensure safety that's the only way to do it. It's just 1 branch
10:53 < bridge> <Jupstar ‚ú™> you are right and if you have a private field that is a refcell it's relatively safe
10:53 < bridge> <Jupstar ‚ú™> i also try to do it, if i use it.
10:53 < bridge> <Jupstar ‚ú™> 
10:53 < bridge> <Jupstar ‚ú™> i guess i am in adventurer mode rn xd
10:56 < bridge> <Jupstar ‚ú™> the only problem is smth like this:
10:56 < bridge> <Jupstar ‚ú™> 
10:56 < bridge> <Jupstar ‚ú™> ```rs
10:56 < bridge> <Jupstar ‚ú™> struct A { r: Rc<...> }
10:56 < bridge> <Jupstar ‚ú™> struct B { r: Rc<..>, a: A } // same rc as above
10:56 < bridge> <Jupstar ‚ú™> 
10:56 < bridge> <Jupstar ‚ú™> impl A { fn func() {r.borrow_mut().dosmth}}
10:56 < bridge> <Jupstar ‚ú™> impl B { fn func() {let borrowered = r.borrow_mut();
10:56 < bridge> <Jupstar ‚ú™> a.func(); // panic bcs and b will borrow_mut
10:56 < bridge> <Jupstar ‚ú™> }}
10:56 < bridge> <Jupstar ‚ú™> 
10:56 < bridge> <Jupstar ‚ú™> 
10:56 < bridge> <Jupstar ‚ú™> let b = B::...;
10:56 < bridge> <Jupstar ‚ú™> b.func();
10:56 < bridge> <Jupstar ‚ú™> ```
10:56 < bridge> <Jupstar ‚ú™> the 'inline lifetime could also also disallow being passed to a function etc.
10:57 < bridge> <Jupstar ‚ú™> well as said it only works under certain conditions, but it defs help to fuck up less in my case without having to have so many proc macros
10:57 < bridge> <Jupstar ‚ú™> the only problem is smth like this:
10:57 < bridge> <Jupstar ‚ú™> 
10:57 < bridge> <Jupstar ‚ú™> ```rs
10:58 < bridge> <Jupstar ‚ú™> struct A { r: Rc<...> }
10:58 < bridge> <Jupstar ‚ú™> struct B { r: Rc<..>, a: A } // same rc as above
10:58 < bridge> <Jupstar ‚ú™> 
10:58 < bridge> <Jupstar ‚ú™> impl A { fn func() {r.borrow_mut().dosmth}}
10:58 < bridge> <Jupstar ‚ú™> impl B { fn func() {let borrowered = r.borrow_mut();
10:58 < bridge> <Jupstar ‚ú™> a.func(); // panic bcs a and b will borrow_mut at same time
10:58 < bridge> <Jupstar ‚ú™> }}
10:58 < bridge> <Jupstar ‚ú™> 
10:58 < bridge> <Jupstar ‚ú™> 
10:58 < bridge> <Jupstar ‚ú™> let b = B::...;
10:58 < bridge> <Jupstar ‚ú™> b.func();
10:58 < bridge> <Jupstar ‚ú™> ```
11:01 < bridge> <Jupstar ‚ú™> now i am motivated to write test cases for my macro to find some of its limitations
11:01 < bridge> <Jupstar ‚ú™> 
11:01 < bridge> <Jupstar ‚ú™> thanks for movation üòè
11:13 < bridge> <learath2> Yeah this is suboptimal calling the functions while holding a borrow leading to a panic is bizarre feeling
11:14 < bridge> <ryozuki> its enforcing the borrow checker  at runtime
11:14 < bridge> <learath2> I'm more curious as to how you'd allow this pattern
11:15 < bridge> <ryozuki> whats the pattern i didnt read i was trying to fix my lalrpop pascal parser :/
11:15 < bridge> <ryozuki> >     <p:"packed"?> "array" "[" <index:CommaNoTrailing<ArrayIndexCompatibleType>> "]" "of" <c:Type> => ast::Type::Array {
11:15 < bridge> <ryozuki> >         index,
11:15 < bridge> <ryozuki> >         component: Box::new(c),
11:15 < bridge> <ryozuki> >         packed: p.is_some(),
11:15 < bridge> <ryozuki> >     },
11:15 < bridge> <ryozuki> >   and looking at a token `Eof` we can reduce to a `CommaNoTrailing<"identifier">` but we can also reduce to a `SemiColonNoTrailing<RecordSection>`
11:15 < bridge> <ryozuki> im dying
11:16 < bridge> <learath2> Technically while `a.func()` is happening you are already holding a mut ref outside it so it panics, but technically it's sane. The second mut borrow is the only one in scope
11:16 < bridge> <learath2> Like a two phase borrow
11:17 < bridge> <learath2> You can get rid of the refcell too. I'm just curious how a seasoned rust veteran would structure it
11:19 < bridge> <learath2> @jupeyy_keks is this components and cgameclient btw?
11:19 < bridge> <learath2> That's the sort of relationship those have
11:19 < bridge> <Jupstar ‚ú™> well you can do lot of stuff without Rc<RefCell>. sadly this can always increase complexity, by a lot, bcs u need to pass so much stuff around.
11:19 < bridge> <Jupstar ‚ú™> 
11:19 < bridge> <Jupstar ‚ú™> Generally i think this isn't even bad, it's just that i want to have some modules be very easy to use
11:20 < bridge> <ryozuki> generally u want to structure ur code to avoud refcells at all
11:20 < bridge> <Jupstar ‚ú™> for me it's more the interaction with the graphics component by two or more components
11:20 < bridge> <Jupstar ‚ú™> and still you use all these fancy libs that have a slim api. bcs they internally have Rc or Arcs
11:21 < bridge> <ryozuki> this code doesnt make sense, where do u get r in the B impl block
11:21 < bridge> <Jupstar ‚ú™> as said, it's a matter of simplicity
11:21 < bridge> <learath2> Yep that works too. So I guess the proper solution is for the components to not hold a ref to the graphics component
11:21 < bridge> <ryozuki> what libs
11:21 < bridge> <Jupstar ‚ú™> it's pseudo code
11:21 < bridge> <Jupstar ‚ú™> i dunno, like 90% of the libs allow me to clone their instance of whatever
11:22 < bridge> <ryozuki> ???
11:22 < bridge> <learath2> Yeah libs wrap their contexts in arcs
11:22 < bridge> <ryozuki> i hate arguments like that, u cant argue cuz its so vague
11:22 < bridge> <Jupstar ‚ú™> if you have a tokio runtime, u can just clone it and it's the same instance
11:22 < bridge> <Jupstar ‚ú™> 
11:22 < bridge> <Jupstar ‚ú™> if you clone some sound lib, you can clone the runtime and it will just work
11:22 < bridge> <learath2> Anyway, why are you arguing? RefCell bad has nothing to do with Arc bad
11:23 < bridge> <ryozuki> yeah arc is kinda the way to share refs between threads
11:23 < bridge> <Jupstar ‚ú™> well Arc<Mutex> has the exact same problem xD
11:23 < bridge> <ryozuki> they want to allow send
11:23 < bridge> <learath2> They don't require runtime borrow checking
11:23 < bridge> <Jupstar ‚ú™> true, it's even worse there
11:23 < bridge> <Jupstar ‚ú™> dead lock
11:23 < bridge> <ryozuki> well thats what uget when dealing with MT
11:23 < bridge> <ryozuki> but a arc alone wont deadlock u
11:23 < bridge> <ryozuki> its  when u use a lock
11:24 < bridge> <ryozuki> consider refcell like a single thread lock
11:24 < bridge> <Jupstar ‚ú™> yeah, but u cannot use arc and then write an API xd
11:24 < bridge> <Jupstar ‚ú™> 
11:24 < bridge> <Jupstar ‚ú™> is that a read-only API or what? XD
11:24 < bridge> <ryozuki> but ucant block xd
11:24 < bridge> <learath2> Anyway can we not drift away? How would one solve this? Just establish a hierarchy so you only pass a reference down instead of keeping an Rc everywhere?
11:24 < bridge> <ryozuki> btw
11:25 < bridge> <ryozuki> u have try_borrow
11:25 < bridge> <ryozuki> iirc
11:25 < bridge> <ryozuki> u can borrow from the rc on a upper level and pass a plain ref down
11:25 < bridge> <Jupstar ‚ú™> i mean B can read the rc of A. and if the borrow_mut would be guaranteed inline, without side effects, it would not compile
11:25 < bridge> <Jupstar ‚ú™> so yes, that is kinda my plan
11:26 < bridge> <Jupstar ‚ú™> my problem isn't so much about that you have to redsign this call a bit.
11:26 < bridge> <Jupstar ‚ú™> 
11:26 < bridge> <Jupstar ‚ú™> it can simply happen without you noticing it
11:26 < bridge> <Jupstar ‚ú™> that's what i dislike about it
11:27 < bridge> <learath2> Yeah, so I guess just don't have multiple references, pass it down instead
11:28 < bridge> <learath2> s\/references/Rcs/
11:28 < bridge> <Jupstar ‚ú™> yep, but for the graphic instance it would suck to always pass it around.
11:28 < bridge> <Jupstar ‚ú™> 
11:28 < bridge> <Jupstar ‚ú™> and i have a usecase where i potentially allow borrowing parts of the graphics api. so if 2 comps have the graphics cloned, this is problem xdd
11:29 < bridge> <ryozuki> ```rust
11:29 < bridge> <ryozuki> use std::{cell::RefCell, rc::Rc};
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> struct A {
11:29 < bridge> <ryozuki>     r: Rc<RefCell<String>>,
11:29 < bridge> <ryozuki> }
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> struct B {
11:29 < bridge> <ryozuki>     r: Rc<RefCell<String>>,
11:29 < bridge> <ryozuki>     a: A,
11:29 < bridge> <ryozuki> }
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> impl A {
11:29 < bridge> <ryozuki>     pub fn funca(&self) {
11:29 < bridge> <ryozuki>         let _ = self.r.borrow_mut();
11:29 < bridge> <ryozuki>     }
11:29 < bridge> <ryozuki> }
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> impl B {
11:29 < bridge> <ryozuki>     pub fn funcb(&self) {
11:29 < bridge> <ryozuki>         let borrowed = self.r.borrow_mut();
11:29 < bridge> <ryozuki>         self.a.funca();
11:29 < bridge> <ryozuki>     }
11:29 < bridge> <ryozuki> }
11:29 < bridge> <ryozuki> 
11:29 < bridge> <ryozuki> fn main() {
11:29 < bridge> <ryozuki>     let r: Rc<RefCell<String>> = Default::default();
11:29 < bridge> <ryozuki>     let x = B {
11:29 < bridge> <ryozuki>         r: r.clone(),
11:29 < bridge> <ryozuki>         a: A { r },
11:30 < bridge> <ryozuki>     };
11:30 < bridge> <ryozuki> ok so this is the code
11:30 < bridge> <ryozuki> it panics on borrow mut
11:30 < bridge> <Jupstar ‚ú™> thanks for taking the time
11:30 < bridge> <ryozuki> sadly i dont have much time tho
11:30 < bridge> <ryozuki> i gotta go to office
11:30 < bridge> <ryozuki> and i need to cook my meal
11:30 < bridge> <ryozuki> XD
11:30 < bridge> <Jupstar ‚ú™> gl
11:30 < bridge> <learath2> Just bite the unsafepill
11:30 < bridge> <learath2> Who cares what the borrowchecker thinks. Who is he anyway
11:30 < bridge> <Jupstar ‚ú™> xdd
11:31 < bridge> <Jupstar ‚ú™> well i'd already be happy to make it harder to fuck up xD
11:34 < bridge> <learath2> Survival of the fittest
11:34 < bridge> <Jupstar ‚ú™> true, but if i am an overpowered cyborg, i've higher chances üò¨
11:35 < bridge> <Jupstar ‚ú™> so i tune myself
11:41 < bridge> <learath2> You know what would be cool? Some sort of "call stack local" variable
11:41 < bridge> <learath2> That way any frame that comes after a frame that mutably borrows something can share that borrow
11:45 < bridge> <ryozuki> ```rust
11:45 < bridge> <ryozuki> use std::{cell::RefCell, rc::Rc};
11:45 < bridge> <ryozuki> 
11:45 < bridge> <ryozuki> struct A {
11:45 < bridge> <ryozuki> }
11:45 < bridge> <ryozuki> 
11:45 < bridge> <ryozuki> struct B {
11:45 < bridge> <ryozuki>     r: Rc<RefCell<String>>,
11:45 < bridge> <ryozuki>     a: A,
11:45 < bridge> <ryozuki> }
11:45 < bridge> <ryozuki> 
11:45 < bridge> <ryozuki> impl A {
11:45 < bridge> <ryozuki>     pub fn funca(&self, r: &mut String) {
11:45 < bridge> <ryozuki>         r.push('a');
11:45 < bridge> <ryozuki>     }
11:45 < bridge> <ryozuki> }
11:45 < bridge> <ryozuki> 
11:45 < bridge> <ryozuki> impl B {
11:45 < bridge> <ryozuki>     pub fn funcb(&self) {
11:45 < bridge> <ryozuki>         let mut borrowed = self.r.borrow_mut();
11:45 < bridge> <ryozuki>         self.a.funca(&mut borrowed);
11:45 < bridge> <ryozuki>     }
11:45 < bridge> <ryozuki> }
11:45 < bridge> <ryozuki> 
11:45 < bridge> <ryozuki> fn main() {
11:45 < bridge> <ryozuki>     let r: Rc<RefCell<String>> = Default::default();
11:45 < bridge> <ryozuki>     let x = B {
11:45 < bridge> <ryozuki>         r: r.clone(),
11:45 < bridge> <ryozuki>         a: A{},
11:45 < bridge> <ryozuki>     };
11:45 < bridge> <ryozuki> 
11:46 < bridge> <ryozuki> btw this is how i would do it
11:46 < bridge> <ryozuki> A simplydoesnt need to hold r
11:46 < bridge> <ryozuki> simply pass the mut ref when it needs on the fn
11:46 < bridge> <ryozuki> it compiles
11:46 < bridge> <ryozuki> now i go to work
11:47 < bridge> <ryozuki> this is why u can usually avoid refcells
11:47 < bridge> <ryozuki> on the second u dont need refcell for B either
11:47 < bridge> <ryozuki> they make life easier on some places and in some are needed ye
11:48 < bridge> <learath2> Makes sense for this specific tiny example, but I think the point is that there are many `A`s that maybe nested far deeper in hierarchy than in here
11:48 < bridge> <ryozuki> its hard to say without seeing the whole picture
11:48 < bridge> <learath2> And B may not even be the one that's directly holding A
11:48 < bridge> <learath2> Think `CComponent` and `CGraphics`
11:49 < bridge> <ryozuki> u have to structure things in rust like u would in rust
11:49 < bridge> <ryozuki> not like in java
11:50 < bridge> <ryozuki> this is why i find bevy amazing
11:50 < bridge> <ryozuki> bevy way is the way
11:50 < bridge> <ryozuki> i think its sensible to say, its better to have functions accept references to the objects u need and use them there instead of holding stuff in ur structs
11:51 < bridge> <ryozuki> limit the scope of ur references as much as possible
11:51 < bridge> <ryozuki> idk
11:51 < bridge> <Jupstar ‚ú™> and how is it doing it?
11:51 < bridge> <ryozuki> the ECS
11:51 < bridge> <learath2> But ECS hardly applies to this situation
11:52 < bridge> <ryozuki> xd
11:52 < bridge> <ryozuki> is his design optimal in the first place
11:52 < bridge> <learath2> Well I guess entities could have a sprite component, which the gfx can call render on with a reference to gfx
11:53 < bridge> <ryozuki> https://docs.rs/bevy_ecs/latest/bevy_ecs/
11:53 < bridge> <Jupstar ‚ú™> i started with passing everything around.
11:53 < bridge> <Jupstar ‚ú™> 
11:53 < bridge> <Jupstar ‚ú™> My point stands: it's simplicity vs compile time checks
11:53 < bridge> <ryozuki> design is not just passing all around
11:54 < bridge> <Jupstar ‚ú™> if you want automatic cleanup of resources on drop, you need a rc of that part of the graphics lib
11:54 < bridge> <ryozuki> but how u structure all ur code idk
11:54 < bridge> <Jupstar ‚ú™> else u need destroy manually
11:54 < bridge> <Jupstar ‚ú™> yes, that's why i tryhard about this problem to not fuck up
11:55 < bridge> <ryozuki> designing things like this is part of the hard problems in programming
11:55 < bridge> <ryozuki> the other is MT
11:55 < bridge> <ryozuki> :owo:
11:56 < bridge> <Jupstar ‚ú™> i defs find my current solution MUCH easier to use, and for an end user easier to not fuck up
11:56 < bridge> <Jupstar ‚ú™> 
11:56 < bridge> <Jupstar ‚ú™> 
11:56 < bridge> <Jupstar ‚ú™> but it
11:56 < bridge> <Jupstar ‚ú™> 1. makes the graphics comp harder to implement
11:56 < bridge> <Jupstar ‚ú™> 2. it still has some _smaller_ holes for potential panics, which is dislike
11:56 < bridge> <learath2> You know where it isn't hard? C
11:56 < bridge> <learath2> No refcells, no Rcs, no borrowchecking. Just don't forget to free stuff bozo :gigachad3:
11:57 < bridge> <Jupstar ‚ú™> üòè
11:57 < bridge> <Jupstar ‚ú™> let's _upgrade_ to c
11:57 < bridge> <ryozuki> lots of segfaults
11:58 < bridge> <ryozuki> also he wants to abuse RAII
11:58 < bridge> <ryozuki> if he did manual freeing of resources he could just use a storage
11:58 < bridge> <learath2> RAII is for weak lazy men. Jupstar is big strong man
11:58 < bridge> <ryozuki> and it would be simple
11:58 < bridge> <ryozuki> in rust too
11:58 < bridge> <ryozuki> honestly i would probs go for some kind of storage
11:59 < bridge> <ryozuki> ecs kinda does that
12:00 < bridge> <Jupstar ‚ú™> then the `key`/`index` to that storage can be invalid
12:00 < bridge> <Jupstar ‚ú™> i prefer the "if it exists, it must exist" philosophy :brownbear:
12:01 < bridge> <Jupstar ‚ú™> i prefer the "if it can exists, it must exist" philosophy :brownbear:
12:01 < bridge> <learath2> Q: Can't you make sure by some other means that all components die before the gfx one instead of an Rc? Isn't there a hierarchical owner of the gfx component that when dead it doesnt even make sense for the gfx component to live on?
12:02 < bridge> <Jupstar ‚ú™> so you want me to use a ptr? üòÑ
12:02 < bridge> <learath2> I fail to see why one might want the components to be able to keep the gfx component alive if the client itself is gone e.g.
12:03 < bridge> <Jupstar ‚ú™> it don't want or need this actually
12:03 < bridge> <Jupstar ‚ú™> it's simply that resources hold a ref to the graphics comp for automatic cleanup, and i don't want to pass aroud graphics component every time
12:04 < bridge> <Jupstar ‚ú™> i introduced a concept of graphics programs, which should work as if it itself is a graphics implementation
12:04 < bridge> <Jupstar ‚ú™> e.g. the map rendering is not part of the graphics component anymore.
12:04 < bridge> <Jupstar ‚ú™> 
12:04 < bridge> <Jupstar ‚ú™> engine & game are 100% split
12:04 < bridge> <learath2> Ah, hm that is actually a rather annoying steucture indeed
12:05 < bridge> <learath2> Too much thinking for me. I have a bag to pack, cya'll
12:05 < bridge> <ryozuki> maybe u could a way would be to have a struct wrapping the gfx with interior mutability and then u pass the outer struct by  a plain non mut reference
12:05 < bridge> <ryozuki> rust will make sure the struct outlives conponents holding a ref to that struct
12:06 < bridge> <ryozuki> components just need to hold a ref
12:06 < bridge> <ryozuki> not a mut ref
12:06 < bridge> <ryozuki> aka use interior mutability but hiding the rc in a struct u share by ref
12:07 < bridge> <ryozuki> hmm
12:07 < bridge> <ryozuki> xd
12:07 < bridge> <ryozuki> ok idk
12:07 < bridge> <ryozuki> u then expose the gfx methods via &self
12:07 < bridge> <ryozuki> or whathever
12:07 < bridge> <Jupstar ‚ú™> xd
12:07 < bridge> <Jupstar ‚ú™> that's indeed what it does, no refcell is public
12:08 < bridge> <ryozuki> ur code was public
12:08 < bridge> <Jupstar ‚ú™> in 99% it just works. but sometimes gfx internal components talk to each other.
12:08 < bridge> <Jupstar ‚ú™> 
12:08 < bridge> <Jupstar ‚ú™> Additionally i have at least one hole where i either pass a closure (harder to use) or have to make sure the graphics api is not in use already
12:09 < bridge> <Jupstar ‚ú™> well it's very outdated. currently i code so much shit xD
12:09 < bridge> <Jupstar ‚ú™> 
12:09 < bridge> <Jupstar ‚ú™> can't show this trash
12:12 < bridge> <ryozuki> https://austral-lang.org/
12:12 < bridge> <ryozuki> Austral is a new systems programming language. It uses linear types to provide memory safety and capability-secure code, and is designed to be simple enough to be understood by a single person, with a focus on readability, maintainbility, and modularity
12:12 < bridge> <ryozuki> syntax is odd tho
12:12 < bridge> <ryozuki> ada like
12:17 < bridge> <learath2> Is there the concept of a call stack local variable in any language?
12:17 < bridge> <Jupstar ‚ú™> please invent one, i want to test it üòÑ
12:18 < bridge> <learath2> I will craft a language one day. Even if it won't be used by anyone I want to experiment
12:19 < bridge> <heinrich5991> what's a call-stack local variable?
12:20 < bridge> <heinrich5991> you mean a global variable? visible to the call stack?
12:20 < bridge> <heinrich5991> thread-local variable maybe?
12:22 < bridge> <ryozuki> my company wants to make a lang
12:22 < bridge> <ryozuki> based on rust safety with go simplicity
12:23 < bridge> <ryozuki> inspired by the lang i sent
12:23 < bridge> <ryozuki> linear types
12:23 < bridge> <ryozuki> arent variables stored in the stack anyway
12:23 < bridge> <ryozuki> or register when possible
12:24 < bridge> <learath2> A global variable of sorts that would lie in some higher stack frame. Maybe like an `export` of sorts. With visibility only within that chain of calls until the function who initially exported it returns
12:24 < bridge> <learath2> Like passing it down all the way but more ergonomic
12:33 < bridge> <Jupstar ‚ú™> that's the solution: no stack, no call frames => no problems
12:34 < bridge> <Jupstar ‚ú™> put everything in one big function xdd
12:37 < bridge> <TsFreddie> how can a company just afford to make a lang
12:37 < bridge> <TsFreddie> our company doesn't even want us to make our own playercontroller
12:41 < bridge> <Jupstar ‚ú™> that doesn't sound like a problem of money
12:45 < bridge> <TsFreddie> it is if we need more than a week to make one
12:45 < bridge> <ryozuki> xd
12:46 < bridge> <TsFreddie> btw we made our own anyway
12:46 < bridge> <TsFreddie> <a:Catxplosion:1082715870893195274>
12:46 < bridge> <ryozuki> :poggers2:
12:46 < bridge> <TsFreddie> and it sucks now
12:47 < bridge> <TsFreddie> stair handling is broken:kek: and i dont have time to fix it
12:47 < bridge> <TsFreddie> shouldve bought one or steal one
12:48 < bridge> <Jupstar ‚ú™> man i really wonder if your companies are really so horrible or if you exaggerate xd
12:48 < bridge> <TsFreddie> definitely exaggerate
12:48 < bridge> <Jupstar ‚ú™> xD
12:48 < bridge> <TsFreddie> but also not?
12:48 < bridge> <learath2> YES
12:48 < bridge> <TsFreddie> it sounds bad
12:49 < bridge> <TsFreddie> i just dont like working if you cant tell
12:50 < bridge> <TsFreddie> and i think everyone is kinda stupid in the team.:owo:
12:50 < bridge> <Jupstar ‚ú™> i feel that. the only difference is, that it includes myself üòâ
12:50 < bridge> <TsFreddie> :owo: you're better than me
12:51 < bridge> <ryozuki> vscode now supports floating windows
12:51 < bridge> <ryozuki> meaning u can move a opened file to second display
12:51 < bridge> <Jupstar ‚ú™> omg
12:51 < bridge> <TsFreddie> ye, thats cool
12:51 < bridge> <ryozuki> biggest feature
12:51 < bridge> <ryozuki> requested since years
12:51 < bridge> <Jupstar ‚ú™> now i just need 2 screens so it's worth it
12:52 < bridge> <TsFreddie> i want the sidebar to float tho
12:52 < bridge> <ryozuki> :owo: float this
12:52 < bridge> <TsFreddie> cuz the explorer takes half of my vertical screen
12:53 < bridge> <Jupstar ‚ú™> you can make the sidebar be a bottombar
12:54 < bridge> <TsFreddie> can you now. havent used vscode for quite a while
12:54 < bridge> <Jupstar ‚ú™> u can drag the icon to some places xd
12:55 < bridge> <TsFreddie> isn't explorer fixed to be on the side.
12:55 < bridge> <TsFreddie> anyway i better check myself
12:55 < bridge> <Jupstar ‚ú™> u gotta drag the explorer icon, then it's not fixed
12:56 < bridge> <milkeeycat> any neovim enjoyers? üò¨
12:56 < bridge> <TsFreddie> i know enough vim to close it
12:57 < bridge> <TsFreddie> :kek:
12:58 < bridge> <TsFreddie> also i know enough to mess my colleague when one of them actually uses a vim plugin in vscode. i hit that I key quicker than he wanted to explain it to me.
12:59 < bridge> <TsFreddie> also i know enough to mess my colleague when one of them actually uses a vim plugin in vscode. i be hitting that I key quicker than him wanting to explain it to me.
13:01 < bridge> <milkeeycat> I love `%` and `_`
13:01 < bridge> <Jupstar ‚ú™> i love changing my text editor alternatives to not use vim
13:49 < bridge> <cyberfighter> i gotta get my settings back but im lazy af
14:39 < ws-client> <ChillerDragon> @milkeeycat what is % and _ and do they work in vanilla vim too?
14:47 < bridge> <milkeeycat> Do you use vim? üòÆ
14:52 < bridge> <milkeeycat> _ goes to first non empty character and % goes to.. eeeh. Opposite character. Like you have { hdhfus } if ur cursor under  { and u press % it goes to }
14:58 < bridge> <_voxeldoesart> #1234
14:58 < bridge> <DDNet> https://github.com/ddnet/ddnet/issues/1234
15:16 < bridge> <cyberfighter> rest in piece
15:18 < bridge> <sedonya> Windows :brownbear:
15:18 < bridge> <sedonya> https://cdn.discordapp.com/attachments/293493549758939136/1186673974495686796/image.png?ex=65941b42&is=6581a642&hm=a0ffce0477b5311bdbf56f5a6a5625981570c5566bae3cbd24827731b6f0a52e&
15:29 < bridge> <Jupstar ‚ú™> Checked out libs?
15:29 < bridge> <sedonya> –î–∞
15:29 < bridge> <sedonya> Yes
15:30 < bridge> <sedonya> Everything is in place on GitHub and on my PC
15:30 < bridge> <sedonya> I also tried to fix it with this
15:30 < bridge> <sedonya> https://cdn.discordapp.com/attachments/293493549758939136/1186677049176371281/image.png?ex=65941e1f&is=6581a91f&hm=d3fe322d6505aa483d6bbaf9c946373e37c2f82fe35b8d71f7c6d3dd1528e898&
15:31 < bridge> <sedonya> I also wrote ``git submodule update --init --recursive``
15:32 < bridge> <Jupstar ‚ú™> Maybe that is the problem
15:32 < bridge> <Jupstar ‚ú™> I never tested it with the sdk xd
15:32 < bridge> <Jupstar ‚ú™> It must be in your path and stuff
15:33 < bridge> <Jupstar ‚ú™> Since our CI isn't failing it should work on Windows
15:34 < bridge> <sedonya> I'm compiling dfng <3
15:40 < bridge> <Jupstar ‚ú™> Then you can also use -DCLIENT=OFF for cmake, i guess
15:41 < bridge> <sedonya> thx
15:44 < bridge> <sedonya> https://cdn.discordapp.com/attachments/293493549758939136/1186680365964869742/image.png?ex=65942136&is=6581ac36&hm=fdb17190f5173feda31a59142daf5d2960f25ba68e5a47488bc0cad6cd15bcdb&
15:48 < bridge> <Jupstar ‚ú™> To me that looks like a clear indicator that libs are not checked out
15:49 < bridge> <sedonya> maybe xd
15:49 < bridge> <sedonya> but I didn't change anything in the repository
15:49 < bridge> <Jupstar ‚ú™> I dunno. Just download the ones from ddnet
15:49 < bridge> <Jupstar ‚ú™> And put them there
15:49 < bridge> <Jupstar ‚ú™> It should: tm: work
16:32 < bridge> <towux> I solved the problem with connecting to my server, the problem was that I have an ovh anti-ddos and because of this, no one can log in until they establish a direct connection to the server (i.e. until they add it to the hosts file (maybe))
18:24 < bridge> <deen> @gummibaer12345 Thank you!
18:24 < bridge> <gummibaer12345> :3
18:25 < bridge> <gummibaer12345> :3 Merry christmas to you guys
19:14 < bridge> <heinrich5991> only 45‚Ç¨ missing until 2023 is completely funded!
19:15 < bridge> <heinrich5991> sounds like a thread-local `Option<>` to me
19:17 < bridge> <_voxeldoesart> wait arent tees already LERPed?
19:21 < bridge> <learath2> Just a tad too large in scope no?
19:42 < bridge> <Jupstar ‚ú™> well thread locals are not readable by threads xd
19:43 < bridge> <Jupstar ‚ú™> well thread locals are not readable by other threads xd
19:43 < bridge> <Jupstar ‚ú™> depends if u want to support this, or if that is out of your stack stack frame
19:43 < bridge> <Jupstar ‚ú™> @learath2 do you like coroutines?
19:47 < bridge> <StormAh~> Uhh, are they?
19:48 < bridge> <learath2> I like the idea of them, but I honestly dont ever think in terms of them nor do many languages support them, so I rarely get to use them
19:48 < bridge> <learath2> Maybe if I learn some go
19:52 < bridge> <patiga> yes, otherwise the maximum would be 50 frames per second
19:53 < bridge> <patiga> > raibow tees
19:53 < bridge> <patiga> small typo
19:56 < bridge> <ryozuki> intratick
19:59 < bridge> <_voxeldoesart> wait then what IS lerped?
20:02 < bridge> <milkeeycat> whats radmin doing there?
20:02 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1186745356214599680/image.png?ex=65945dbd&is=6581e8bd&hm=7a56fae41214ec4b37b76239490f219ccee1e3948aab705a57e14524a7dd7e9a&
20:02 < bridge> <milkeeycat> @stormaxd
20:04 < bridge> <milkeeycat> whats radmin doing on ur website?
20:04 < bridge> <milkeeycat> https://cdn.discordapp.com/attachments/293493549758939136/1186745356214599680/image.png?ex=65945dbd&is=6581e8bd&hm=7a56fae41214ec4b37b76239490f219ccee1e3948aab705a57e14524a7dd7e9a&
20:05 < bridge> <StormAh~> Radmin template
20:05 < bridge> <StormAh~> :justatest:
20:11 < bridge> <_voxeldoesart> üó£Ô∏è
20:15 < bridge> <StormAh~> Means unlocked feets, hammer etc
20:16 < bridge> <StormAh~> That what you can see on this video
20:16 < bridge> <StormAh~> https://cdn.discordapp.com/attachments/295908390956433410/1186106431762604112/Disability_2023-12-18_02-39-07.mp4?ex=65920ab2&is=657f95b2&hm=7b6b0b52f6d2f37bed6ca27f5124009a9ad8781d7a298c7167e583635858df36&
20:16 < bridge> <_voxeldoesart> oh thaat
20:17 < bridge> <cyberfighter> mid map
20:17 < bridge> <_voxeldoesart> isnt it just the feet and hammer lagging behind 1 frame
20:20 < bridge> <ryozuki> this feature is not original btw
20:20 < bridge> <kekomonter> And this have a lot of bugs, cuz I programmed this :troll:
20:21 < bridge> <ryozuki> https://www.youtube.com/watch?v=0dq1BpvjWEE
20:21 < bridge> <ryozuki> look my vid from 8 years ago
20:21 < bridge> <ryozuki> their feet
20:21 < bridge> <kekomonter> Ye, this was taken from goreworlds to my client, and from my client to storm client
20:21 < bridge> <StormAh~> Yeah i saw that somewhere already
20:21 < bridge> <StormAh~> However you can just turn it off
20:22 < bridge> <ryozuki> the blood is funny
20:22 < bridge> <StormAh~> github:hehehe:
20:22 < bridge> <_voxeldoesart> i gotta make an offline client so i can just fuck around
20:23 < bridge> <_voxeldoesart> i love the teeworlds engine
20:23 < bridge> <_voxeldoesart> has so much potential
20:23 < bridge> <kekomonter> I love teewars engine, has so much potential
20:24 < bridge> <StormAh~> I love teeworlds
20:24 < bridge> <StormAh~> That's all i can say
20:24 < bridge> <ryozuki> i love rust
20:24 < bridge> <ryozuki> rustworlds*
20:24 < bridge> <kekomonter> I love asm
20:24 < bridge> <_voxeldoesart> im blocking you
20:24 < bridge> <kekomonter> Binworlds*
20:25 < bridge> <ryozuki> https://tenor.com/view/ni%C3%B1o-asustado-huh-what-meme-stare-gif-16752413
20:25 < bridge> <_voxeldoesart> 1 blocked messahe
20:25 < bridge> <StormAh~> Blockworlds
20:25 < bridge> <_voxeldoesart> 1 blocked message
20:25 < bridge> <ryozuki> not like we interact much lately xD
20:25 < bridge> <_voxeldoesart> i am at peace now
20:26 < bridge> <ryozuki> good, i can say linux without u answering windows
20:26 < bridge> <ryozuki> :3
20:27 < bridge> <ryozuki> https://andrewkchan.dev/posts/fire.html
20:27 < bridge> <patiga> maybe "fresh animations"
20:27 < bridge> <StormAh~> Fair, guess i have to rename it
20:27 < bridge> <kekomonter> Lagging animations
20:27 < bridge> <ryozuki> https://www.jpl.nasa.gov/news/nasas-tech-demo-streams-first-video-from-deep-space-via-laser
20:27 < bridge> <ryozuki> nasa sent a cat video
20:27 < bridge> <ryozuki> to space
20:27 < bridge> <ryozuki> based
20:27 < bridge> <StormAh~> cursed*
20:30 < bridge> <_voxeldoesart> yea
20:31 < bridge> <blaiszephyr> call it "lerp_ported_from_Goresworld_to_toilet_to_stormax"
20:32 < bridge> <blaiszephyr> call it "cursed_animations_ported_from_Goresworld_to_toilet_to_stormax"
20:32 < bridge> <_voxeldoesart> tbh if it was less dramatic itd be cool
20:33 < bridge> <ryozuki> @learath2 did u know ocaml has += for type definitions
20:34 < bridge> <kekomonter> Imagine how config variables will be named :justatest:
20:34 < bridge> <learath2> I barely knew ocaml existed
20:34 < bridge> <_voxeldoesart> camel
20:34 < bridge> <ryozuki> https://v2.ocaml.org/manual/extensiblevariants.html
20:34 < bridge> <blaiszephyr> Objective Camel!
20:34 < bridge> <ryozuki> honestly ocaml is big
20:34 < bridge> <ryozuki> its used to make compilers
20:34 < bridge> <ryozuki> i havent learned it tho
20:34 < bridge> <ryozuki> but the bad thing is it has circular deps problem
20:35 < bridge> <learath2> I would make my compiler in C, don't need no camel
20:35 < bridge> <ryozuki> xd
20:35 < bridge> <blaiszephyr> you keep on writing rust wrong smh
20:35 < bridge> <ryozuki> @learath2 its rly rly easy to make a compilere in ocaml
20:35 < bridge> <ryozuki> i think it falls nicely
20:35 < bridge> <ryozuki> rust was originally made with ocaml
20:35 < bridge> <ryozuki> llvm has oficial bindings in ocaml
20:36 < bridge> <learath2> The rust lobby has arrived
20:36 < bridge> <ryozuki> xd
20:36 < bridge> <blaiszephyr> <a:peepoShy:918939050470170645>
20:36 < bridge> <_voxeldoesart> the unfunniest group of people ever
20:37 < bridge> <blaiszephyr> i mean i dont wanna brag, but i not only enjoy rust... i use arch btw!
20:37 < bridge> <_voxeldoesart> ok yeah thats my push thank you
20:37 < bridge> <ryozuki> gentoo here
20:38 < bridge> <blaiszephyr> did i just get blocked ._.
20:38 < bridge> <ryozuki> why do u care
20:38 < bridge> <blaiszephyr> true
20:38 < bridge> <ryozuki> the holy path to rust has obstacles
20:38 < bridge> <ryozuki> now join the church of memory safety
20:39 < bridge> <ryozuki> and confess (tell me ur unsafe uses) to me in the confession box
20:39 < bridge> <ryozuki> :justatest:
20:39 < bridge> <StormAh~> Voxel just gone
20:39 < bridge> <ryozuki> https://en.wikipedia.org/wiki/Confession_(religion)
20:39 < bridge> <ryozuki> XD
20:40 < bridge> <StormAh~> What??
20:41 < bridge> <blaiszephyr> not everyone can be as superior as us rust enjoyers
20:41 < bridge> <kekomonter> You said rust?
20:41 < bridge> <kekomonter> https://cdn.discordapp.com/attachments/293493549758939136/1186755245527806134/ryo.png?ex=659466f3&is=6581f1f3&hm=f64756b30730724e087d6acab63bbcf8a701c43315b3375f697b66861adf1423&
20:42 < bridge> <Jupstar ‚ú™> witzig witzig
20:42 < bridge> <learath2> Arch is old news. All the real cool people use gentoo now
20:43 < bridge> <blaiszephyr> aight give me 2 hours!
20:43 < bridge> <blaiszephyr> https://cdn.discordapp.com/attachments/293493549758939136/1186755677306224660/image.png?ex=6594675a&is=6581f25a&hm=8e6a643c3e6410c07a96531f377d926f790aa81356539c4e583f068cac628b04&
20:43 < bridge> <ryozuki> mentioning zig is a sin here
20:44 < bridge> <ryozuki> üò¨
20:44 < bridge> <blaiszephyr> *forgive me Ryozuki for i have sinned*
21:35 < ChillerDragon> @milkeeycat _ goes to start of line and % does nothing gg
21:36 < bridge> <ryozuki> https://cdn.discordapp.com/attachments/293493549758939136/1186769081941119047/GBsn8TGXIAAEmJM.png?ex=659473d6&is=6581fed6&hm=c186ef548cf3516f8e3431f4572c9c1e01eb6a72f866ad3b25a1726e7a8b6aec&
21:37 < ChillerDragon> xd
21:37 < bridge> <ryozuki> xd
21:38 < ChillerDragon> isnt zig the new shit that will replace rust?
21:38 < bridge> <ryozuki> no it has no memor safety
21:38 < bridge> <ryozuki> its hipster C
21:38 < ChillerDragon> wot no memory safety?
21:38 < ChillerDragon> thats so 1999
21:38 < bridge> <ryozuki> yeah
21:39 < bridge> <milkeeycat> Time to try neovim üôÇ
21:39 < ChillerDragon> i tried in neovim too
21:39 < ChillerDragon> same result
21:39 < bridge> <milkeeycat> Wat
21:39 < ChillerDragon> german keyboard layout :p
21:39 < ChillerDragon> :beer:
21:39 < ChillerDragon> :de:
21:40 < bridge> <milkeeycat> It's default motions, they have to work xd
21:40 < ChillerDragon> not on my machine
21:40 < bridge> <milkeeycat> Works on ukrainian, russian, czech and english layouts
21:40 < ChillerDragon> i use f<space> for those scenarios i guess
21:40 < ChillerDragon> or f,
21:40 < ChillerDragon> germany issue then
21:40 < bridge> <milkeeycat> XD
21:42 < bridge> <milkeeycat> Do u have config for ur vim on gh? üòÆ
21:47 < bridge> <milkeeycat> chillerdragon: was ur cursor at '{' char when u were pressing `%`?
22:01 < bridge> <cellegenrih> https://cdn.discordapp.com/attachments/293493549758939136/1186775272960295033/Screenshot_2023-12-19-22-01-08-032_com.brave.browser.jpg?ex=6594799a&is=6582049a&hm=050178256d3243b6cf33e3beb2823f0452c173a011f06e882d50ffc1febc2d3d&
22:01 < bridge> <cellegenrih> https://tenor.com/view/detroit-become-human-gif-26524809
22:01 < bridge> <cellegenrih> @ryozuki @deen
22:02 < bridge> <ryozuki> xd
22:03 < bridge> <heinrich5991> but a callstack usually lives in one thread only, no?
22:03 < bridge> <heinrich5991> rust too, no?
22:04 < bridge> <Jupstar ‚ú™> sounded more like a var that lives on the stack somewhere
22:05 < bridge> <cyberfighter> instead of donating 100 euros you should donate 1 euro 100 times and add a different name each time
22:05 < bridge> <cyberfighter> :troll:
22:05 < bridge> <Jupstar ‚ú™> real pros let the girl die
22:05 < bridge> <Jupstar ‚ú™> üò¨
22:05 < bridge> <heinrich5991> C seems like the wrong choice, given no ADTs
22:06 < bridge> <cellegenrih> fuck missed opportunity
22:06 < bridge> <cellegenrih> https://tenor.com/view/death-gif-24356219
22:14 < bridge> <blaiszephyr> is there a specific reasons /showothers only works on the client you activate it on?, if its off and i set it on with /showothers, and switch to dummy, its disabled there
22:15 < bridge> <heinrich5991> there's a technical reason, but no concrete design reason, I guess
23:04 < bridge> <learath2> Doesn‚Äôt rust only have them in nightly?
23:06 < bridge> <learath2> Well I was half jesting. The only reason I would even consider C for a compiler is because something so complex I probably should write in the language I‚Äôm most familiar with
23:12 < bridge> <heinrich5991> ah, futures are not co-routine-y enough?
23:12 < bridge> <heinrich5991> yes
23:30 < bridge> <deen> @cellegenrih Thanks again for the second donation in 2 days!
23:30 < bridge> <deen> @zwelf2 Thanks for the donation, you two filled up the missing 45 ‚Ç¨ kind of at once üòÑ
23:32 < bridge> <heinrich5991> ü§î
23:32 < bridge> <heinrich5991> https://cdn.discordapp.com/attachments/293493549758939136/1186798277505589308/image.png?ex=65948f07&is=65821a07&hm=c360a8249a728356f69a659a7a163c4ee13a4c7241f4365af8d9a02ad747496a&
23:35 < bridge> <heinrich5991> completely funded üéâ
23:42 < bridge> <blaiszephyr> :poggers2:
23:53 < bridge> <chillerdragon> ChillerDragon/dotfiles
23:54 < bridge> <chillerdragon> My cursor was in a word I had no { only spaces I thought it also jumps to spaces
23:54 < bridge> <chillerdragon> Do I need a literal { ?
