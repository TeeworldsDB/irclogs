10:55 <+bridge> [ddnet] <Learath2> > [11:36 PM] fokkonaut: i dont get what exactly you mean, but it would not work
10:55 <+bridge> [ddnet] <Learath2> How do you know it wouldn't work if you don't even get it? ðŸ˜„
11:01 <+bridge> [ddnet] <Trafalgar Law> https://tenor.com/view/shots-fired-gun-gif-4566555
13:20 <+bridge> [ddnet] <fokkonaut> @Learath2 I think it wouldnt because I cant think of a nice way doing it
13:22 <+bridge> [ddnet] <fokkonaut> I think heinrich doesnt get the problem
13:34 <+bridge> [ddnet] <heinrich5991> @deen what are the interactions with players-cache? ranks.py generates it, players.py reads it?
14:45 <+bridge> [ddnet] <Learath2> @heinrich5991 do you have a couple minutes?
14:46 <+bridge> [ddnet] <heinrich5991> yes
14:46 <+bridge> [ddnet] <heinrich5991> another lecture got cancelled
14:46 <+bridge> [ddnet] <heinrich5991> uni is very good with internet
14:46 <+bridge> [ddnet] <Learath2> I'm having trouble crafting an algorithm, I thought maybe you could have an idea
14:47 <+bridge> [ddnet] <Learath2> I have two list of tuples describing the route taken by two people, in the format `(total time until node, node)`, I need to find if these two people are at the same place at the same time
14:48 <+bridge> [ddnet] <Learath2> now that would be simple enough, but both the routes have a special destination point, at which they spend an extra 30 time
14:49 <+bridge> [ddnet] <Learath2> (you spend only an instant in the other nodes)
14:50 <+bridge> [ddnet] <heinrich5991> so they only have a chance for meeting at the nodes in an instant? and at the destination points for 30min?
14:50 <+bridge> [ddnet] <Learath2> Yes, they can only meet at an intermediate node if the tuples match exactly
14:50 <+bridge> [ddnet] <Learath2> Both lists are sorted w.r.t total time until node
14:50 <+bridge> [ddnet] <heinrich5991> or if one is at its special destination node and the other is at the same node which is intermediate for him?
14:51 <+bridge> [ddnet] <Learath2> yes
14:51 <+bridge> [ddnet] <heinrich5991> I'd iterate over both the lists at the same time
14:51 <+bridge> [ddnet] <heinrich5991> adding another special-cased node for the end of the arrival point stay
14:54 <+bridge> [ddnet] <Learath2> but that doesn't reduce the problem to the case with no destination
14:54 <+bridge> [ddnet] <Learath2> does it?
14:54 <+bridge> [ddnet] <heinrich5991> no, doesn't
14:54 <+bridge> [ddnet] <heinrich5991> still needs special-cased support for the destination point
14:54 <+bridge> [ddnet] <heinrich5991> you step one of the iterators (the lower one)
14:55 <+bridge> [ddnet] <heinrich5991> now check whether the new node is equal to the other or the other's latest is the destination point
14:55 <+bridge> [ddnet] <heinrich5991> ah, could work without the inserted node as well
14:57 <+bridge> [ddnet] <heinrich5991> i.e. check whether the new node is completely equal or equal in the place and within 30min of arrival
14:57 <+bridge> [ddnet] <heinrich5991> i.e. check whether the new node is completely equal or equal in the place and within 30min of arrival and it's the destination node
14:57 <+bridge> [ddnet] <Learath2> hm, if it's within 30 of arrival and it's one of the either destination nodes?
14:57 <+bridge> [ddnet] <Learath2> I think that would work
14:58 <+bridge> [ddnet] <heinrich5991> no, if it's *the* destination node
14:58 <+bridge> [ddnet] <heinrich5991> you only need to check one way
14:59 <+bridge> [ddnet] <Learath2> ah because only the user that's in the past moves
16:27 <+bridge> [ddnet] <deen> @heinrich5991 correct
20:35 <+bridge> [ddnet] <jao> @deen ``UnicodeDecodeError: 'ascii' codec can't decode byte 0xe0 in position 1: ordinal not in range(128)``
20:47 <@deen> ok, so we still have some incompatibility there. how about .decode('utf-8')?
20:47 <+bridge> [ddnet] <heinrich5991> the error happens as it's reading the cache file
20:47 <+bridge> [ddnet] <heinrich5991> before anything happens
20:47 <@deen> oh
20:48 <@deen> didn't happen for me, weird
20:48 <+bridge> [ddnet] <heinrich5991> ```
20:48 <+bridge> [ddnet] <heinrich5991>     return pickle.load(reader)
20:48 <+bridge> [ddnet] <heinrich5991> UnicodeDecodeError: 'ascii' codec can't decode byte 0xe0 in position 1: ordinal not in range(128)
20:48 <+bridge> [ddnet] <heinrich5991> ```
20:49 <+bridge> [ddnet] <heinrich5991> ```
20:49 <+bridge> [ddnet] <heinrich5991> Traceback (most recent call last):
20:49 <+bridge> [ddnet] <heinrich5991>   File "test.py", line 8, in <module>
20:49 <+bridge> [ddnet] <heinrich5991>     print(cache.get(b'jao'))
20:49 <+bridge> [ddnet] <heinrich5991>   File "/home/teeworlds/.local/lib/python3.7/site-packages/diskcache/core.py", line 1198, in get
20:49 <+bridge> [ddnet] <heinrich5991>     value = self._disk.fetch(mode, filename, db_value, read)
20:49 <+bridge> [ddnet] <heinrich5991>   File "/home/teeworlds/.local/lib/python3.7/site-packages/diskcache/core.py", line 303, in fetch
20:49 <+bridge> [ddnet] <heinrich5991>     return pickle.load(reader)
20:49 <+bridge> [ddnet] <heinrich5991> UnicodeDecodeError: 'ascii' codec can't decode byte 0xe0 in position 1: ordinal not in range(128)
20:49 <+bridge> [ddnet] <heinrich5991> ```
22:24 <+bridge> [ddnet] <heinrich5991> overengineering http masters :<
23:43 <+ChillerDragon> updating macOS is fun :D https://zillyhuhn.com/cs/.1587498918.png
