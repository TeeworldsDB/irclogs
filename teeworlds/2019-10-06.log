00:17 < bridge> [teeworlds] <jxsl13> I made a tw discord bot concept. if somone would like to use it: https://github.com/jxsl13/TeeworldsDiscordBot
00:17 < bridge> [teeworlds] <jxsl13> have fun
00:19 < bridge> [teeworlds] <jxsl13> or just add https://discordapp.com/api/oauth2/authorize?client_id=628902630617513985&permissions=116800&scope=bot to your server, as long as the bot still runs.
13:21 < bridge> [teeworlds] <ChillerDragon> Cool what does it do?
13:39 < bridge> [teeworlds] <jxsl13> just two basic functions, one is to look for an online player and the other one is to look for active tw servers based on a gametype.
14:06 < bridge> [teeworlds] <jxsl13> might add more functions if someone has any ideas
14:11 < bridge> [teeworlds] <fokkonaut> Make it livestreamable
14:11 < bridge> [teeworlds] <fokkonaut> Discord has live streams
14:11 < bridge> [teeworlds] <fokkonaut> make it controllable
14:11 < bridge> [teeworlds] <fokkonaut> !connect
14:11 < bridge> [teeworlds] <fokkonaut> !watch name
14:11 < bridge> [teeworlds] <fokkonaut> or id
14:12 < bridge> [teeworlds] <fokkonaut> only spectator mode
14:41 < bridge> [teeworlds] <jxsl13> seems to be too much of a hassle and I don't quite get what you exactly mean.
14:45 < bridge> [teeworlds] <jxsl13> the bot doesn't connect to servers, it just retrieves server information that one can also obtain from the server browser.
14:49 < bridge> [teeworlds] <fokkonaut> Yes, but you could connect it to some client thing
14:49 < bridge> [teeworlds] <fokkonaut> I know its hard xd
14:50 < bridge> [teeworlds] <jxsl13> it's written in python xD I'm surely not going to reimplement the client in python.
17:04 < bridge> [teeworlds] <ChillerDragon> lol rewriting whole tw client in python
22:23 < bridge> [teeworlds] <jxsl13> what kind of player disconnects are actually propagated to the CGameController ?
22:23 < bridge> [teeworlds] <jxsl13> only default ones or the timeout ones?
22:39 < bridge> [teeworlds] <jxsl13> hm, k seems to be called as callback in CServer::DelClientCallback
22:42 < bridge> [teeworlds] <heinrich5991> so all of them
22:42 < bridge> [teeworlds] <heinrich5991> even those that `CGameController` isn't aware of yet
22:45 < bridge> [teeworlds] <jxsl13> Oo
22:45 < bridge> [teeworlds] <heinrich5991> ah no, there's a check about that
22:46 < bridge> [teeworlds] <heinrich5991> hmmm
22:46 < bridge> [teeworlds] <heinrich5991> `>= CClient::STATE_READY`
22:47 < bridge> [teeworlds] <jxsl13> I replaced the normal m_apPlayer iteration with std::vector and I'm adding players (ids)to the vector whenever a player is constructed and removing the player when he's destroyed, dunno whether that adds any performance improvements or rather none
22:47 < bridge> [teeworlds] <jxsl13> I seem to be getting invalid ids in that vector
22:49 < bridge> [teeworlds] <jxsl13> hm, ok, might be something different there ._.. wrong vector
22:54 < bridge> [teeworlds] <jxsl13> basically even tho the client is not yet known by the controller, is can be dropped, but if it's not known, then there shouldn't exist any CPlayer object yet?
23:13 < rand> there shouldn't be a CPlayer without client at least
23:48 < bridge> [teeworlds] <Assa> if you use a vector and delete a random player
23:48 < bridge> [teeworlds] <Assa> the id is NOT the index in the vector, so be careful
23:55 < bridge> [teeworlds] <jxsl13> I know ðŸ˜„
