04:19 < ***> Buffer Playback...
04:19 < JulianAssange> [03:57:36] what's the release command
04:19 < JulianAssange> [03:57:39] for bam
04:19 < ***> Playback Complete.
08:41 < heinrich5991> JulianAssange: bam conf=release <target>
08:42 < heinrich5991> target being one of server, client, game, etc.
09:21 < JulianAssange> i liked the old method
09:21 <@matricks> CHANGE? I DONT LIKE CHANGE!
09:22 < JulianAssange> ^
09:25 <@matricks> https://www.youtube.com/watch?v=ZgIrXKpv2gw
09:25 < Nimda3> [YouTube] Title: Stewie I Don't Like Change | Rating: 4.69/5.00 | Views: 376,316
09:28 <@matricks> btw, this is kinda nice
09:28 <@matricks> https://github.com/simonask/simonask.github.com/blob/master/maybe.markdown
09:28 < JulianAssange> thanks for watching!
09:28 <@matricks> the resulting code looks a bit.. cluttery however
09:29 < JulianAssange> i haven't read it, but i thought o a way to avoid double free's
09:29 <@matricks> oh?
09:30 < JulianAssange> every time something is alloc'd, the name/address is added to a database(array), and when it is freed, it checks the database/array to see if it's still current
09:30 < JulianAssange> no idea about the performance of that
09:30 <@matricks> as everyone does
09:31 < JulianAssange> people actually do that? i just thought of it randomly when i was doing something else involving arrays
09:31 <@matricks> and thats a bad way of doing that
09:31 <@matricks> when you free a memory block, you check that block if it's still valid
09:31 <@matricks> there is a couple of problems however when free blocks gets merged back into a big block again
09:32 <@matricks> or, you alloc, free, alloc again, but then free it again and thinking it's the old block
09:32 <@matricks> there is a method usually called defered/delayed delete
09:32 <@matricks> instead of freeing the block, you keep it around for a certain time and free it later to be able to check if someone tries to free it again
09:33 <@matricks> also, you write a pattern to the memory so you can check if someone is touching that memory after it's been freed
09:33 < JulianAssange> optionally you could just do var=NULL after the free
09:33 <@matricks> which you usually do, but the problem is if you have several pointers to that memory
09:33 < JulianAssange> yeah
09:34 <@matricks> if the pointer is unique, you usually don't have any issues
09:34 < JulianAssange> that's usually just somebody else coming in and messing it up though
09:34 <@matricks> all these are common techs to find memory errors
09:35 <@matricks> an even more advanced method is to put each allocation into a separate page so you can actually mark the page as invalid when you free the memory and use the MMU to cause faults when someone accessing something that isn't valid anymore
09:35 < JulianAssange> people need to start doing it then
09:35 < JulianAssange> what method does teeworlds use?
09:35 <@matricks> I use valgrind
09:36 < JulianAssange> i mean, when writing
09:36 < JulianAssange> valgrind won't find problems unless they actually occur
09:36 < JulianAssange> (i think)
09:36 <@matricks> defered delete, and the page stuff isn't something you use in production due to the fact that it increases the memory usage a lot
09:36 <@matricks> JulianAssange: these system are runtime detections as well so
09:37 <@matricks> so no difference there
09:37 < JulianAssange> that's for detecting thenm, vs. them not occuring in the first place
09:38 <@matricks> not occuring in the first place... then you are doing something fancy static analysis in compile time
09:38 <@matricks> havn't really seen anything that can deduce stuff like that
09:41 < JulianAssange> or, just code properly I guess
09:42 <@matricks> yeah, but tools that helps you do that is a good thing, and no-body produces perfect code
11:59 < JulianAssange> https://scontent-a-lax.xx.fbcdn.net/hphotos-xap1/v/t1.0-9/12873_10152550301172204_3929437441141655720_n.jpg?oh=a3e8610570d25fff184ed2f482ebee79&oe=55655D2C
11:59 < JulianAssange> why do i look like a rapist?
